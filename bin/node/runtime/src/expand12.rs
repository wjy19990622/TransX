#![feature(prelude_import)]
// Copyright 2018-2019 Parity Technologies (UK) Ltd.
// This file is part of Substrate.

// Substrate is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Substrate is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Substrate.  If not, see <http://www.gnu.org/licenses/>.

//! The Substrate runtime. This can be compiled with ``#[no_std]`, ready for Wasm.

// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.
#![recursion_limit = "256"]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;

use rstd::prelude::*;
use support::{construct_runtime, parameter_types, weights::Weight,
              traits::{SplitTwoWays, Currency, Randomness}};
use primitives::u32_trait::{_1, _2, _3, _4};
use node_primitives::{AccountId, AccountIndex, Balance, BlockNumber, Hash,
                      Index, Moment, Signature, Count, USD, Workforce};
use sp_api::impl_runtime_apis;
use sp_runtime::{Permill, Perbill, ApplyExtrinsicResult, impl_opaque_keys,
                 generic, create_runtime_str};
use sp_runtime::curve::PiecewiseLinear;
use sp_runtime::transaction_validity::TransactionValidity;
use sp_runtime::traits::{self, BlakeTwo256, Block as BlockT, NumberFor,
                         StaticLookup, SaturatedConversion, OpaqueKeys};
use version::RuntimeVersion;
#[cfg(any (feature = "std", test))]
use version::NativeVersion;
use primitives::OpaqueMetadata;
use grandpa::AuthorityList as GrandpaAuthorityList;
use grandpa::fg_primitives;
use im_online::sr25519::{AuthorityId as ImOnlineId};
use authority_discovery_primitives::AuthorityId as AuthorityDiscoveryId;
use transaction_payment_rpc_runtime_api::RuntimeDispatchInfo;
use contracts_rpc_runtime_api::ContractExecResult;
use system::offchain::TransactionSubmitter;
use inherents::{InherentData, CheckInherentsResult};

#[cfg(any (feature = "std", test))]
pub use sp_runtime::BuildStorage;
pub use timestamp::Call as TimestampCall;
pub use balances::Call as BalancesCall;
pub use contracts::Gas;
pub use support::StorageValue;
pub use staking::StakerStatus;

/// Implementations of some helper traits passed into runtime modules as associated types.
pub mod impls {





    // Make the WASM binary available.

    // Per convention: if the runtime behavior changes, increment spec_version
    // and set impl_version to equal spec_version. If only runtime
    // implementation changes and behavior does not, then leave spec_version as
    // is and increment impl_version.



    // 4 parts (80%) goes to the treasury.
    // 1 part (20%) goes to the block author.










    // setting this to zero will disable the weight fee.
    // for a sane configuration, this should always be less than `AvailableBlockRatio`.










    // 1/4 the bonding duration.

    // send the slashed funds to the treasury.
    // rewards are minted from the void

    // One cent: $10,000 / MB

    // To cancel a proposal which has been passed, 2/3 of the council must agree to it.
    // Any single technical committee member may veto a coming council proposal, however they can
    // only do it once and it lasts only for the cooloff period.






    //	pub const PledgeAmount: Balance = 5*DOLLARS;  // 自己添加的参数




















    // α
    // β
    // SR
    // RR
    // SSR
    // OSR
    // MR
    // MSR

    // α
    // β
    // SR
    // RR
    // SSR
    // OSR
    // MR
    // MSR


    //type TranRuntime = Runtime;

    // Add `workforce` module
    // 将算力汇总信息归档到链上并不再修改


    //pub mod workforce;
    //impl workforce for Runtime {
    //	type Event = Event;
    //	type ArchiveDuration = ArchiveDuration;
    //}

    //Workforce: workforce::{Module, Call, Storage, Event<T>},














    // The choice of `c` parameter (where `1 - c` represents the
    // probability of a slot being empty), is done in accordance to the
    // slot duration and expected target block time, for safely
    // resisting network delays of maximum two seconds.
    // <https://research.web3.foundation/en/latest/polkadot/BABE/Babe/#6-practical-results>












    // Invariant. Always must be like this to have a sane chain.

    // Warning.

    //! Some configurable implementations as associated type for the substrate runtime.
    use node_primitives::Balance;
    use sp_runtime::traits::{Convert, Saturating};
    use sp_runtime::{Fixed64, Perbill};
    use support::{traits::{OnUnbalanced, Currency, Get}, weights::Weight};
    use crate::{Balances, System, Authorship, MaximumBlockWeight,
                NegativeImbalance};
    pub struct Author;
    impl OnUnbalanced<NegativeImbalance> for Author {
        fn on_nonzero_unbalanced(amount: NegativeImbalance) {
            Balances::resolve_creating(&Authorship::author(), amount);
        }
    }
    /// Struct that handles the conversion of Balance -> `u64`. This is used for staking's election
    /// calculation.
    pub struct CurrencyToVoteHandler;
    impl CurrencyToVoteHandler {
        fn factor() -> Balance {
            (Balances::total_issuance() / u64::max_value() as Balance).max(1)
        }
    }
    impl Convert<Balance, u64> for CurrencyToVoteHandler {
        fn convert(x: Balance) -> u64 { (x / Self::factor()) as u64 }
    }
    impl Convert<u128, Balance> for CurrencyToVoteHandler {
        fn convert(x: u128) -> Balance { x * Self::factor() }
    }
    /// Convert from weight to balance via a simple coefficient multiplication
    /// The associated type C encapsulates a constant in units of balance per weight
    pub struct LinearWeightToFee<C>(rstd::marker::PhantomData<C>);
    impl <C: Get<Balance>> Convert<Weight, Balance> for LinearWeightToFee<C> {
        fn convert(w: Weight) -> Balance {
            let coefficient = C::get();
            Balance::from(w).saturating_mul(coefficient)
        }
    }
    /// Update the given multiplier based on the following formula
    ///
    ///   diff = (previous_block_weight - target_weight)
    ///   v = 0.00004
    ///   next_weight = weight * (1 + (v . diff) + (v . diff)^2 / 2)
    ///
    /// Where `target_weight` must be given as the `Get` implementation of the `T` generic type.
    /// https://research.web3.foundation/en/latest/polkadot/Token%20Economics/#relay-chain-transaction-fees
    pub struct TargetedFeeAdjustment<T>(rstd::marker::PhantomData<T>);
    impl <T: Get<Perbill>> Convert<Fixed64, Fixed64> for
     TargetedFeeAdjustment<T> {
        fn convert(multiplier: Fixed64) -> Fixed64 {
            let block_weight = System::all_extrinsics_weight();
            let max_weight = MaximumBlockWeight::get();
            let target_weight = (T::get() * max_weight) as u128;
            let block_weight = block_weight as u128;
            let positive = block_weight >= target_weight;
            let diff_abs =
                block_weight.max(target_weight) -
                    block_weight.min(target_weight);
            let diff =
                Fixed64::from_rational(diff_abs as i64, max_weight as u64);
            let diff_squared = diff.saturating_mul(diff);
            let v = Fixed64::from_rational(4, 100_000);
            let v_squared_2 = Fixed64::from_rational(1, 1_000_000_000);
            let first_term = v.saturating_mul(diff);
            let second_term = v_squared_2.saturating_mul(diff_squared);
            if positive {
                let excess = first_term.saturating_add(second_term);
                multiplier.saturating_add(excess)
            } else {
                let negative = first_term - second_term;
                multiplier.saturating_sub(negative).max(Fixed64::from_rational(-1,
                                                                               1))
            }
        }
    }
}
pub mod register {
    type BalanceOf<T>
        =
        <<T as Trait>::Currency1 as
        Currency<<T as system::Trait>::AccountId>>::Balance;
    use support::traits::{Get, Currency, ReservableCurrency};
    use rstd::prelude::*;
    use support::{debug, ensure, decl_module, decl_storage, decl_event,
                  dispatch::Result, weights::{SimpleDispatchInfo},
                  StorageValue, StorageMap, StorageDoubleMap, Blake2_256};
    use system::ensure_signed;
    use timestamp;
    use codec::{Encode, Decode};
    use crate::report;
    pub struct MinerInfo<A, M> {
        hardware_id: Vec<u8>,
        father_address: Option<A>,
        grandpa_address: Option<A>,
        register_time: M,
        machine_state: Vec<u8>,
        machine_owner: A,
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <A, M> _parity_scale_codec::Encode for MinerInfo<A, M> where
             Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             M: _parity_scale_codec::Encode, M: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.hardware_id);
                    dest.push(&self.father_address);
                    dest.push(&self.grandpa_address);
                    dest.push(&self.register_time);
                    dest.push(&self.machine_state);
                    dest.push(&self.machine_owner);
                }
            }
            impl <A, M> _parity_scale_codec::EncodeLike for MinerInfo<A, M>
             where Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             Option<A>: _parity_scale_codec::Encode,
             M: _parity_scale_codec::Encode, M: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <A, M> _parity_scale_codec::Decode for MinerInfo<A, M> where
             Option<A>: _parity_scale_codec::Decode,
             Option<A>: _parity_scale_codec::Decode,
             Option<A>: _parity_scale_codec::Decode,
             Option<A>: _parity_scale_codec::Decode,
             M: _parity_scale_codec::Decode, M: _parity_scale_codec::Decode,
             A: _parity_scale_codec::Decode, A: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(MinerInfo{hardware_id:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.hardware_id".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 father_address:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.father_address".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 grandpa_address:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.grandpa_address".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 register_time:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.register_time".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 machine_state:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.machine_state".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 machine_owner:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.machine_owner".into()),
                                             Ok(a) => a,
                                         }
                                     },})
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <A: ::core::default::Default, M: ::core::default::Default>
     ::core::default::Default for MinerInfo<A, M> {
        #[inline]
        fn default() -> MinerInfo<A, M> {
            MinerInfo{hardware_id: ::core::default::Default::default(),
                      father_address: ::core::default::Default::default(),
                      grandpa_address: ::core::default::Default::default(),
                      register_time: ::core::default::Default::default(),
                      machine_state: ::core::default::Default::default(),
                      machine_owner: ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <A: ::core::clone::Clone, M: ::core::clone::Clone>
     ::core::clone::Clone for MinerInfo<A, M> {
        #[inline]
        fn clone(&self) -> MinerInfo<A, M> {
            match *self {
                MinerInfo {
                hardware_id: ref __self_0_0,
                father_address: ref __self_0_1,
                grandpa_address: ref __self_0_2,
                register_time: ref __self_0_3,
                machine_state: ref __self_0_4,
                machine_owner: ref __self_0_5 } =>
                MinerInfo{hardware_id:
                              ::core::clone::Clone::clone(&(*__self_0_0)),
                          father_address:
                              ::core::clone::Clone::clone(&(*__self_0_1)),
                          grandpa_address:
                              ::core::clone::Clone::clone(&(*__self_0_2)),
                          register_time:
                              ::core::clone::Clone::clone(&(*__self_0_3)),
                          machine_state:
                              ::core::clone::Clone::clone(&(*__self_0_4)),
                          machine_owner:
                              ::core::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    impl <A, M> ::core::marker::StructuralPartialEq for MinerInfo<A, M> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <A: ::core::cmp::PartialEq, M: ::core::cmp::PartialEq>
     ::core::cmp::PartialEq for MinerInfo<A, M> {
        #[inline]
        fn eq(&self, other: &MinerInfo<A, M>) -> bool {
            match *other {
                MinerInfo {
                hardware_id: ref __self_1_0,
                father_address: ref __self_1_1,
                grandpa_address: ref __self_1_2,
                register_time: ref __self_1_3,
                machine_state: ref __self_1_4,
                machine_owner: ref __self_1_5 } =>
                match *self {
                    MinerInfo {
                    hardware_id: ref __self_0_0,
                    father_address: ref __self_0_1,
                    grandpa_address: ref __self_0_2,
                    register_time: ref __self_0_3,
                    machine_state: ref __self_0_4,
                    machine_owner: ref __self_0_5 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MinerInfo<A, M>) -> bool {
            match *other {
                MinerInfo {
                hardware_id: ref __self_1_0,
                father_address: ref __self_1_1,
                grandpa_address: ref __self_1_2,
                register_time: ref __self_1_3,
                machine_state: ref __self_1_4,
                machine_owner: ref __self_1_5 } =>
                match *self {
                    MinerInfo {
                    hardware_id: ref __self_0_0,
                    father_address: ref __self_0_1,
                    grandpa_address: ref __self_0_2,
                    register_time: ref __self_0_3,
                    machine_state: ref __self_0_4,
                    machine_owner: ref __self_0_5 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <A: ::core::fmt::Debug, M: ::core::fmt::Debug> ::core::fmt::Debug for
     MinerInfo<A, M> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MinerInfo {
                hardware_id: ref __self_0_0,
                father_address: ref __self_0_1,
                grandpa_address: ref __self_0_2,
                register_time: ref __self_0_3,
                machine_state: ref __self_0_4,
                machine_owner: ref __self_0_5 } => {
                    let mut debug_trait_builder = f.debug_struct("MinerInfo");
                    let _ =
                        debug_trait_builder.field("hardware_id",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("father_address",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("grandpa_address",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("register_time",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("machine_state",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("machine_owner",
                                                  &&(*__self_0_5));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub trait Trait: timestamp::Trait + system::Trait {
        /// The overarching event type.
        type
        PledgeAmount: Get<BalanceOf<Self>>;
        type
        Event: From<Event<Self>> +
        Into<<Self as system::Trait>::Event>;
        type
        Currency1: Currency<Self::AccountId> +
        ReservableCurrency<Self::AccountId>;
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{StorageValue
                                                                    as _,
                                                                    StorageMap
                                                                    as _,
                                                                    StorageLinkedMap
                                                                    as _,
                                                                    StorageDoubleMap
                                                                    as _};
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate support as hidden_include;
    }
    trait Store {
        type
        AllMiners;
        type
        TokenInfo;
        type
        AllRegisters;
        type
        MinersCount;
        type
        BlackList;
    }
    impl <T: Trait + 'static> Store for Module<T> {
        type
        AllMiners
        =
        AllMiners<T>;
        type
        TokenInfo
        =
        TokenInfo<T>;
        type
        AllRegisters
        =
        AllRegisters<T>;
        type
        MinersCount
        =
        MinersCount<>;
        type
        BlackList
        =
        BlackList<T>;
    }
    impl <T: Trait + 'static> Module<T> {
        pub fn allminers<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<T::AccountId>>(key:
                                                                                                                            K)
         -> MinerInfo<T::AccountId, T::Moment> {
            <AllMiners<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<T::AccountId,
                                                                                               MinerInfo<T::AccountId,
                                                                                                         T::Moment>>>::get(key)
        }
        pub fn allregisters<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<Vec<u8>>>(key:
                                                                                                                          K)
         -> T::AccountId {
            <AllRegisters<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<Vec<u8>,
                                                                                               T::AccountId>>::get(key)
        }
        pub fn blacklist<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<T::AccountId>>(key:
                                                                                                                            K)
         -> T::Hash {
            <BlackList<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<T::AccountId,
                                                                                               T::Hash>>::get(key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructAllMiners<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_AllMiners:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructAllMiners<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_AllMiners.get_or_init(||
                                                              {
                                                                  let def_val:
                                                                          MinerInfo<T::AccountId,
                                                                                    T::Moment> =
                                                                      Default::default();
                                                                  <MinerInfo<T::AccountId,
                                                                             T::Moment>
                                                                      as
                                                                      Encode>::encode(&def_val)
                                                              }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructAllMiners<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructAllMiners<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructTokenInfo<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_TokenInfo:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructTokenInfo<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_TokenInfo.get_or_init(||
                                                              {
                                                                  let def_val:
                                                                          Vec<u8> =
                                                                      Default::default();
                                                                  <Vec<u8> as
                                                                      Encode>::encode(&def_val)
                                                              }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructTokenInfo<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructTokenInfo<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructAllRegisters<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_AllRegisters:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructAllRegisters<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_AllRegisters.get_or_init(||
                                                                 {
                                                                     let def_val:
                                                                             T::AccountId =
                                                                         Default::default();
                                                                     <T::AccountId
                                                                         as
                                                                         Encode>::encode(&def_val)
                                                                 }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructAllRegisters<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructAllRegisters<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructMinersCount<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_MinersCount:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructMinersCount<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_MinersCount.get_or_init(||
                                                                {
                                                                    let def_val:
                                                                            u64 =
                                                                        Default::default();
                                                                    <u64 as
                                                                        Encode>::encode(&def_val)
                                                                }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructMinersCount<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructMinersCount<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructBlackList<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_BlackList:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructBlackList<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_BlackList.get_or_init(||
                                                              {
                                                                  let def_val:
                                                                          T::Hash =
                                                                      Default::default();
                                                                  <T::Hash as
                                                                      Encode>::encode(&def_val)
                                                              }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructBlackList<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructBlackList<T> { }
    impl <T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata()
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata {
            self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata{prefix:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("TemplateModule"),
                                                                                                 entries:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("AllMiners"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::AccountId"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("MinerInfo<T::AccountId, T::Moment>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructAllMiners::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("TokenInfo"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::DoubleMap{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                       self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Twox64Concat,
                                                                                                                                                                                                                                                                                                                                                                                                   key1:
                                                                                                                                                                                                                                                                                                                                                                                                       self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::AccountId"),
                                                                                                                                                                                                                                                                                                                                                                                                   key2:
                                                                                                                                                                                                                                                                                                                                                                                                       self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<u8>"),
                                                                                                                                                                                                                                                                                                                                                                                                   value:
                                                                                                                                                                                                                                                                                                                                                                                                       self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<u8>"),
                                                                                                                                                                                                                                                                                                                                                                                                   key2_hasher:
                                                                                                                                                                                                                                                                                                                                                                                                       self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructTokenInfo::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("AllRegisters"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<u8>"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::AccountId"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructAllRegisters::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("MinersCount"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Plain(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("u64")),
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructMinersCount::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("BlackList"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::AccountId"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::Hash"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructBlackList::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),}][..]),}
        }
    }
    #[doc = r" Tag a type as an instance of a module."]
    #[doc = r""]
    #[doc = r" Defines storage prefixes, they must be unique."]
    #[doc(hidden)]
    pub trait __GeneratedInstantiable: 'static {
        #[doc = r" The prefix used by any storage entry of an instance."]
        const
        PREFIX:
        &'static str;
    }
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance =>
                match *self { __InherentHiddenInstance => true, },
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for __InherentHiddenInstance {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                }
            }
            impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance
             {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for __InherentHiddenInstance {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(__InherentHiddenInstance)
                }
            }
        };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl __GeneratedInstantiable for __InherentHiddenInstance {
        const
        PREFIX:
        &'static str
        =
        "TemplateModule";
    }
    pub struct AllMiners<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<T::AccountId,
                                                                                               MinerInfo<T::AccountId,
                                                                                                         T::Moment>>
     for AllMiners<T> {
        type
        Query
        =
        MinerInfo<T::AccountId, T::Moment>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "AllMiners".as_bytes() }
        fn from_optional_value_to_query(v:
                                            Option<MinerInfo<T::AccountId,
                                                             T::Moment>>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<MinerInfo<T::AccountId, T::Moment>> {
            Some(v)
        }
    }
    struct TokenInfo<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageDoubleMap<T::AccountId,
                                                                                                     Vec<u8>,
                                                                                                     Vec<u8>>
     for TokenInfo<T> {
        type
        Query
        =
        Vec<u8>;
        type
        Hasher1
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Twox64Concat;
        type
        Hasher2
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "TokenInfo".as_bytes() }
        fn from_optional_value_to_query(v: Option<Vec<u8>>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<Vec<u8>> {
            Some(v)
        }
    }
    struct AllRegisters<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<Vec<u8>,
                                                                                               T::AccountId>
     for AllRegisters<T> {
        type
        Query
        =
        T::AccountId;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "AllRegisters".as_bytes() }
        fn from_optional_value_to_query(v: Option<T::AccountId>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<T::AccountId> {
            Some(v)
        }
    }
    struct MinersCount(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<()>);
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<u64>
     for MinersCount<> {
        type
        Query
        =
        u64;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "MinersCount".as_bytes() }
        fn from_optional_value_to_query(v: Option<u64>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<u64> {
            Some(v)
        }
    }
    pub struct BlackList<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<T::AccountId,
                                                                                               T::Hash>
     for BlackList<T> {
        type
        Query
        =
        T::Hash;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "BlackList".as_bytes() }
        fn from_optional_value_to_query(v: Option<T::Hash>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<T::Hash> {
            Some(v)
        }
    }
    pub struct Module<T: Trait>(::frame_support::rstd::marker::PhantomData<(T)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T>
     {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) =>
                Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T>
     {
    }
    impl <T: Trait> ::core::marker::StructuralPartialEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for
     Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl <T: Trait> ::core::marker::StructuralEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _:
                        ::core::cmp::AssertParamIsEq<::frame_support::rstd::marker::PhantomData<(T)>>;
            }
        }
    }
    impl <T: Trait> core::fmt::Debug for Module<T> where T: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnInitialize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnFinalize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> ::frame_support::dispatch::WeighBlock<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OffchainWorker<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> Module<T> {
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <system::Module<T>>::deposit_event(event.into())
        }
    }
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl <T: Trait> Module<T> {
        pub fn register(origin: T::Origin, hardware_id: Vec<u8>,
                        father_Address: T::AccountId, machine_state: Vec<u8>)
         -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("register",
                                                                                "node_runtime::register",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/register.rs"),
                                                                                Some(48u32),
                                                                                Some("node_runtime::register"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                #[doc = r" register the machine."]
                let who = ensure_signed(origin)?;
                {
                    if !!(hardware_id.len() == 0) {
                        { return Err("please put into the hardware_id."); };
                    }
                };
                {
                    if !!(machine_state.len() == 0) {
                        { return Err("please put into the machine_state."); };
                    }
                };
                {
                    if !!<AllMiners<T>>::exists(who.clone()) {
                        { return Err("you have been registed!"); };
                    }
                };
                {
                    if !!<BlackList<T>>::exists(who.clone()) {
                        {
                            return Err("you are the member of the blacklist, can't register again.");
                        };
                    }
                };
                {
                    if !!<AllRegisters<T>>::exists(hardware_id.clone()) {
                        { return Err("the hardware_id is exists!"); };
                    }
                };
                let bond: BalanceOf<T> = T::PledgeAmount::get();
                debug::RuntimeLogger::init();
                use core::fmt::Write;
                let mut w = ::frame_support::debug::Writer::default();
                let _ =
                    (&mut w).write_fmt(::core::fmt::Arguments::new_v1(&["bond---------------------------------"],
                                                                      &match (&bond,)
                                                                           {
                                                                           (arg0,)
                                                                           =>
                                                                           [::core::fmt::ArgumentV1::new(arg0,
                                                                                                         ::core::fmt::Debug::fmt)],
                                                                       }));
                w.print();
                T::Currency1::reserve(&who,
                                      bond.clone()).map_err(|_|
                                                                "Proposer's balance too low, you can't registe!")?;
                let register_time = <timestamp::Module<T>>::get();
                let mut minerinfo =
                    MinerInfo{hardware_id: hardware_id.clone(),
                              father_address: None,
                              grandpa_address: None,
                              register_time: register_time.clone(),
                              machine_state: machine_state,
                              machine_owner: who.clone(),};
                if who.clone() != father_Address.clone() {
                    minerinfo.father_address = Some(father_Address.clone());
                }
                if <AllMiners<T>>::exists(father_Address.clone()) {
                    let tmpt =
                        <AllMiners<T>>::get(father_Address.clone()).father_address.unwrap_or(who.clone());
                    if who.clone() != tmpt {
                        minerinfo.grandpa_address = Some(tmpt);
                    }
                }
                <AllMiners<T>>::insert(who.clone(), minerinfo.clone());
                <AllRegisters<T>>::insert(hardware_id.clone(), who.clone());
                let allminerscount = MinersCount::get();
                let new_allminerscount =
                    allminerscount.checked_add(1).ok_or("Overflow adding a miner to total supply!")?;
                MinersCount::put(new_allminerscount);
                Self::deposit_event(RawEvent::RegisterEvent(allminerscount,
                                                            who.clone(),
                                                            register_time.clone()));
                Ok(())
            }
        }
        pub fn kill_register(origin: T::Origin) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("kill_register",
                                                                                "node_runtime::register",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/register.rs"),
                                                                                Some(48u32),
                                                                                Some("node_runtime::register"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                #[doc = r" 注销注册的账户 并归还抵押金额"]
                let who = ensure_signed(origin)?;
                {
                    if !<AllMiners<T>>::exists(who.clone()) {
                        { return Err("you have been not registered!"); };
                    }
                };
                let bond: BalanceOf<T> = T::PledgeAmount::get();
                T::Currency1::unreserve(&who, bond.clone());
                let hardware_id =
                    <AllMiners<T>>::get(who.clone()).hardware_id;
                <AllMiners<T>>::remove(who.clone());
                <AllRegisters<T>>::remove(hardware_id.clone());
                let minercount = MinersCount::get();
                let new_minercount = minercount - 1;
                MinersCount::put(new_minercount);
                <TokenInfo<T>>::remove_prefix(who.clone());
                Self::deposit_event(RawEvent::KillRegisterEvent(who.clone()));
                Ok(())
            }
        }
        pub fn add_token_info(origin: T::Origin,
                              tokenaddress_add_symbol: Vec<u8>,
                              tokenaddress: Vec<u8>) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("add_token_info",
                                                                                "node_runtime::register",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/register.rs"),
                                                                                Some(48u32),
                                                                                Some("node_runtime::register"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                #[doc = r" 给注册过的用户添加token信息"]
                let who = ensure_signed(origin)?;
                {
                    if !!(tokenaddress_add_symbol.len() == 0) {
                        {
                            return Err("please put into the tokenaddress_add_symbol.");
                        };
                    }
                };
                {
                    if !!(tokenaddress.len() == 0) {
                        { return Err("please put into the tokenaddress."); };
                    }
                };
                {
                    if !<AllMiners<T>>::exists(who.clone()) {
                        { return Err("you have been not registered!"); };
                    }
                };
                {
                    if !!<TokenInfo<T>>::exists(who.clone(),
                                                tokenaddress_add_symbol.clone())
                       {
                        {
                            return Err("the token info have been existsting.");
                        };
                    }
                };
                <TokenInfo<T>>::insert(who.clone(),
                                       tokenaddress_add_symbol.clone(),
                                       tokenaddress.clone());
                Self::deposit_event(RawEvent::AddTokenInfoEvent(who,
                                                                tokenaddress_add_symbol));
                Ok(())
            }
        }
        pub fn remove_token_info(origin: T::Origin,
                                 tokenaddress_add_symbol: Vec<u8>) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("remove_token_info",
                                                                                "node_runtime::register",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/register.rs"),
                                                                                Some(48u32),
                                                                                Some("node_runtime::register"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = ensure_signed(origin)?;
                {
                    if !!(tokenaddress_add_symbol.len() == 0) {
                        {
                            return Err("please put into the tokenaddress_add_symbol.");
                        };
                    }
                };
                {
                    if !<AllMiners<T>>::exists(who.clone()) {
                        { return Err("you have been not registered!"); };
                    }
                };
                {
                    if !<TokenInfo<T>>::exists(who.clone(),
                                               tokenaddress_add_symbol.clone())
                       {
                        { return Err("the token info not exists."); };
                    }
                };
                <TokenInfo<T>>::remove(who.clone(),
                                       tokenaddress_add_symbol.clone());
                Self::deposit_event(RawEvent::RemoveTokenInfoEvent(who,
                                                                   tokenaddress_add_symbol));
                Ok(())
            }
        }
    }
    #[doc = r" The module declaration."]
    pub enum Call<T: Trait> {

        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(::frame_support::rstd::marker::PhantomData<(T)>,
                      ::frame_support::dispatch::Never),

        #[allow(non_camel_case_types)]
        register(Vec<u8>, T::AccountId, Vec<u8>),

        #[allow(non_camel_case_types)]
        kill_register(),

        #[allow(non_camel_case_types)]
        add_token_info(Vec<u8>, Vec<u8>),

        #[allow(non_camel_case_types)]
        remove_token_info(Vec<u8>),
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Encode for Call<T> where
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        Call::register(ref aa, ref ba, ref ca) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                            dest.push(ca);
                        }
                        Call::kill_register() => {
                            dest.push_byte(1usize as u8);
                        }
                        Call::add_token_info(ref aa, ref ba) => {
                            dest.push_byte(2usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        Call::remove_token_info(ref aa) => {
                            dest.push_byte(3usize as u8);
                            dest.push(aa);
                        }
                        _ => (),
                    }
                }
            }
            impl <T: Trait> _parity_scale_codec::EncodeLike for Call<T> where
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Decode for Call<T> where
             T::AccountId: _parity_scale_codec::Decode,
             T::AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(Call::register({
                                                  let res =
                                                      _parity_scale_codec::Decode::decode(input);
                                                  match res {
                                                      Err(_) =>
                                                      return Err("Error decoding field Call :: register.0".into()),
                                                      Ok(a) => a,
                                                  }
                                              },
                                              {
                                                  let res =
                                                      _parity_scale_codec::Decode::decode(input);
                                                  match res {
                                                      Err(_) =>
                                                      return Err("Error decoding field Call :: register.1".into()),
                                                      Ok(a) => a,
                                                  }
                                              },
                                              {
                                                  let res =
                                                      _parity_scale_codec::Decode::decode(input);
                                                  match res {
                                                      Err(_) =>
                                                      return Err("Error decoding field Call :: register.2".into()),
                                                      Ok(a) => a,
                                                  }
                                              }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(Call::kill_register())
                        }
                        x if x == 2usize as u8 => {
                            Ok(Call::add_token_info({
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: add_token_info.0".into()),
                                                            Ok(a) => a,
                                                        }
                                                    },
                                                    {
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: add_token_info.1".into()),
                                                            Ok(a) => a,
                                                        }
                                                    }))
                        }
                        x if x == 3usize as u8 => {
                            Ok(Call::remove_token_info({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field Call :: remove_token_info.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                        }
                        x => Err("No such variant in enum Call".into()),
                    }
                }
            }
        };
    impl <T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self)
         -> ::frame_support::dispatch::DispatchInfo {
            if let Call::register(ref hardware_id, ref father_Address,
                                  ref machine_state) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,
                                                               &T::AccountId,
                                                               &Vec<u8>)>>::weigh_data(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                       (hardware_id,
                                                                                        father_Address,
                                                                                        machine_state));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,
                                                                      &T::AccountId,
                                                                      &Vec<u8>)>>::classify_dispatch(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                                     (hardware_id,
                                                                                                      father_Address,
                                                                                                      machine_state));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&SimpleDispatchInfo::FixedNormal(500_000));
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/register.rs",
                                                         48u32, 1u32))
                        }
                    }
                }
            }
            if let Call::kill_register() = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<()>>::weigh_data(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                               ());
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<()>>::classify_dispatch(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                             ());
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&SimpleDispatchInfo::FixedNormal(500_000));
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/register.rs",
                                                         48u32, 1u32))
                        }
                    }
                }
            }
            if let Call::add_token_info(ref tokenaddress_add_symbol,
                                        ref tokenaddress) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,
                                                               &Vec<u8>)>>::weigh_data(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                       (tokenaddress_add_symbol,
                                                                                        tokenaddress));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,
                                                                      &Vec<u8>)>>::classify_dispatch(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                                     (tokenaddress_add_symbol,
                                                                                                      tokenaddress));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&SimpleDispatchInfo::FixedNormal(500_000));
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/register.rs",
                                                         48u32, 1u32))
                        }
                    }
                }
            }
            if let Call::remove_token_info(ref tokenaddress_add_symbol) = self
               {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,)>>::weigh_data(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                        (tokenaddress_add_symbol,));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,)>>::classify_dispatch(&SimpleDispatchInfo::FixedNormal(500_000),
                                                                                                      (tokenaddress_add_symbol,));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&SimpleDispatchInfo::FixedNormal(500_000));
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/register.rs",
                                                         48u32, 1u32))
                        }
                    }
                }
            }
            let weight =
                <dyn ::frame_support::dispatch::WeighData<_>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                          ());
            let class =
                <dyn ::frame_support::dispatch::ClassifyDispatch<_>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                        ());
            let pays_fee =
                <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
            ::frame_support::dispatch::DispatchInfo{weight, class, pays_fee,}
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::register(ref hardware_id, ref father_Address,
                               ref machine_state) =>
                Call::register((*hardware_id).clone(),
                               (*father_Address).clone(),
                               (*machine_state).clone()),
                Call::kill_register() => Call::kill_register(),
                Call::add_token_info(ref tokenaddress_add_symbol,
                                     ref tokenaddress) =>
                Call::add_token_info((*tokenaddress_add_symbol).clone(),
                                     (*tokenaddress).clone()),
                Call::remove_token_info(ref tokenaddress_add_symbol) =>
                Call::remove_token_info((*tokenaddress_add_symbol).clone()),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/register.rs",
                                                 48u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::register(ref hardware_id, ref father_Address,
                               ref machine_state) => {
                    let self_params =
                        (hardware_id, father_Address, machine_state);
                    if let Call::register(ref hardware_id, ref father_Address,
                                          ref machine_state) = *_other {
                        self_params ==
                            (hardware_id, father_Address, machine_state)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/register.rs",
                                                             48u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::kill_register() => {
                    let self_params = ();
                    if let Call::kill_register() = *_other {
                        self_params == ()
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/register.rs",
                                                             48u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::add_token_info(ref tokenaddress_add_symbol,
                                     ref tokenaddress) => {
                    let self_params = (tokenaddress_add_symbol, tokenaddress);
                    if let Call::add_token_info(ref tokenaddress_add_symbol,
                                                ref tokenaddress) = *_other {
                        self_params == (tokenaddress_add_symbol, tokenaddress)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/register.rs",
                                                             48u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::remove_token_info(ref tokenaddress_add_symbol) => {
                    let self_params = (tokenaddress_add_symbol,);
                    if let Call::remove_token_info(ref tokenaddress_add_symbol)
                           = *_other {
                        self_params == (tokenaddress_add_symbol,)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/register.rs",
                                                             48u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/register.rs",
                                                 48u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Eq for Call<T> { }
    impl <T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(&self, _f: &mut ::frame_support::dispatch::fmt::Formatter)
         ->
             ::frame_support::dispatch::result::Result<(),
                                                       ::frame_support::dispatch::fmt::Error> {
            match *self {
                Call::register(ref hardware_id, ref father_Address,
                               ref machine_state) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"register",
                                                                    &(hardware_id.clone(),
                                                                      father_Address.clone(),
                                                                      machine_state.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::kill_register() =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"kill_register",
                                                                    &()) {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::add_token_info(ref tokenaddress_add_symbol,
                                     ref tokenaddress) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"add_token_info",
                                                                    &(tokenaddress_add_symbol.clone(),
                                                                      tokenaddress.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::remove_token_info(ref tokenaddress_add_symbol) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"remove_token_info",
                                                                    &(tokenaddress_add_symbol.clone(),))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/register.rs",
                                                 48u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Dispatchable for Call<T> {
        type
        Trait
        =
        T;
        type
        Origin
        =
        T::Origin;
        type
        Error
        =
        &'static str;
        fn dispatch(self, _origin: Self::Origin)
         -> ::frame_support::dispatch::DispatchResult<Self::Error> {
            match self {
                Call::register(hardware_id, father_Address, machine_state) =>
                {
                    <Module<T>>::register(_origin, hardware_id,
                                          father_Address, machine_state)
                }
                Call::kill_register() => {
                    <Module<T>>::kill_register(_origin)
                }
                Call::add_token_info(tokenaddress_add_symbol, tokenaddress) =>
                {
                    <Module<T>>::add_token_info(_origin,
                                                tokenaddress_add_symbol,
                                                tokenaddress)
                }
                Call::remove_token_info(tokenaddress_add_symbol) => {
                    <Module<T>>::remove_token_info(_origin,
                                                   tokenaddress_add_symbol)
                }
                Call::__PhantomItem(_, _) => {
                    {
                        {
                            {
                                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                           &match (&"__PhantomItem should never be used.",)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::core::fmt::Display::fmt)],
                                                                                            }),
                                                           &("bin/node/runtime/src/register.rs",
                                                             48u32, 1u32))
                            }
                        }
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type
        Call
        =
        Call<T>;
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn dispatch<D: ::frame_support::dispatch::Dispatchable<Trait =
                        T>>(d: D, origin: D::Origin)
         -> ::frame_support::dispatch::DispatchResult<D::Error> {
            d.dispatch(origin)
        }
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn call_functions()
         -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("register"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("hardware_id"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("father_Address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::AccountId"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("machine_state"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("kill_register"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("add_token_info"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tokenaddress_add_symbol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tokenaddress"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("remove_token_info"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tokenaddress_add_symbol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),}]
        }
    }
    impl <T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        pub fn module_constants_metadata()
         -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl <T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for
     Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as
                ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    /// [`RawEvent`] specialized for the configuration [`Trait`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Trait`]: trait.Trait.html
    pub type Event<T>
        =
        RawEvent<<T as system::Trait>::AccountId,
                 <T as timestamp::Trait>::Moment>;
    /// Events for this module.
    ///
    pub enum RawEvent<AccountId, Moment> {
        RegisterEvent(u64, AccountId, Moment),
        AddTokenInfoEvent(AccountId, Vec<u8>),
        RemoveTokenInfoEvent(AccountId, Vec<u8>),
        KillRegisterEvent(AccountId),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::clone::Clone, Moment: ::core::clone::Clone>
     ::core::clone::Clone for RawEvent<AccountId, Moment> {
        #[inline]
        fn clone(&self) -> RawEvent<AccountId, Moment> {
            match (&*self,) {
                (&RawEvent::RegisterEvent(ref __self_0, ref __self_1,
                                          ref __self_2),) =>
                RawEvent::RegisterEvent(::core::clone::Clone::clone(&(*__self_0)),
                                        ::core::clone::Clone::clone(&(*__self_1)),
                                        ::core::clone::Clone::clone(&(*__self_2))),
                (&RawEvent::AddTokenInfoEvent(ref __self_0, ref __self_1),) =>
                RawEvent::AddTokenInfoEvent(::core::clone::Clone::clone(&(*__self_0)),
                                            ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::RemoveTokenInfoEvent(ref __self_0, ref __self_1),)
                =>
                RawEvent::RemoveTokenInfoEvent(::core::clone::Clone::clone(&(*__self_0)),
                                               ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::KillRegisterEvent(ref __self_0),) =>
                RawEvent::KillRegisterEvent(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl <AccountId, Moment> ::core::marker::StructuralPartialEq for
     RawEvent<AccountId, Moment> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::PartialEq, Moment: ::core::cmp::PartialEq>
     ::core::cmp::PartialEq for RawEvent<AccountId, Moment> {
        #[inline]
        fn eq(&self, other: &RawEvent<AccountId, Moment>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::RegisterEvent(ref __self_0, ref __self_1,
                                                  ref __self_2),
                         &RawEvent::RegisterEvent(ref __arg_1_0,
                                                  ref __arg_1_1,
                                                  ref __arg_1_2)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        (&RawEvent::AddTokenInfoEvent(ref __self_0,
                                                      ref __self_1),
                         &RawEvent::AddTokenInfoEvent(ref __arg_1_0,
                                                      ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::RemoveTokenInfoEvent(ref __self_0,
                                                         ref __self_1),
                         &RawEvent::RemoveTokenInfoEvent(ref __arg_1_0,
                                                         ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::KillRegisterEvent(ref __self_0),
                         &RawEvent::KillRegisterEvent(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<AccountId, Moment>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::RegisterEvent(ref __self_0, ref __self_1,
                                                  ref __self_2),
                         &RawEvent::RegisterEvent(ref __arg_1_0,
                                                  ref __arg_1_1,
                                                  ref __arg_1_2)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        (&RawEvent::AddTokenInfoEvent(ref __self_0,
                                                      ref __self_1),
                         &RawEvent::AddTokenInfoEvent(ref __arg_1_0,
                                                      ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::RemoveTokenInfoEvent(ref __self_0,
                                                         ref __self_1),
                         &RawEvent::RemoveTokenInfoEvent(ref __arg_1_0,
                                                         ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::KillRegisterEvent(ref __self_0),
                         &RawEvent::KillRegisterEvent(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    impl <AccountId, Moment> ::core::marker::StructuralEq for
     RawEvent<AccountId, Moment> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::Eq, Moment: ::core::cmp::Eq> ::core::cmp::Eq
     for RawEvent<AccountId, Moment> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Moment>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, Moment> _parity_scale_codec::Encode for
             RawEvent<AccountId, Moment> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        RawEvent::RegisterEvent(ref aa, ref ba, ref ca) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                            dest.push(ca);
                        }
                        RawEvent::AddTokenInfoEvent(ref aa, ref ba) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::RemoveTokenInfoEvent(ref aa, ref ba) => {
                            dest.push_byte(2usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::KillRegisterEvent(ref aa) => {
                            dest.push_byte(3usize as u8);
                            dest.push(aa);
                        }
                        _ => (),
                    }
                }
            }
            impl <AccountId, Moment> _parity_scale_codec::EncodeLike for
             RawEvent<AccountId, Moment> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, Moment> _parity_scale_codec::Decode for
             RawEvent<AccountId, Moment> where
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             Moment: _parity_scale_codec::Decode,
             Moment: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(RawEvent::RegisterEvent({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: RegisterEvent.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       },
                                                       {
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: RegisterEvent.1".into()),
                                                               Ok(a) => a,
                                                           }
                                                       },
                                                       {
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: RegisterEvent.2".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(RawEvent::AddTokenInfoEvent({
                                                               let res =
                                                                   _parity_scale_codec::Decode::decode(input);
                                                               match res {
                                                                   Err(_) =>
                                                                   return Err("Error decoding field RawEvent :: AddTokenInfoEvent.0".into()),
                                                                   Ok(a) => a,
                                                               }
                                                           },
                                                           {
                                                               let res =
                                                                   _parity_scale_codec::Decode::decode(input);
                                                               match res {
                                                                   Err(_) =>
                                                                   return Err("Error decoding field RawEvent :: AddTokenInfoEvent.1".into()),
                                                                   Ok(a) => a,
                                                               }
                                                           }))
                        }
                        x if x == 2usize as u8 => {
                            Ok(RawEvent::RemoveTokenInfoEvent({
                                                                  let res =
                                                                      _parity_scale_codec::Decode::decode(input);
                                                                  match res {
                                                                      Err(_)
                                                                      =>
                                                                      return Err("Error decoding field RawEvent :: RemoveTokenInfoEvent.0".into()),
                                                                      Ok(a) =>
                                                                      a,
                                                                  }
                                                              },
                                                              {
                                                                  let res =
                                                                      _parity_scale_codec::Decode::decode(input);
                                                                  match res {
                                                                      Err(_)
                                                                      =>
                                                                      return Err("Error decoding field RawEvent :: RemoveTokenInfoEvent.1".into()),
                                                                      Ok(a) =>
                                                                      a,
                                                                  }
                                                              }))
                        }
                        x if x == 3usize as u8 => {
                            Ok(RawEvent::KillRegisterEvent({
                                                               let res =
                                                                   _parity_scale_codec::Decode::decode(input);
                                                               match res {
                                                                   Err(_) =>
                                                                   return Err("Error decoding field RawEvent :: KillRegisterEvent.0".into()),
                                                                   Ok(a) => a,
                                                               }
                                                           }))
                        }
                        x => Err("No such variant in enum RawEvent".into()),
                    }
                }
            }
        };
    impl <AccountId, Moment> core::fmt::Debug for RawEvent<AccountId, Moment>
     where AccountId: core::fmt::Debug, Moment: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::RegisterEvent(ref a0, ref a1, ref a2) =>
                fmt.debug_tuple("RawEvent::RegisterEvent").field(a0).field(a1).field(a2).finish(),
                Self::AddTokenInfoEvent(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::AddTokenInfoEvent").field(a0).field(a1).finish(),
                Self::RemoveTokenInfoEvent(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::RemoveTokenInfoEvent").field(a0).field(a1).finish(),
                Self::KillRegisterEvent(ref a0) =>
                fmt.debug_tuple("RawEvent::KillRegisterEvent").field(a0).finish(),
                _ => Ok(()),
            }
        }
    }
    impl <AccountId, Moment> From<RawEvent<AccountId, Moment>> for () {
        fn from(_: RawEvent<AccountId, Moment>) -> () { () }
    }
    impl <AccountId, Moment> RawEvent<AccountId, Moment> {
        #[allow(dead_code)]
        pub fn metadata()
         -> &'static [::frame_support::event::EventMetadata] {
            &[::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("RegisterEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["u64",
                                                                                                          "AccountId",
                                                                                                          "Moment"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("AddTokenInfoEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId",
                                                                                                          "Vec<u8>"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("RemoveTokenInfoEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId",
                                                                                                          "Vec<u8>"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("KillRegisterEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),}]
        }
    }
    impl <T: Trait> Module<T> {
        pub fn kill_man(who: T::AccountId) -> Result {
            {
                if !<AllMiners<T>>::exists(who.clone()) {
                    { return Err("you have been not registered!"); };
                }
            };
            let bond: BalanceOf<T> = T::PledgeAmount::get();
            let hardware_id = <AllMiners<T>>::get(who.clone()).hardware_id;
            <AllMiners<T>>::remove(who.clone());
            <AllRegisters<T>>::remove(hardware_id.clone());
            let minercount = MinersCount::get();
            let new_minercount = minercount - 1;
            MinersCount::put(new_minercount);
            <TokenInfo<T>>::remove_prefix(who.clone());
            Self::deposit_event(RawEvent::KillRegisterEvent(who.clone()));
            Ok(())
        }
    }
}
pub mod report {
    use support::{decl_module, decl_storage, decl_event, dispatch::Result,
                  ensure, debug, StorageMap, StorageValue};
    use system::ensure_signed;
    use rstd::prelude::*;
    use collective;
    use codec::{Encode, Decode};
    use sp_runtime::traits::{Hash};
    use support::traits::{Get, Currency, ReservableCurrency};
    use sp_runtime::{Permill, ModuleId};
    use sp_runtime::traits::{Zero, EnsureOrigin, StaticLookup,
                             AccountIdConversion, Saturating};
    use crate::register::{AllMiners, BlackList, Trait as RegisterTrait};
    use crate::register;
    use elections_phragmen;
    const MODULE_ID: ModuleId = ModuleId(*b"py/trsry");
    type BalanceOf<T>
        =
        <<T as Trait>::Currency0 as
        Currency<<T as system::Trait>::AccountId>>::Balance;
    pub struct VoteInfo<Bo, A, Ba, H> {
        start_vote_block: Bo,
        symbol: Vec<u8>,
        tx: Vec<u8>,
        tx_hash: H,
        reporter: A,
        report_reason: Vec<u8>,
        illegal_man: A,
        transaction_amount: Ba,
        usdt_amount: Ba,
        decimals: u32,
        approve_mans: Vec<A>,
        reject_mans: Vec<A>,
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <Bo, A, Ba, H> _parity_scale_codec::Encode for
             VoteInfo<Bo, A, Ba, H> where Bo: _parity_scale_codec::Encode,
             Bo: _parity_scale_codec::Encode, H: _parity_scale_codec::Encode,
             H: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, Ba: _parity_scale_codec::Encode,
             Ba: _parity_scale_codec::Encode, Ba: _parity_scale_codec::Encode,
             Ba: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.start_vote_block);
                    dest.push(&self.symbol);
                    dest.push(&self.tx);
                    dest.push(&self.tx_hash);
                    dest.push(&self.reporter);
                    dest.push(&self.report_reason);
                    dest.push(&self.illegal_man);
                    dest.push(&self.transaction_amount);
                    dest.push(&self.usdt_amount);
                    dest.push(&self.decimals);
                    dest.push(&self.approve_mans);
                    dest.push(&self.reject_mans);
                }
            }
            impl <Bo, A, Ba, H> _parity_scale_codec::EncodeLike for
             VoteInfo<Bo, A, Ba, H> where Bo: _parity_scale_codec::Encode,
             Bo: _parity_scale_codec::Encode, H: _parity_scale_codec::Encode,
             H: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, A: _parity_scale_codec::Encode,
             A: _parity_scale_codec::Encode, Ba: _parity_scale_codec::Encode,
             Ba: _parity_scale_codec::Encode, Ba: _parity_scale_codec::Encode,
             Ba: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode,
             Vec<A>: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <Bo, A, Ba, H> _parity_scale_codec::Decode for
             VoteInfo<Bo, A, Ba, H> where Bo: _parity_scale_codec::Decode,
             Bo: _parity_scale_codec::Decode, H: _parity_scale_codec::Decode,
             H: _parity_scale_codec::Decode, A: _parity_scale_codec::Decode,
             A: _parity_scale_codec::Decode, A: _parity_scale_codec::Decode,
             A: _parity_scale_codec::Decode, Ba: _parity_scale_codec::Decode,
             Ba: _parity_scale_codec::Decode, Ba: _parity_scale_codec::Decode,
             Ba: _parity_scale_codec::Decode,
             Vec<A>: _parity_scale_codec::Decode,
             Vec<A>: _parity_scale_codec::Decode,
             Vec<A>: _parity_scale_codec::Decode,
             Vec<A>: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(VoteInfo{start_vote_block:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.start_vote_block".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                symbol:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.symbol".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                tx:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.tx".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                tx_hash:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.tx_hash".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                reporter:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.reporter".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                report_reason:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.report_reason".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                illegal_man:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.illegal_man".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                transaction_amount:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.transaction_amount".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                usdt_amount:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.usdt_amount".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                decimals:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.decimals".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                approve_mans:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.approve_mans".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                reject_mans:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field VoteInfo.reject_mans".into()),
                                            Ok(a) => a,
                                        }
                                    },})
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Bo: ::core::default::Default, A: ::core::default::Default,
          Ba: ::core::default::Default, H: ::core::default::Default>
     ::core::default::Default for VoteInfo<Bo, A, Ba, H> {
        #[inline]
        fn default() -> VoteInfo<Bo, A, Ba, H> {
            VoteInfo{start_vote_block: ::core::default::Default::default(),
                     symbol: ::core::default::Default::default(),
                     tx: ::core::default::Default::default(),
                     tx_hash: ::core::default::Default::default(),
                     reporter: ::core::default::Default::default(),
                     report_reason: ::core::default::Default::default(),
                     illegal_man: ::core::default::Default::default(),
                     transaction_amount: ::core::default::Default::default(),
                     usdt_amount: ::core::default::Default::default(),
                     decimals: ::core::default::Default::default(),
                     approve_mans: ::core::default::Default::default(),
                     reject_mans: ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Bo: ::core::clone::Clone, A: ::core::clone::Clone,
          Ba: ::core::clone::Clone, H: ::core::clone::Clone>
     ::core::clone::Clone for VoteInfo<Bo, A, Ba, H> {
        #[inline]
        fn clone(&self) -> VoteInfo<Bo, A, Ba, H> {
            match *self {
                VoteInfo {
                start_vote_block: ref __self_0_0,
                symbol: ref __self_0_1,
                tx: ref __self_0_2,
                tx_hash: ref __self_0_3,
                reporter: ref __self_0_4,
                report_reason: ref __self_0_5,
                illegal_man: ref __self_0_6,
                transaction_amount: ref __self_0_7,
                usdt_amount: ref __self_0_8,
                decimals: ref __self_0_9,
                approve_mans: ref __self_0_10,
                reject_mans: ref __self_0_11 } =>
                VoteInfo{start_vote_block:
                             ::core::clone::Clone::clone(&(*__self_0_0)),
                         symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                         tx: ::core::clone::Clone::clone(&(*__self_0_2)),
                         tx_hash: ::core::clone::Clone::clone(&(*__self_0_3)),
                         reporter:
                             ::core::clone::Clone::clone(&(*__self_0_4)),
                         report_reason:
                             ::core::clone::Clone::clone(&(*__self_0_5)),
                         illegal_man:
                             ::core::clone::Clone::clone(&(*__self_0_6)),
                         transaction_amount:
                             ::core::clone::Clone::clone(&(*__self_0_7)),
                         usdt_amount:
                             ::core::clone::Clone::clone(&(*__self_0_8)),
                         decimals:
                             ::core::clone::Clone::clone(&(*__self_0_9)),
                         approve_mans:
                             ::core::clone::Clone::clone(&(*__self_0_10)),
                         reject_mans:
                             ::core::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    impl <Bo, A, Ba, H> ::core::marker::StructuralPartialEq for
     VoteInfo<Bo, A, Ba, H> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Bo: ::core::cmp::PartialEq, A: ::core::cmp::PartialEq,
          Ba: ::core::cmp::PartialEq, H: ::core::cmp::PartialEq>
     ::core::cmp::PartialEq for VoteInfo<Bo, A, Ba, H> {
        #[inline]
        fn eq(&self, other: &VoteInfo<Bo, A, Ba, H>) -> bool {
            match *other {
                VoteInfo {
                start_vote_block: ref __self_1_0,
                symbol: ref __self_1_1,
                tx: ref __self_1_2,
                tx_hash: ref __self_1_3,
                reporter: ref __self_1_4,
                report_reason: ref __self_1_5,
                illegal_man: ref __self_1_6,
                transaction_amount: ref __self_1_7,
                usdt_amount: ref __self_1_8,
                decimals: ref __self_1_9,
                approve_mans: ref __self_1_10,
                reject_mans: ref __self_1_11 } =>
                match *self {
                    VoteInfo {
                    start_vote_block: ref __self_0_0,
                    symbol: ref __self_0_1,
                    tx: ref __self_0_2,
                    tx_hash: ref __self_0_3,
                    reporter: ref __self_0_4,
                    report_reason: ref __self_0_5,
                    illegal_man: ref __self_0_6,
                    transaction_amount: ref __self_0_7,
                    usdt_amount: ref __self_0_8,
                    decimals: ref __self_0_9,
                    approve_mans: ref __self_0_10,
                    reject_mans: ref __self_0_11 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6) &&
                        (*__self_0_7) == (*__self_1_7) &&
                        (*__self_0_8) == (*__self_1_8) &&
                        (*__self_0_9) == (*__self_1_9) &&
                        (*__self_0_10) == (*__self_1_10) &&
                        (*__self_0_11) == (*__self_1_11),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &VoteInfo<Bo, A, Ba, H>) -> bool {
            match *other {
                VoteInfo {
                start_vote_block: ref __self_1_0,
                symbol: ref __self_1_1,
                tx: ref __self_1_2,
                tx_hash: ref __self_1_3,
                reporter: ref __self_1_4,
                report_reason: ref __self_1_5,
                illegal_man: ref __self_1_6,
                transaction_amount: ref __self_1_7,
                usdt_amount: ref __self_1_8,
                decimals: ref __self_1_9,
                approve_mans: ref __self_1_10,
                reject_mans: ref __self_1_11 } =>
                match *self {
                    VoteInfo {
                    start_vote_block: ref __self_0_0,
                    symbol: ref __self_0_1,
                    tx: ref __self_0_2,
                    tx_hash: ref __self_0_3,
                    reporter: ref __self_0_4,
                    report_reason: ref __self_0_5,
                    illegal_man: ref __self_0_6,
                    transaction_amount: ref __self_0_7,
                    usdt_amount: ref __self_0_8,
                    decimals: ref __self_0_9,
                    approve_mans: ref __self_0_10,
                    reject_mans: ref __self_0_11 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6) ||
                        (*__self_0_7) != (*__self_1_7) ||
                        (*__self_0_8) != (*__self_1_8) ||
                        (*__self_0_9) != (*__self_1_9) ||
                        (*__self_0_10) != (*__self_1_10) ||
                        (*__self_0_11) != (*__self_1_11),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Bo: ::core::fmt::Debug, A: ::core::fmt::Debug,
          Ba: ::core::fmt::Debug, H: ::core::fmt::Debug> ::core::fmt::Debug
     for VoteInfo<Bo, A, Ba, H> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                VoteInfo {
                start_vote_block: ref __self_0_0,
                symbol: ref __self_0_1,
                tx: ref __self_0_2,
                tx_hash: ref __self_0_3,
                reporter: ref __self_0_4,
                report_reason: ref __self_0_5,
                illegal_man: ref __self_0_6,
                transaction_amount: ref __self_0_7,
                usdt_amount: ref __self_0_8,
                decimals: ref __self_0_9,
                approve_mans: ref __self_0_10,
                reject_mans: ref __self_0_11 } => {
                    let mut debug_trait_builder = f.debug_struct("VoteInfo");
                    let _ =
                        debug_trait_builder.field("start_vote_block",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("symbol", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("tx", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("tx_hash", &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("reporter",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("report_reason",
                                                  &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("illegal_man",
                                                  &&(*__self_0_6));
                    let _ =
                        debug_trait_builder.field("transaction_amount",
                                                  &&(*__self_0_7));
                    let _ =
                        debug_trait_builder.field("usdt_amount",
                                                  &&(*__self_0_8));
                    let _ =
                        debug_trait_builder.field("decimals",
                                                  &&(*__self_0_9));
                    let _ =
                        debug_trait_builder.field("approve_mans",
                                                  &&(*__self_0_10));
                    let _ =
                        debug_trait_builder.field("reject_mans",
                                                  &&(*__self_0_11));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub enum IsPunished { YES, NO, }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for IsPunished {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        IsPunished::YES => { dest.push_byte(0usize as u8); }
                        IsPunished::NO => { dest.push_byte(1usize as u8); }
                        _ => (),
                    }
                }
            }
            impl _parity_scale_codec::EncodeLike for IsPunished { }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for IsPunished {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => { Ok(IsPunished::YES) }
                        x if x == 1usize as u8 => { Ok(IsPunished::NO) }
                        x => Err("No such variant in enum IsPunished".into()),
                    }
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for IsPunished {
        #[inline]
        fn clone(&self) -> IsPunished {
            match (&*self,) {
                (&IsPunished::YES,) => IsPunished::YES,
                (&IsPunished::NO,) => IsPunished::NO,
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for IsPunished { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for IsPunished {
        #[inline]
        fn eq(&self, other: &IsPunished) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for IsPunished {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&IsPunished::YES,) => {
                    let mut debug_trait_builder = f.debug_tuple("YES");
                    debug_trait_builder.finish()
                }
                (&IsPunished::NO,) => {
                    let mut debug_trait_builder = f.debug_tuple("NO");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub enum TreasuryNeed { SUB, ADD, }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for TreasuryNeed {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        TreasuryNeed::SUB => { dest.push_byte(0usize as u8); }
                        TreasuryNeed::ADD => { dest.push_byte(1usize as u8); }
                        _ => (),
                    }
                }
            }
            impl _parity_scale_codec::EncodeLike for TreasuryNeed { }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for TreasuryNeed {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => { Ok(TreasuryNeed::SUB) }
                        x if x == 1usize as u8 => { Ok(TreasuryNeed::ADD) }
                        x =>
                        Err("No such variant in enum TreasuryNeed".into()),
                    }
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TreasuryNeed {
        #[inline]
        fn clone(&self) -> TreasuryNeed {
            match (&*self,) {
                (&TreasuryNeed::SUB,) => TreasuryNeed::SUB,
                (&TreasuryNeed::ADD,) => TreasuryNeed::ADD,
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TreasuryNeed { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TreasuryNeed {
        #[inline]
        fn eq(&self, other: &TreasuryNeed) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TreasuryNeed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TreasuryNeed::SUB,) => {
                    let mut debug_trait_builder = f.debug_tuple("SUB");
                    debug_trait_builder.finish()
                }
                (&TreasuryNeed::ADD,) => {
                    let mut debug_trait_builder = f.debug_tuple("ADD");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub enum VoteResult { PASS, NoPASS, }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for VoteResult {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        VoteResult::PASS => { dest.push_byte(0usize as u8); }
                        VoteResult::NoPASS => {
                            dest.push_byte(1usize as u8);
                        }
                        _ => (),
                    }
                }
            }
            impl _parity_scale_codec::EncodeLike for VoteResult { }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for VoteResult {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => { Ok(VoteResult::PASS) }
                        x if x == 1usize as u8 => { Ok(VoteResult::NoPASS) }
                        x => Err("No such variant in enum VoteResult".into()),
                    }
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for VoteResult {
        #[inline]
        fn clone(&self) -> VoteResult {
            match (&*self,) {
                (&VoteResult::PASS,) => VoteResult::PASS,
                (&VoteResult::NoPASS,) => VoteResult::NoPASS,
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for VoteResult { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for VoteResult {
        #[inline]
        fn eq(&self, other: &VoteResult) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for VoteResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&VoteResult::PASS,) => {
                    let mut debug_trait_builder = f.debug_tuple("PASS");
                    debug_trait_builder.finish()
                }
                (&VoteResult::NoPASS,) => {
                    let mut debug_trait_builder = f.debug_tuple("NoPASS");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub trait Trait: balances::Trait + RegisterTrait +
     elections_phragmen::Trait {
        type
        ConcilOrigin: EnsureOrigin<Self::Origin,
        Success
        =
        Self::AccountId>;
        type
        Currency0: Currency<Self::AccountId> +
        ReservableCurrency<Self::AccountId>;
        type
        Thredshould: Get<u32>;
        type
        ProposalExpire: Get<Self::BlockNumber>;
        type
        VoteRewardPeriod: Get<Self::BlockNumber>;
        type
        ReportReserve: Get<BalanceOf<Self>>;
        type
        ReportReward: Get<BalanceOf<Self>>;
        type
        IllegalPunishment: Get<BalanceOf<Self>>;
        type
        CouncilReward: Get<BalanceOf<Self>>;
        type
        Event: From<Event<Self>> +
        Into<<Self as system::Trait>::Event>;
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{StorageValue
                                                                    as _,
                                                                    StorageMap
                                                                    as _,
                                                                    StorageLinkedMap
                                                                    as _,
                                                                    StorageDoubleMap
                                                                    as _};
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate support as hidden_include;
    }
    trait Store {
        type
        Votes;
        type
        Man_Txhashs;
        type
        RewardList;
        type
        AllPunishmentInfo;
    }
    impl <T: Trait + 'static> Store for Module<T> {
        type
        Votes
        =
        Votes<T>;
        type
        Man_Txhashs
        =
        Man_Txhashs<T>;
        type
        RewardList
        =
        RewardList<T>;
        type
        AllPunishmentInfo
        =
        AllPunishmentInfo<T>;
    }
    impl <T: Trait + 'static> Module<T> {
        pub fn votes<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<T::Hash>>(key:
                                                                                                                   K)
         -> VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash> {
            <Votes<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<T::Hash,
                                                                                               VoteInfo<T::BlockNumber,
                                                                                                        T::AccountId,
                                                                                                        T::Balance,
                                                                                                        T::Hash>>>::get(key)
        }
        pub fn mantxhashs<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<T::AccountId>>(key:
                                                                                                                             K)
         -> Vec<T::Hash> {
            <Man_Txhashs<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<T::AccountId,
                                                                                               Vec<T::Hash>>>::get(key)
        }
        pub fn rewardlist()
         -> Vec<VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>> {
            <RewardList<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageValue<Vec<VoteInfo<T::BlockNumber,
                                                                                                              T::AccountId,
                                                                                                              T::Balance,
                                                                                                              T::Hash>>>>::get()
        }
        pub fn allpunishmentinfo<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<T::Hash>>(key:
                                                                                                                               K)
         -> VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash> {
            <AllPunishmentInfo<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<T::Hash,
                                                                                               VoteInfo<T::BlockNumber,
                                                                                                        T::AccountId,
                                                                                                        T::Balance,
                                                                                                        T::Hash>>>::get(key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructVotes<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Votes:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructVotes<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Votes.get_or_init(||
                                                          {
                                                              let def_val:
                                                                      VoteInfo<T::BlockNumber,
                                                                               T::AccountId,
                                                                               T::Balance,
                                                                               T::Hash> =
                                                                  Default::default();
                                                              <VoteInfo<T::BlockNumber,
                                                                        T::AccountId,
                                                                        T::Balance,
                                                                        T::Hash>
                                                                  as
                                                                  Encode>::encode(&def_val)
                                                          }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructVotes<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructVotes<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructMan_Txhashs<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Man_Txhashs:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructMan_Txhashs<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Man_Txhashs.get_or_init(||
                                                                {
                                                                    let def_val:
                                                                            Vec<T::Hash> =
                                                                        Default::default();
                                                                    <Vec<T::Hash>
                                                                        as
                                                                        Encode>::encode(&def_val)
                                                                }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructMan_Txhashs<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructMan_Txhashs<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructRewardList<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_RewardList:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructRewardList<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_RewardList.get_or_init(||
                                                               {
                                                                   let def_val:
                                                                           Vec<VoteInfo<T::BlockNumber,
                                                                                        T::AccountId,
                                                                                        T::Balance,
                                                                                        T::Hash>> =
                                                                       Default::default();
                                                                   <Vec<VoteInfo<T::BlockNumber,
                                                                                 T::AccountId,
                                                                                 T::Balance,
                                                                                 T::Hash>>
                                                                       as
                                                                       Encode>::encode(&def_val)
                                                               }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructRewardList<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructRewardList<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructAllPunishmentInfo<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_AllPunishmentInfo:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructAllPunishmentInfo<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_AllPunishmentInfo.get_or_init(||
                                                                      {
                                                                          let def_val:
                                                                                  VoteInfo<T::BlockNumber,
                                                                                           T::AccountId,
                                                                                           T::Balance,
                                                                                           T::Hash> =
                                                                              Default::default();
                                                                          <VoteInfo<T::BlockNumber,
                                                                                    T::AccountId,
                                                                                    T::Balance,
                                                                                    T::Hash>
                                                                              as
                                                                              Encode>::encode(&def_val)
                                                                      }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructAllPunishmentInfo<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructAllPunishmentInfo<T> { }
    impl <T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata()
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata {
            self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata{prefix:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("ReportModule"),
                                                                                                 entries:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Votes"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::Hash"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructVotes::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Man_Txhashs"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::AccountId"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<T::Hash>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructMan_Txhashs::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("RewardList"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Plain(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>>")),
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructRewardList::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("AllPunishmentInfo"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("T::Hash"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructAllPunishmentInfo::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),}][..]),}
        }
    }
    #[doc = r" Tag a type as an instance of a module."]
    #[doc = r""]
    #[doc = r" Defines storage prefixes, they must be unique."]
    #[doc(hidden)]
    pub trait __GeneratedInstantiable: 'static {
        #[doc = r" The prefix used by any storage entry of an instance."]
        const
        PREFIX:
        &'static str;
    }
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance =>
                match *self { __InherentHiddenInstance => true, },
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for __InherentHiddenInstance {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                }
            }
            impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance
             {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for __InherentHiddenInstance {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(__InherentHiddenInstance)
                }
            }
        };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl __GeneratedInstantiable for __InherentHiddenInstance {
        const
        PREFIX:
        &'static str
        =
        "ReportModule";
    }
    pub struct Votes<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<T::Hash,
                                                                                               VoteInfo<T::BlockNumber,
                                                                                                        T::AccountId,
                                                                                                        T::Balance,
                                                                                                        T::Hash>>
     for Votes<T> {
        type
        Query
        =
        VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "Votes".as_bytes() }
        fn from_optional_value_to_query(v:
                                            Option<VoteInfo<T::BlockNumber,
                                                            T::AccountId,
                                                            T::Balance,
                                                            T::Hash>>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         ->
             Option<VoteInfo<T::BlockNumber, T::AccountId, T::Balance,
                             T::Hash>> {
            Some(v)
        }
    }
    pub struct Man_Txhashs<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<T::AccountId,
                                                                                               Vec<T::Hash>>
     for Man_Txhashs<T> {
        type
        Query
        =
        Vec<T::Hash>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "Man_Txhashs".as_bytes() }
        fn from_optional_value_to_query(v: Option<Vec<T::Hash>>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<Vec<T::Hash>> {
            Some(v)
        }
    }
    pub struct RewardList<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<Vec<VoteInfo<T::BlockNumber,
                                                                                                              T::AccountId,
                                                                                                              T::Balance,
                                                                                                              T::Hash>>>
     for RewardList<T> {
        type
        Query
        =
        Vec<VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>>;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "RewardList".as_bytes() }
        fn from_optional_value_to_query(v:
                                            Option<Vec<VoteInfo<T::BlockNumber,
                                                                T::AccountId,
                                                                T::Balance,
                                                                T::Hash>>>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         ->
             Option<Vec<VoteInfo<T::BlockNumber, T::AccountId, T::Balance,
                                 T::Hash>>> {
            Some(v)
        }
    }
    pub struct AllPunishmentInfo<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<T::Hash,
                                                                                               VoteInfo<T::BlockNumber,
                                                                                                        T::AccountId,
                                                                                                        T::Balance,
                                                                                                        T::Hash>>
     for AllPunishmentInfo<T> {
        type
        Query
        =
        VoteInfo<T::BlockNumber, T::AccountId, T::Balance, T::Hash>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] {
            "AllPunishmentInfo".as_bytes()
        }
        fn from_optional_value_to_query(v:
                                            Option<VoteInfo<T::BlockNumber,
                                                            T::AccountId,
                                                            T::Balance,
                                                            T::Hash>>)
         -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         ->
             Option<VoteInfo<T::BlockNumber, T::AccountId, T::Balance,
                             T::Hash>> {
            Some(v)
        }
    }
    pub struct Module<T: Trait>(::frame_support::rstd::marker::PhantomData<(T)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T>
     {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) =>
                Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T>
     {
    }
    impl <T: Trait> ::core::marker::StructuralPartialEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for
     Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl <T: Trait> ::core::marker::StructuralEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _:
                        ::core::cmp::AssertParamIsEq<::frame_support::rstd::marker::PhantomData<(T)>>;
            }
        }
    }
    impl <T: Trait> core::fmt::Debug for Module<T> where T: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnInitialize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnFinalize<T::BlockNumber> for
     Module<T> {
        fn on_finalize(n: T::BlockNumber) {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("on_finalize",
                                                                                "node_runtime::report",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/report.rs"),
                                                                                Some(122u32),
                                                                                Some("node_runtime::report"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                if (n % T::VoteRewardPeriod::get()).is_zero() {
                    Self::reward();
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::WeighBlock<T::BlockNumber> for
     Module<T> {
        fn on_finalize(n: T::BlockNumber)
         -> ::frame_support::dispatch::Weight {
            <dyn ::frame_support::dispatch::WeighData<T::BlockNumber>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::zero(),
                                                                                   n)
        }
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OffchainWorker<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> Module<T> {
        pub fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <system::Module<T>>::deposit_event(event.into())
        }
    }
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl <T: Trait> Module<T> {
        pub fn report(origin: T::Origin, symbol: Vec<u8>, tx: Vec<u8>,
                      repoter: T::AccountId, reason: Vec<u8>,
                      illegalman: T::AccountId, tx_amount: T::Balance,
                      usdt_amount: T::Balance, decimals: u32) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("report",
                                                                                "node_runtime::report",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/report.rs"),
                                                                                Some(122u32),
                                                                                Some("node_runtime::report"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = ensure_signed(origin)?;
                {
                    if !(<BlackList<T>>::exists(who.clone()) ||
                             <BlackList<T>>::exists(illegalman.clone())) {
                        {
                            return Err("someone in the blacklist can't report.");
                        };
                    }
                };
                {
                    if !!Self::is_register_member(illegalman.clone()) {
                        {
                            return Err("you are not the member of the register. ");
                        };
                    }
                };
                let tx_hash = tx.using_encoded(<T as system::Trait>::hash);
                {
                    if !!<Votes<T>>::exists(&tx_hash) {
                        {
                            return Err("the tx exists in the report queue, you can't put it into again.");
                        };
                    }
                };
                T::Currency0::reserve(&who,
                                      T::ReportReserve::get()).map_err(|_|
                                                                           "balance too low, you can't report")?;
                let start_vote_block = <system::Module<T>>::block_number();
                let mut vote_info =
                    VoteInfo{start_vote_block: start_vote_block.clone(),
                             symbol: symbol.clone(),
                             tx: tx.clone(),
                             tx_hash: tx_hash.clone(),
                             reporter: who.clone(),
                             report_reason: reason.clone(),
                             illegal_man: illegalman.clone(),
                             transaction_amount: tx_amount.clone(),
                             usdt_amount: usdt_amount.clone(),
                             decimals: decimals.clone(),
                             approve_mans: <[_]>::into_vec(box []),
                             reject_mans: <[_]>::into_vec(box []),};
                if Self::is_concil_member(who.clone()) {
                    vote_info.approve_mans.push(who.clone());
                }
                <Votes<T>>::insert(tx_hash.clone(), vote_info);
                Self::add_mantxhashs(who.clone(), tx_hash.clone());
                Self::add_mantxhashs(illegalman.clone(), tx_hash.clone());
                Self::deposit_event(RawEvent::ReportEvent(start_vote_block,
                                                          illegalman));
                Ok(())
            }
        }
        pub fn vote(origin: T::Origin, tx_hash: T::Hash, yes_no: bool)
         -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("vote",
                                                                                "node_runtime::report",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/report.rs"),
                                                                                Some(122u32),
                                                                                Some("node_runtime::report"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = T::ConcilOrigin::ensure_origin(origin)?;
                {
                    if !!(<Votes<T>>::exists(&tx_hash)) {
                        { return Err("the tx_hash not in vote_queue."); };
                    }
                };
                let illegalman = <Votes<T>>::get(&tx_hash).illegal_man;
                {
                    if !!(illegalman.clone() == who.clone()) {
                        {
                            return Err("you are being reported, can't vote.");
                        };
                    }
                };
                {
                    if !(<BlackList<T>>::exists(who.clone()) ||
                             <BlackList<T>>::exists(illegalman.clone())) {
                        {
                            return Err("someone don't exists in register_list.");
                        };
                    }
                };
                let now = <system::Module<T>>::block_number();
                if now - <Votes<T>>::get(&tx_hash).start_vote_block >
                       T::ProposalExpire::get() {
                    <Votes<T>>::remove(&tx_hash);
                    T::Currency0::unreserve(&<Votes<T>>::get(&tx_hash).reporter,
                                            T::ReportReserve::get());
                    Self::remove_mantxhashs(who.clone(), tx_hash.clone());
                    Self::remove_mantxhashs(illegalman.clone(),
                                            tx_hash.clone());
                    {
                        if !(1 == 2) {
                            { return Err("the vote is expire."); };
                        }
                    }
                }
                let mut voting = <Votes<T>>::get(&tx_hash);
                let position_yes =
                    voting.approve_mans.iter().position(|a| a == &who);
                let position_no =
                    voting.reject_mans.iter().position(|a| a == &who);
                if yes_no {
                    if position_yes.is_none() {
                        voting.approve_mans.push(who.clone());
                    } else { return Err("duplicate vote ignored") }
                    if let Some(pos) = position_no {
                        voting.reject_mans.swap_remove(pos);
                    }
                } else {
                    if position_no.is_none() {
                        voting.reject_mans.push(who.clone());
                    } else { return Err("duplicate vote ignored") }
                    if let Some(pos) = position_yes {
                        voting.approve_mans.swap_remove(pos);
                    }
                }
                <Votes<T>>::insert(tx_hash.clone(), voting.clone());
                let vote_result = Self::vote_result(voting.clone());
                if vote_result.0 == VoteResult::PASS {
                    <RewardList<T>>::mutate(|a| a.push(voting.clone()));
                    Self::remove_mantxhashs(who.clone(), tx_hash.clone());
                    Self::remove_mantxhashs(illegalman.clone(),
                                            tx_hash.clone());
                    if vote_result.1 == IsPunished::YES {
                        <BlackList<T>>::insert(illegalman.clone(),
                                               tx_hash.clone());
                        Self::kill_register(illegalman.clone());
                        <AllPunishmentInfo<T>>::insert(tx_hash.clone(),
                                                       voting.clone());
                    }
                }
                Self::deposit_event(RawEvent::VoteEvent(illegalman.clone()));
                Ok(())
            }
        }
    }
    #[doc = r" The module declaration."]
    pub enum Call<T: Trait> {

        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(::frame_support::rstd::marker::PhantomData<(T)>,
                      ::frame_support::dispatch::Never),

        #[allow(non_camel_case_types)]
        report(Vec<u8>, Vec<u8>, T::AccountId, Vec<u8>, T::AccountId,
               T::Balance, T::Balance, u32),

        #[allow(non_camel_case_types)]
        vote(T::Hash, bool),
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Encode for Call<T> where
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Hash: _parity_scale_codec::Encode,
             T::Hash: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        Call::report(ref aa, ref ba, ref ca, ref da, ref ea,
                                     ref fa, ref ga, ref ha) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                            dest.push(ca);
                            dest.push(da);
                            dest.push(ea);
                            dest.push(fa);
                            dest.push(ga);
                            dest.push(ha);
                        }
                        Call::vote(ref aa, ref ba) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        _ => (),
                    }
                }
            }
            impl <T: Trait> _parity_scale_codec::EncodeLike for Call<T> where
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::AccountId: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Balance: _parity_scale_codec::Encode,
             T::Hash: _parity_scale_codec::Encode,
             T::Hash: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Decode for Call<T> where
             T::AccountId: _parity_scale_codec::Decode,
             T::AccountId: _parity_scale_codec::Decode,
             T::AccountId: _parity_scale_codec::Decode,
             T::AccountId: _parity_scale_codec::Decode,
             T::Balance: _parity_scale_codec::Decode,
             T::Balance: _parity_scale_codec::Decode,
             T::Balance: _parity_scale_codec::Decode,
             T::Balance: _parity_scale_codec::Decode,
             T::Hash: _parity_scale_codec::Decode,
             T::Hash: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(Call::report({
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.0".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.1".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.2".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.3".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.4".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.5".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.6".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: report.7".into()),
                                                    Ok(a) => a,
                                                }
                                            }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(Call::vote({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: vote.0".into()),
                                                  Ok(a) => a,
                                              }
                                          },
                                          {
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: vote.1".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                        }
                        x => Err("No such variant in enum Call".into()),
                    }
                }
            }
        };
    impl <T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self)
         -> ::frame_support::dispatch::DispatchInfo {
            if let Call::report(ref symbol, ref tx, ref repoter, ref reason,
                                ref illegalman, ref tx_amount,
                                ref usdt_amount, ref decimals) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,
                                                               &Vec<u8>,
                                                               &T::AccountId,
                                                               &Vec<u8>,
                                                               &T::AccountId,
                                                               &T::Balance,
                                                               &T::Balance,
                                                               &u32)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                   (symbol,
                                                                                    tx,
                                                                                    repoter,
                                                                                    reason,
                                                                                    illegalman,
                                                                                    tx_amount,
                                                                                    usdt_amount,
                                                                                    decimals));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,
                                                                      &Vec<u8>,
                                                                      &T::AccountId,
                                                                      &Vec<u8>,
                                                                      &T::AccountId,
                                                                      &T::Balance,
                                                                      &T::Balance,
                                                                      &u32)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                 (symbol,
                                                                                                  tx,
                                                                                                  repoter,
                                                                                                  reason,
                                                                                                  illegalman,
                                                                                                  tx_amount,
                                                                                                  usdt_amount,
                                                                                                  decimals));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/report.rs",
                                                         122u32, 1u32))
                        }
                    }
                }
            }
            if let Call::vote(ref tx_hash, ref yes_no) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&T::Hash,
                                                               &bool)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                    (tx_hash,
                                                                                     yes_no));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&T::Hash,
                                                                      &bool)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                  (tx_hash,
                                                                                                   yes_no));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/report.rs",
                                                         122u32, 1u32))
                        }
                    }
                }
            }
            let weight =
                <dyn ::frame_support::dispatch::WeighData<_>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                          ());
            let class =
                <dyn ::frame_support::dispatch::ClassifyDispatch<_>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                        ());
            let pays_fee =
                <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
            ::frame_support::dispatch::DispatchInfo{weight, class, pays_fee,}
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::report(ref symbol, ref tx, ref repoter, ref reason,
                             ref illegalman, ref tx_amount, ref usdt_amount,
                             ref decimals) =>
                Call::report((*symbol).clone(), (*tx).clone(),
                             (*repoter).clone(), (*reason).clone(),
                             (*illegalman).clone(), (*tx_amount).clone(),
                             (*usdt_amount).clone(), (*decimals).clone()),
                Call::vote(ref tx_hash, ref yes_no) =>
                Call::vote((*tx_hash).clone(), (*yes_no).clone()),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/report.rs",
                                                 122u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::report(ref symbol, ref tx, ref repoter, ref reason,
                             ref illegalman, ref tx_amount, ref usdt_amount,
                             ref decimals) => {
                    let self_params =
                        (symbol, tx, repoter, reason, illegalman, tx_amount,
                         usdt_amount, decimals);
                    if let Call::report(ref symbol, ref tx, ref repoter,
                                        ref reason, ref illegalman,
                                        ref tx_amount, ref usdt_amount,
                                        ref decimals) = *_other {
                        self_params ==
                            (symbol, tx, repoter, reason, illegalman,
                             tx_amount, usdt_amount, decimals)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/report.rs",
                                                             122u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::vote(ref tx_hash, ref yes_no) => {
                    let self_params = (tx_hash, yes_no);
                    if let Call::vote(ref tx_hash, ref yes_no) = *_other {
                        self_params == (tx_hash, yes_no)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/report.rs",
                                                             122u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/report.rs",
                                                 122u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Eq for Call<T> { }
    impl <T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(&self, _f: &mut ::frame_support::dispatch::fmt::Formatter)
         ->
             ::frame_support::dispatch::result::Result<(),
                                                       ::frame_support::dispatch::fmt::Error> {
            match *self {
                Call::report(ref symbol, ref tx, ref repoter, ref reason,
                             ref illegalman, ref tx_amount, ref usdt_amount,
                             ref decimals) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"report",
                                                                    &(symbol.clone(),
                                                                      tx.clone(),
                                                                      repoter.clone(),
                                                                      reason.clone(),
                                                                      illegalman.clone(),
                                                                      tx_amount.clone(),
                                                                      usdt_amount.clone(),
                                                                      decimals.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::vote(ref tx_hash, ref yes_no) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"vote",
                                                                    &(tx_hash.clone(),
                                                                      yes_no.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/report.rs",
                                                 122u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Dispatchable for Call<T> {
        type
        Trait
        =
        T;
        type
        Origin
        =
        T::Origin;
        type
        Error
        =
        &'static str;
        fn dispatch(self, _origin: Self::Origin)
         -> ::frame_support::dispatch::DispatchResult<Self::Error> {
            match self {
                Call::report(symbol, tx, repoter, reason, illegalman,
                             tx_amount, usdt_amount, decimals) => {
                    <Module<T>>::report(_origin, symbol, tx, repoter, reason,
                                        illegalman, tx_amount, usdt_amount,
                                        decimals)
                }
                Call::vote(tx_hash, yes_no) => {
                    <Module<T>>::vote(_origin, tx_hash, yes_no)
                }
                Call::__PhantomItem(_, _) => {
                    {
                        {
                            {
                                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                           &match (&"__PhantomItem should never be used.",)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::core::fmt::Display::fmt)],
                                                                                            }),
                                                           &("bin/node/runtime/src/report.rs",
                                                             122u32, 1u32))
                            }
                        }
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type
        Call
        =
        Call<T>;
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn dispatch<D: ::frame_support::dispatch::Dispatchable<Trait =
                        T>>(d: D, origin: D::Origin)
         -> ::frame_support::dispatch::DispatchResult<D::Error> {
            d.dispatch(origin)
        }
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn call_functions()
         -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("report"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("symbol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tx"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("repoter"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::AccountId"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("reason"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("illegalman"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::AccountId"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tx_amount"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::Balance"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("usdt_amount"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::Balance"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("decimals"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("u32"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("vote"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tx_hash"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("T::Hash"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("yes_no"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("bool"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),}]
        }
    }
    impl <T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        pub fn module_constants_metadata()
         -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl <T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for
     Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as
                ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    /// [`RawEvent`] specialized for the configuration [`Trait`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Trait`]: trait.Trait.html
    pub type Event<T>
        =
        RawEvent<<T as system::Trait>::AccountId,
                 <T as system::Trait>::BlockNumber,
                 <T as system::Trait>::Hash, <T as balances::Trait>::Balance>;
    /// Events for this module.
    ///
    pub enum RawEvent<AccountId, BlockNumber, Hash, Balance> {
        ReportEvent(BlockNumber, AccountId),
        VoteEvent(AccountId),
        VoteFinishEvent(AccountId),
        TreasuryEvent(bool, Balance),
        RewardEvent(AccountId, Hash),
        SomethingStored(u32, AccountId),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::clone::Clone, BlockNumber: ::core::clone::Clone,
          Hash: ::core::clone::Clone, Balance: ::core::clone::Clone>
     ::core::clone::Clone for RawEvent<AccountId, BlockNumber, Hash, Balance>
     {
        #[inline]
        fn clone(&self) -> RawEvent<AccountId, BlockNumber, Hash, Balance> {
            match (&*self,) {
                (&RawEvent::ReportEvent(ref __self_0, ref __self_1),) =>
                RawEvent::ReportEvent(::core::clone::Clone::clone(&(*__self_0)),
                                      ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::VoteEvent(ref __self_0),) =>
                RawEvent::VoteEvent(::core::clone::Clone::clone(&(*__self_0))),
                (&RawEvent::VoteFinishEvent(ref __self_0),) =>
                RawEvent::VoteFinishEvent(::core::clone::Clone::clone(&(*__self_0))),
                (&RawEvent::TreasuryEvent(ref __self_0, ref __self_1),) =>
                RawEvent::TreasuryEvent(::core::clone::Clone::clone(&(*__self_0)),
                                        ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::RewardEvent(ref __self_0, ref __self_1),) =>
                RawEvent::RewardEvent(::core::clone::Clone::clone(&(*__self_0)),
                                      ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::SomethingStored(ref __self_0, ref __self_1),) =>
                RawEvent::SomethingStored(::core::clone::Clone::clone(&(*__self_0)),
                                          ::core::clone::Clone::clone(&(*__self_1))),
            }
        }
    }
    impl <AccountId, BlockNumber, Hash, Balance>
     ::core::marker::StructuralPartialEq for
     RawEvent<AccountId, BlockNumber, Hash, Balance> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::PartialEq,
          BlockNumber: ::core::cmp::PartialEq, Hash: ::core::cmp::PartialEq,
          Balance: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
     RawEvent<AccountId, BlockNumber, Hash, Balance> {
        #[inline]
        fn eq(&self, other: &RawEvent<AccountId, BlockNumber, Hash, Balance>)
         -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::ReportEvent(ref __self_0, ref __self_1),
                         &RawEvent::ReportEvent(ref __arg_1_0, ref __arg_1_1))
                        =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::VoteEvent(ref __self_0),
                         &RawEvent::VoteEvent(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&RawEvent::VoteFinishEvent(ref __self_0),
                         &RawEvent::VoteFinishEvent(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&RawEvent::TreasuryEvent(ref __self_0, ref __self_1),
                         &RawEvent::TreasuryEvent(ref __arg_1_0,
                                                  ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::RewardEvent(ref __self_0, ref __self_1),
                         &RawEvent::RewardEvent(ref __arg_1_0, ref __arg_1_1))
                        =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::SomethingStored(ref __self_0,
                                                    ref __self_1),
                         &RawEvent::SomethingStored(ref __arg_1_0,
                                                    ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<AccountId, BlockNumber, Hash, Balance>)
         -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::ReportEvent(ref __self_0, ref __self_1),
                         &RawEvent::ReportEvent(ref __arg_1_0, ref __arg_1_1))
                        =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::VoteEvent(ref __self_0),
                         &RawEvent::VoteEvent(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&RawEvent::VoteFinishEvent(ref __self_0),
                         &RawEvent::VoteFinishEvent(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&RawEvent::TreasuryEvent(ref __self_0, ref __self_1),
                         &RawEvent::TreasuryEvent(ref __arg_1_0,
                                                  ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::RewardEvent(ref __self_0, ref __self_1),
                         &RawEvent::RewardEvent(ref __arg_1_0, ref __arg_1_1))
                        =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::SomethingStored(ref __self_0,
                                                    ref __self_1),
                         &RawEvent::SomethingStored(ref __arg_1_0,
                                                    ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    impl <AccountId, BlockNumber, Hash, Balance> ::core::marker::StructuralEq
     for RawEvent<AccountId, BlockNumber, Hash, Balance> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::Eq, BlockNumber: ::core::cmp::Eq,
          Hash: ::core::cmp::Eq, Balance: ::core::cmp::Eq> ::core::cmp::Eq for
     RawEvent<AccountId, BlockNumber, Hash, Balance> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<BlockNumber>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Balance>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Hash>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, BlockNumber, Hash, Balance>
             _parity_scale_codec::Encode for
             RawEvent<AccountId, BlockNumber, Hash, Balance> where
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        RawEvent::ReportEvent(ref aa, ref ba) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::VoteEvent(ref aa) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                        }
                        RawEvent::VoteFinishEvent(ref aa) => {
                            dest.push_byte(2usize as u8);
                            dest.push(aa);
                        }
                        RawEvent::TreasuryEvent(ref aa, ref ba) => {
                            dest.push_byte(3usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::RewardEvent(ref aa, ref ba) => {
                            dest.push_byte(4usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::SomethingStored(ref aa, ref ba) => {
                            dest.push_byte(5usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        _ => (),
                    }
                }
            }
            impl <AccountId, BlockNumber, Hash, Balance>
             _parity_scale_codec::EncodeLike for
             RawEvent<AccountId, BlockNumber, Hash, Balance> where
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, BlockNumber, Hash, Balance>
             _parity_scale_codec::Decode for
             RawEvent<AccountId, BlockNumber, Hash, Balance> where
             BlockNumber: _parity_scale_codec::Decode,
             BlockNumber: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             Hash: _parity_scale_codec::Decode,
             Hash: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(RawEvent::ReportEvent({
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field RawEvent :: ReportEvent.0".into()),
                                                             Ok(a) => a,
                                                         }
                                                     },
                                                     {
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field RawEvent :: ReportEvent.1".into()),
                                                             Ok(a) => a,
                                                         }
                                                     }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(RawEvent::VoteEvent({
                                                       let res =
                                                           _parity_scale_codec::Decode::decode(input);
                                                       match res {
                                                           Err(_) =>
                                                           return Err("Error decoding field RawEvent :: VoteEvent.0".into()),
                                                           Ok(a) => a,
                                                       }
                                                   }))
                        }
                        x if x == 2usize as u8 => {
                            Ok(RawEvent::VoteFinishEvent({
                                                             let res =
                                                                 _parity_scale_codec::Decode::decode(input);
                                                             match res {
                                                                 Err(_) =>
                                                                 return Err("Error decoding field RawEvent :: VoteFinishEvent.0".into()),
                                                                 Ok(a) => a,
                                                             }
                                                         }))
                        }
                        x if x == 3usize as u8 => {
                            Ok(RawEvent::TreasuryEvent({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: TreasuryEvent.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       },
                                                       {
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: TreasuryEvent.1".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                        }
                        x if x == 4usize as u8 => {
                            Ok(RawEvent::RewardEvent({
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field RawEvent :: RewardEvent.0".into()),
                                                             Ok(a) => a,
                                                         }
                                                     },
                                                     {
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field RawEvent :: RewardEvent.1".into()),
                                                             Ok(a) => a,
                                                         }
                                                     }))
                        }
                        x if x == 5usize as u8 => {
                            Ok(RawEvent::SomethingStored({
                                                             let res =
                                                                 _parity_scale_codec::Decode::decode(input);
                                                             match res {
                                                                 Err(_) =>
                                                                 return Err("Error decoding field RawEvent :: SomethingStored.0".into()),
                                                                 Ok(a) => a,
                                                             }
                                                         },
                                                         {
                                                             let res =
                                                                 _parity_scale_codec::Decode::decode(input);
                                                             match res {
                                                                 Err(_) =>
                                                                 return Err("Error decoding field RawEvent :: SomethingStored.1".into()),
                                                                 Ok(a) => a,
                                                             }
                                                         }))
                        }
                        x => Err("No such variant in enum RawEvent".into()),
                    }
                }
            }
        };
    impl <AccountId, BlockNumber, Hash, Balance> core::fmt::Debug for
     RawEvent<AccountId, BlockNumber, Hash, Balance> where
     AccountId: core::fmt::Debug, BlockNumber: core::fmt::Debug,
     Hash: core::fmt::Debug, Balance: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::ReportEvent(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::ReportEvent").field(a0).field(a1).finish(),
                Self::VoteEvent(ref a0) =>
                fmt.debug_tuple("RawEvent::VoteEvent").field(a0).finish(),
                Self::VoteFinishEvent(ref a0) =>
                fmt.debug_tuple("RawEvent::VoteFinishEvent").field(a0).finish(),
                Self::TreasuryEvent(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::TreasuryEvent").field(a0).field(a1).finish(),
                Self::RewardEvent(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::RewardEvent").field(a0).field(a1).finish(),
                Self::SomethingStored(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::SomethingStored").field(a0).field(a1).finish(),
                _ => Ok(()),
            }
        }
    }
    impl <AccountId, BlockNumber, Hash, Balance>
     From<RawEvent<AccountId, BlockNumber, Hash, Balance>> for () {
        fn from(_: RawEvent<AccountId, BlockNumber, Hash, Balance>) -> () {
            ()
        }
    }
    impl <AccountId, BlockNumber, Hash, Balance>
     RawEvent<AccountId, BlockNumber, Hash, Balance> {
        #[allow(dead_code)]
        pub fn metadata()
         -> &'static [::frame_support::event::EventMetadata] {
            &[::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("ReportEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["BlockNumber",
                                                                                                          "AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("VoteEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("VoteFinishEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("TreasuryEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["bool",
                                                                                                          "Balance"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("RewardEvent"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId",
                                                                                                          "Hash"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("SomethingStored"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["u32",
                                                                                                          "AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),}]
        }
    }
    impl <T: Trait> Module<T> {
        pub fn reward() -> Result {
            let mut useable_balance = Self::treasury_useable_balance();
            let treasury_id = Self::get_treasury_id();
            for i in 0..2 {
                <RewardList<T>>::mutate(|v|
                                            {
                                                v.retain(|voteinfo|
                                                             {
                                                                 let is_punish =
                                                                     Self::vote_result(voteinfo.clone()).1;
                                                                 let treasury_result =
                                                                     Self::treasury_imbalance(is_punish.clone(),
                                                                                              voteinfo.clone());
                                                                 let sub_or_add =
                                                                     treasury_result.0;
                                                                 let imbalances =
                                                                     treasury_result.1;
                                                                 if sub_or_add
                                                                        ==
                                                                        TreasuryNeed::ADD
                                                                    {
                                                                     useable_balance
                                                                         +=
                                                                         imbalances;
                                                                     T::Currency0::make_free_balance_be(&treasury_id,
                                                                                                        useable_balance
                                                                                                            +
                                                                                                            T::Currency0::minimum_balance());
                                                                     <Votes<T>>::remove(voteinfo.clone().tx_hash);
                                                                     Self::everyone_balance_oprate(is_punish.clone(),
                                                                                                   voteinfo.clone());
                                                                     false
                                                                 } else {
                                                                     if useable_balance
                                                                            >=
                                                                            imbalances
                                                                        {
                                                                         useable_balance
                                                                             -=
                                                                             imbalances;
                                                                         T::Currency0::make_free_balance_be(&treasury_id,
                                                                                                            useable_balance
                                                                                                                +
                                                                                                                T::Currency0::minimum_balance());
                                                                         <Votes<T>>::remove(voteinfo.clone().tx_hash);
                                                                         Self::everyone_balance_oprate(is_punish.clone(),
                                                                                                       voteinfo.clone());
                                                                         false
                                                                     } else {
                                                                         true
                                                                     }
                                                                 }
                                                             });
                                            });
            }
            Ok(())
        }
        pub fn is_concil_member(who: T::AccountId) -> bool {
            if <elections_phragmen::Module<T>>::is_member(&who) {
                true
            } else { false }
        }
        pub fn is_register_member(who: T::AccountId) -> bool {
            if <AllMiners<T>>::exists(&who) { true } else { false }
        }
        pub fn kill_register(who: T::AccountId) {
            <register::Module<T>>::kill_man(who.clone());
        }
        pub fn get_treasury_id() -> T::AccountId { MODULE_ID.into_account() }
        pub fn treasury_useable_balance() -> BalanceOf<T> {
            T::Currency0::free_balance(&Self::get_treasury_id()).saturating_sub(T::Currency0::minimum_balance())
        }
        pub fn add_mantxhashs(who: T::AccountId, tx_hash: T::Hash) {
            let mut vec_txhash = <[_]>::into_vec(box []);
            if <Man_Txhashs<T>>::exists(&who) {
                vec_txhash = <Man_Txhashs<T>>::get(&who);
                vec_txhash.push(tx_hash);
            } else { vec_txhash.push(tx_hash) }
            <Man_Txhashs<T>>::insert(&who, &vec_txhash);
        }
        pub fn remove_mantxhashs(who: T::AccountId, tx_hash: T::Hash) {
            let mut vec_txhash = <[_]>::into_vec(box []);
            vec_txhash = <Man_Txhashs<T>>::get(&who);
            if let Some(pos) =
                   vec_txhash.iter().position(|a|
                                                  <Votes<T>>::exists(&tx_hash))
               {
                vec_txhash.swap_remove(pos);
            };
            if vec_txhash.len() == 0 {
                <Man_Txhashs<T>>::remove(&who)
            } else { <Man_Txhashs<T>>::insert(&who, &vec_txhash); }
        }
        pub fn vote_result(vote_info:
                               VoteInfo<T::BlockNumber, T::AccountId,
                                        T::Balance, T::Hash>)
         -> (VoteResult, IsPunished) {
            let approve_len = vote_info.approve_mans.len() as u32;
            let reject_len = vote_info.reject_mans.len() as u32;
            if approve_len - reject_len >= 2 || reject_len - approve_len >= 2
                   || approve_len >= T::Thredshould::get() ||
                   reject_len >= T::Thredshould::get() {
                if approve_len > reject_len {
                    (VoteResult::PASS, IsPunished::YES)
                } else { (VoteResult::PASS, IsPunished::NO) }
            } else { (VoteResult::NoPASS, IsPunished::NO) }
        }
        pub fn treasury_imbalance(is_punish: IsPunished,
                                  vote:
                                      VoteInfo<T::BlockNumber, T::AccountId,
                                               T::Balance, T::Hash>)
         -> (TreasuryNeed, BalanceOf<T>) {
            let reporter = vote.clone().reporter;
            let illegalman = vote.clone().illegal_man;
            let mut postive: BalanceOf<T> = 0.into();
            let mut negative: BalanceOf<T> = 0.into();
            if is_punish == IsPunished::YES {
                if !<BlackList<T>>::exists(reporter.clone()) {
                    if T::Currency0::total_balance(&illegalman) >=
                           T::IllegalPunishment::get() {
                        postive = T::IllegalPunishment::get();
                    } else {
                        postive = T::Currency0::total_balance(&illegalman);
                    }
                }
                if !<BlackList<T>>::exists(reporter.clone()) {
                    negative = T::ReportReward::get();
                }
            } else {
                if !<BlackList<T>>::exists(reporter.clone()) {
                    if <system::AccountNonce<T>>::exists(reporter.clone()) {
                        if T::Currency0::total_balance(&reporter) >=
                               T::ReportReserve::get() {
                            postive += T::ReportReserve::get().clone();
                        } else {
                            postive += T::Currency0::total_balance(&reporter);
                        }
                    }
                }
            }
            let mut all_mans =
                vote.reject_mans.iter().chain(vote.approve_mans.iter());
            for i in 0..all_mans.clone().count() {
                if let Some(peaple) = all_mans.next() {
                    if !<BlackList<T>>::exists(peaple.clone()) {
                        if <system::AccountNonce<T>>::exists(peaple.clone()) {
                            if T::ReportReward::get() +
                                   T::Currency0::total_balance(&peaple) >=
                                   T::Currency0::minimum_balance() {
                                negative += T::CouncilReward::get().clone();
                            }
                        } else {
                            if T::ReportReward::get() >=
                                   T::Currency0::minimum_balance() {
                                negative += T::CouncilReward::get().clone();
                            }
                        }
                    }
                };
            }
            if postive > negative {
                (TreasuryNeed::SUB, postive - negative)
            } else { (TreasuryNeed::ADD, negative - postive) }
        }
        pub fn everyone_balance_oprate(is_punish: IsPunished,
                                       vote:
                                           VoteInfo<T::BlockNumber,
                                                    T::AccountId, T::Balance,
                                                    T::Hash>) {
            let reporter = vote.clone().reporter;
            let illegalman = vote.clone().illegal_man;
            if is_punish == IsPunished::YES {
                if !<BlackList<T>>::exists(reporter.clone()) {
                    if T::Currency0::total_balance(&illegalman) >=
                           T::IllegalPunishment::get() {
                        T::Currency0::slash_reserved(&illegalman,
                                                     T::IllegalPunishment::get());
                    } else {
                        T::Currency0::slash_reserved(&illegalman,
                                                     T::Currency0::total_balance(&illegalman));
                    }
                }
                if !<BlackList<T>>::exists(reporter.clone()) {
                    T::Currency0::unreserve(&reporter,
                                            T::ReportReserve::get());
                    T::Currency0::deposit_creating(&reporter,
                                                   T::ReportReward::get());
                }
            } else {
                if !<BlackList<T>>::exists(reporter.clone()) {
                    if <system::AccountNonce<T>>::exists(reporter.clone()) {
                        if T::Currency0::total_balance(&reporter) >=
                               T::ReportReserve::get() {
                            T::Currency0::slash_reserved(&reporter,
                                                         T::ReportReserve::get());
                        } else {
                            T::Currency0::slash_reserved(&reporter,
                                                         T::Currency0::total_balance(&reporter));
                        }
                    }
                }
            }
            let mut all_mans =
                vote.reject_mans.iter().chain(vote.approve_mans.iter());
            for i in 0..all_mans.clone().count() {
                if let Some(peaple) = all_mans.next() {
                    if !<BlackList<T>>::exists(peaple.clone()) {
                        if <system::AccountNonce<T>>::exists(peaple.clone()) {
                            if T::ReportReward::get() +
                                   T::Currency0::total_balance(&peaple) >=
                                   T::Currency0::minimum_balance() {
                                T::Currency0::deposit_creating(&peaple,
                                                               T::CouncilReward::get());
                            }
                        } else {
                            if T::ReportReward::get() >=
                                   T::Currency0::minimum_balance() {
                                T::Currency0::deposit_creating(&peaple,
                                                               T::CouncilReward::get());
                            }
                        }
                    }
                };
            }
        }
    }
}
mod mine {
    use support::{debug, decl_storage, decl_module, decl_event, StorageValue,
                  StorageMap, Parameter, dispatch::Result, ensure,
                  dispatch::Vec, traits::Currency};
    use support::traits::{Get, ReservableCurrency};
    use system::{ensure_signed};
    use sp_runtime::traits::{Hash, SimpleArithmetic, Bounded, One, Member,
                             CheckedAdd};
    use codec::{Encode, Decode};
    use crate::mine_linked::{PersonMineWorkForce, PersonMine, MineParm,
                             PersonMineRecord, BLOCK_NUMS};
    use crate::register::{AllMiners, Trait as RegisterTrait};
    pub trait Trait: balances::Trait + RegisterTrait {
        type
        Event: From<Event<Self>> +
        Into<<Self as system::Trait>::Event>;
        type
        MineIndex: Parameter +
        Member +
        SimpleArithmetic +
        Bounded +
        Default +
        Copy;
    }
    type BlockNumberOf<T> = <T as system::Trait>::BlockNumber;
    type OwnerMineWorkForce<T>
        =
        PersonMineWorkForce<<T as system::Trait>::BlockNumber>;
    type OwnerWorkForceItem<T>
        =
        PersonMine<OwnedDayWorkForce<T>, <T as system::Trait>::AccountId,
                   <T as system::Trait>::BlockNumber>;
    type OwnerMineRecordItem<T>
        =
        PersonMineRecord<<T as timestamp::Trait>::Moment,
                         <T as system::Trait>::BlockNumber,
                         <T as balances::Trait>::Balance,
                         <T as system::Trait>::AccountId>;
    /// [`RawEvent`] specialized for the configuration [`Trait`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Trait`]: trait.Trait.html
    pub type Event<T>
        =
        RawEvent<<T as system::Trait>::AccountId, <T as system::Trait>::Hash>;
    /// Events for this module.
    ///
    pub enum RawEvent<AccountId, Hash> {
        Created(AccountId, Hash),
        Mined(AccountId, u64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::clone::Clone, Hash: ::core::clone::Clone>
     ::core::clone::Clone for RawEvent<AccountId, Hash> {
        #[inline]
        fn clone(&self) -> RawEvent<AccountId, Hash> {
            match (&*self,) {
                (&RawEvent::Created(ref __self_0, ref __self_1),) =>
                RawEvent::Created(::core::clone::Clone::clone(&(*__self_0)),
                                  ::core::clone::Clone::clone(&(*__self_1))),
                (&RawEvent::Mined(ref __self_0, ref __self_1),) =>
                RawEvent::Mined(::core::clone::Clone::clone(&(*__self_0)),
                                ::core::clone::Clone::clone(&(*__self_1))),
            }
        }
    }
    impl <AccountId, Hash> ::core::marker::StructuralPartialEq for
     RawEvent<AccountId, Hash> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::PartialEq, Hash: ::core::cmp::PartialEq>
     ::core::cmp::PartialEq for RawEvent<AccountId, Hash> {
        #[inline]
        fn eq(&self, other: &RawEvent<AccountId, Hash>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::Created(ref __self_0, ref __self_1),
                         &RawEvent::Created(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&RawEvent::Mined(ref __self_0, ref __self_1),
                         &RawEvent::Mined(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<AccountId, Hash>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::Created(ref __self_0, ref __self_1),
                         &RawEvent::Created(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&RawEvent::Mined(ref __self_0, ref __self_1),
                         &RawEvent::Mined(ref __arg_1_0, ref __arg_1_1)) =>
                        (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    impl <AccountId, Hash> ::core::marker::StructuralEq for
     RawEvent<AccountId, Hash> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::Eq, Hash: ::core::cmp::Eq> ::core::cmp::Eq
     for RawEvent<AccountId, Hash> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Hash>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, Hash> _parity_scale_codec::Encode for
             RawEvent<AccountId, Hash> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        RawEvent::Created(ref aa, ref ba) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        RawEvent::Mined(ref aa, ref ba) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        _ => (),
                    }
                }
            }
            impl <AccountId, Hash> _parity_scale_codec::EncodeLike for
             RawEvent<AccountId, Hash> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             Hash: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId, Hash> _parity_scale_codec::Decode for
             RawEvent<AccountId, Hash> where
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             Hash: _parity_scale_codec::Decode,
             Hash: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(RawEvent::Created({
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field RawEvent :: Created.0".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field RawEvent :: Created.1".into()),
                                                         Ok(a) => a,
                                                     }
                                                 }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(RawEvent::Mined({
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field RawEvent :: Mined.0".into()),
                                                       Ok(a) => a,
                                                   }
                                               },
                                               {
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field RawEvent :: Mined.1".into()),
                                                       Ok(a) => a,
                                                   }
                                               }))
                        }
                        x => Err("No such variant in enum RawEvent".into()),
                    }
                }
            }
        };
    impl <AccountId, Hash> core::fmt::Debug for RawEvent<AccountId, Hash>
     where AccountId: core::fmt::Debug, Hash: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::Created(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::Created").field(a0).field(a1).finish(),
                Self::Mined(ref a0, ref a1) =>
                fmt.debug_tuple("RawEvent::Mined").field(a0).field(a1).finish(),
                _ => Ok(()),
            }
        }
    }
    impl <AccountId, Hash> From<RawEvent<AccountId, Hash>> for () {
        fn from(_: RawEvent<AccountId, Hash>) -> () { () }
    }
    impl <AccountId, Hash> RawEvent<AccountId, Hash> {
        #[allow(dead_code)]
        pub fn metadata()
         -> &'static [::frame_support::event::EventMetadata] {
            &[::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("Created"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId",
                                                                                                          "Hash"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("Mined"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId",
                                                                                                          "u64"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),}]
        }
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{StorageValue
                                                                    as _,
                                                                    StorageMap
                                                                    as _,
                                                                    StorageLinkedMap
                                                                    as _,
                                                                    StorageDoubleMap
                                                                    as _};
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate support as hidden_include;
    }
    trait Store {
        type
        DayWorkForce;
        type
        AvgWorkForce;
        type
        OwnerMineRecord;
        type
        OwnedDayWorkForce;
        type
        OwnedMineIndex;
    }
    impl <T: Trait + 'static> Store for Module<T> {
        type
        DayWorkForce
        =
        DayWorkForce<>;
        type
        AvgWorkForce
        =
        AvgWorkForce<>;
        type
        OwnerMineRecord
        =
        OwnerMineRecord<T>;
        type
        OwnedDayWorkForce
        =
        OwnedDayWorkForce<T>;
        type
        OwnedMineIndex
        =
        OwnedMineIndex<T>;
    }
    impl <T: Trait + 'static> Module<T> {
        pub fn day_workforce<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<u64>>(key:
                                                                                                                       K)
         -> u64 {
            <DayWorkForce<> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<u64,
                                                                                               u64>>::get(key)
        }
        pub fn avg_workforce() -> u64 {
            <AvgWorkForce<> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageValue<u64>>::get()
        }
        pub fn mine_record<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<Vec<u8>>>(key:
                                                                                                                         K)
         -> Option<OwnerMineRecordItem<T>> {
            <OwnerMineRecord<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<Vec<u8>,
                                                                                               OwnerMineRecordItem<T>>>::get(key)
        }
        #[doc = " linked OwnerWorkForceItem,个人数据每天汇总"]
        pub fn person_workforce<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<(T::AccountId,
                                                                                                                 BlockNumberOf<T>)>>(key:
                                                                                                                                         K)
         -> Option<OwnerMineWorkForce<T>> {
            <OwnedDayWorkForce<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<(T::AccountId,
                                                                                                BlockNumberOf<T>),
                                                                                               OwnerMineWorkForce<T>>>::get(key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructDayWorkForce<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_DayWorkForce:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructDayWorkForce<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_DayWorkForce.get_or_init(||
                                                                 {
                                                                     let def_val:
                                                                             u64 =
                                                                         Default::default();
                                                                     <u64 as
                                                                         Encode>::encode(&def_val)
                                                                 }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructDayWorkForce<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructDayWorkForce<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructAvgWorkForce<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_AvgWorkForce:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructAvgWorkForce<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_AvgWorkForce.get_or_init(||
                                                                 {
                                                                     let def_val:
                                                                             u64 =
                                                                         Default::default();
                                                                     <u64 as
                                                                         Encode>::encode(&def_val)
                                                                 }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructAvgWorkForce<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructAvgWorkForce<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructOwnerMineRecord<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_OwnerMineRecord:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructOwnerMineRecord<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_OwnerMineRecord.get_or_init(||
                                                                    {
                                                                        let def_val:
                                                                                Option<OwnerMineRecordItem<T>> =
                                                                            Default::default();
                                                                        <Option<OwnerMineRecordItem<T>>
                                                                            as
                                                                            Encode>::encode(&def_val)
                                                                    }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructOwnerMineRecord<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructOwnerMineRecord<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructOwnedDayWorkForce<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_OwnedDayWorkForce:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructOwnedDayWorkForce<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_OwnedDayWorkForce.get_or_init(||
                                                                      {
                                                                          let def_val:
                                                                                  Option<OwnerMineWorkForce<T>> =
                                                                              Default::default();
                                                                          <Option<OwnerMineWorkForce<T>>
                                                                              as
                                                                              Encode>::encode(&def_val)
                                                                      }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructOwnedDayWorkForce<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructOwnedDayWorkForce<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructOwnedMineIndex<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_OwnedMineIndex:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructOwnedMineIndex<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_OwnedMineIndex.get_or_init(||
                                                                   {
                                                                       let def_val:
                                                                               u64 =
                                                                           Default::default();
                                                                       <u64 as
                                                                           Encode>::encode(&def_val)
                                                                   }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructOwnedMineIndex<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructOwnedMineIndex<T> { }
    impl <T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata()
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata {
            self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata{prefix:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("MineStorage"),
                                                                                                 entries:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("DayWorkForce"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("u64"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("u64"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructDayWorkForce::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("AvgWorkForce"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Plain(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("u64")),
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructAvgWorkForce::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnerMineRecord"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Optional,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<u8>"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnerMineRecordItem<T>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructOwnerMineRecord::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnedDayWorkForce"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Optional,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("(T::AccountId, BlockNumberOf<T>)"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnerMineWorkForce<T>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructOwnedDayWorkForce::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[" linked OwnerWorkForceItem,个人数据每天汇总"]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnedMineIndex"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("(T::AccountId, BlockNumberOf<T>)"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("u64"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructOwnedMineIndex::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[]),}][..]),}
        }
    }
    #[doc = r" Tag a type as an instance of a module."]
    #[doc = r""]
    #[doc = r" Defines storage prefixes, they must be unique."]
    #[doc(hidden)]
    pub trait __GeneratedInstantiable: 'static {
        #[doc = r" The prefix used by any storage entry of an instance."]
        const
        PREFIX:
        &'static str;
    }
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance =>
                match *self { __InherentHiddenInstance => true, },
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for __InherentHiddenInstance {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                }
            }
            impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance
             {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for __InherentHiddenInstance {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(__InherentHiddenInstance)
                }
            }
        };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl __GeneratedInstantiable for __InherentHiddenInstance {
        const
        PREFIX:
        &'static str
        =
        "MineStorage";
    }
    struct DayWorkForce(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<()>);
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<u64,
                                                                                                   u64>
     for DayWorkForce<> {
        type
        Query
        =
        u64;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "DayWorkForce".as_bytes() }
        fn from_optional_value_to_query(v: Option<u64>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<u64> {
            Some(v)
        }
    }
    struct AvgWorkForce(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<()>);
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<u64>
     for AvgWorkForce<> {
        type
        Query
        =
        u64;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "AvgWorkForce".as_bytes() }
        fn from_optional_value_to_query(v: Option<u64>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<u64> {
            Some(v)
        }
    }
    struct OwnerMineRecord<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<Vec<u8>,
                                                                                               OwnerMineRecordItem<T>>
     for OwnerMineRecord<T> {
        type
        Query
        =
        Option<OwnerMineRecordItem<T>>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "OwnerMineRecord".as_bytes() }
        fn from_optional_value_to_query(v: Option<OwnerMineRecordItem<T>>)
         -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<OwnerMineRecordItem<T>> {
            v
        }
    }
    #[doc = " linked OwnerWorkForceItem,个人数据每天汇总"]
    struct OwnedDayWorkForce<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<(T::AccountId,
                                                                                                BlockNumberOf<T>),
                                                                                               OwnerMineWorkForce<T>>
     for OwnedDayWorkForce<T> {
        type
        Query
        =
        Option<OwnerMineWorkForce<T>>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] {
            "OwnedDayWorkForce".as_bytes()
        }
        fn from_optional_value_to_query(v: Option<OwnerMineWorkForce<T>>)
         -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<OwnerMineWorkForce<T>> {
            v
        }
    }
    struct OwnedMineIndex<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<(T::AccountId,
                                                                                                BlockNumberOf<T>),
                                                                                               u64>
     for OwnedMineIndex<T> {
        type
        Query
        =
        u64;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "OwnedMineIndex".as_bytes() }
        fn from_optional_value_to_query(v: Option<u64>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<u64> {
            Some(v)
        }
    }
    pub struct Module<T: Trait>(::frame_support::rstd::marker::PhantomData<(T)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T>
     {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) =>
                Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T>
     {
    }
    impl <T: Trait> ::core::marker::StructuralPartialEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for
     Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl <T: Trait> ::core::marker::StructuralEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _:
                        ::core::cmp::AssertParamIsEq<::frame_support::rstd::marker::PhantomData<(T)>>;
            }
        }
    }
    impl <T: Trait> core::fmt::Debug for Module<T> where T: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnInitialize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnFinalize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> ::frame_support::dispatch::WeighBlock<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OffchainWorker<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> Module<T> {
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <system::Module<T>>::deposit_event(event.into())
        }
    }
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl <T: Trait> Module<T> {
        pub fn create_mine(origin: T::Origin, tx: Vec<u8>, address: Vec<u8>,
                           to_address: Vec<u8>, symbol: Vec<u8>, amount: u64,
                           protocol: Vec<u8>, decimal: u64, usdt_nums: u32,
                           blockchain: Vec<u8>, memo: Vec<u8>) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("create_mine",
                                                                                "node_runtime::mine",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/mine.rs"),
                                                                                Some(56u32),
                                                                                Some("node_runtime::mine"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let sender = ensure_signed(origin)?;
                {
                    if !<AllMiners<T>>::exists(sender.clone()) {
                        { return Err("account not register"); };
                    }
                };
                {
                    if !(T::Currency1::reserved_balance(&sender) >=
                             T::PledgeAmount::get()) {
                        {
                            return Err("your reservable currency is not enough");
                        };
                    }
                };
                {
                    if !!<OwnerMineRecord<T>>::exists(tx.clone()) {
                        { return Err("tx already exists"); };
                    }
                };
                {
                    if !(address != to_address) {
                        { return Err("you cannot transfer  to yourself"); };
                    }
                };
                {
                    if !(usdt_nums < u32::max_value()) {
                        { return Err("usdt_nums is overflow"); };
                    }
                };
                {
                    if !(usdt_nums > 5) {
                        { return Err("usdt_nums is too small"); };
                    }
                };
                let action = "transfer".as_bytes().to_vec();
                let mine_parm =
                    MineParm{action,
                             tx,
                             address,
                             to_address,
                             symbol,
                             amount,
                             protocol,
                             decimal,
                             usdt_nums,
                             blockchain,
                             memo,};
                Self::mining(mine_parm, sender)?;
                Ok(())
            }
        }
    }
    pub enum Call<T: Trait> {

        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(::frame_support::rstd::marker::PhantomData<(T)>,
                      ::frame_support::dispatch::Never),

        #[allow(non_camel_case_types)]
        create_mine(Vec<u8>, Vec<u8>, Vec<u8>, Vec<u8>, u64, Vec<u8>, u64,
                    u32, Vec<u8>, Vec<u8>),
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Encode for Call<T> {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        Call::create_mine(ref aa, ref ba, ref ca, ref da,
                                          ref ea, ref fa, ref ga, ref ha,
                                          ref ia, ref ja) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                            dest.push(ca);
                            dest.push(da);
                            dest.push(ea);
                            dest.push(fa);
                            dest.push(ga);
                            dest.push(ha);
                            dest.push(ia);
                            dest.push(ja);
                        }
                        _ => (),
                    }
                }
            }
            impl <T: Trait> _parity_scale_codec::EncodeLike for Call<T> { }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Decode for Call<T> {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(Call::create_mine({
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.0".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.1".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.2".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.3".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.4".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.5".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.6".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.7".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.8".into()),
                                                         Ok(a) => a,
                                                     }
                                                 },
                                                 {
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: create_mine.9".into()),
                                                         Ok(a) => a,
                                                     }
                                                 }))
                        }
                        x => Err("No such variant in enum Call".into()),
                    }
                }
            }
        };
    impl <T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self)
         -> ::frame_support::dispatch::DispatchInfo {
            if let Call::create_mine(ref tx, ref address, ref to_address,
                                     ref symbol, ref amount, ref protocol,
                                     ref decimal, ref usdt_nums,
                                     ref blockchain, ref memo) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,
                                                               &Vec<u8>,
                                                               &Vec<u8>,
                                                               &Vec<u8>, &u64,
                                                               &Vec<u8>, &u64,
                                                               &u32, &Vec<u8>,
                                                               &Vec<u8>)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                       (tx,
                                                                                        address,
                                                                                        to_address,
                                                                                        symbol,
                                                                                        amount,
                                                                                        protocol,
                                                                                        decimal,
                                                                                        usdt_nums,
                                                                                        blockchain,
                                                                                        memo));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,
                                                                      &Vec<u8>,
                                                                      &Vec<u8>,
                                                                      &Vec<u8>,
                                                                      &u64,
                                                                      &Vec<u8>,
                                                                      &u64,
                                                                      &u32,
                                                                      &Vec<u8>,
                                                                      &Vec<u8>)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                     (tx,
                                                                                                      address,
                                                                                                      to_address,
                                                                                                      symbol,
                                                                                                      amount,
                                                                                                      protocol,
                                                                                                      decimal,
                                                                                                      usdt_nums,
                                                                                                      blockchain,
                                                                                                      memo));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/mine.rs",
                                                         56u32, 1u32))
                        }
                    }
                }
            }
            let weight =
                <dyn ::frame_support::dispatch::WeighData<_>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                          ());
            let class =
                <dyn ::frame_support::dispatch::ClassifyDispatch<_>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                        ());
            let pays_fee =
                <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
            ::frame_support::dispatch::DispatchInfo{weight, class, pays_fee,}
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::create_mine(ref tx, ref address, ref to_address,
                                  ref symbol, ref amount, ref protocol,
                                  ref decimal, ref usdt_nums, ref blockchain,
                                  ref memo) =>
                Call::create_mine((*tx).clone(), (*address).clone(),
                                  (*to_address).clone(), (*symbol).clone(),
                                  (*amount).clone(), (*protocol).clone(),
                                  (*decimal).clone(), (*usdt_nums).clone(),
                                  (*blockchain).clone(), (*memo).clone()),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/mine.rs",
                                                 56u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::create_mine(ref tx, ref address, ref to_address,
                                  ref symbol, ref amount, ref protocol,
                                  ref decimal, ref usdt_nums, ref blockchain,
                                  ref memo) => {
                    let self_params =
                        (tx, address, to_address, symbol, amount, protocol,
                         decimal, usdt_nums, blockchain, memo);
                    if let Call::create_mine(ref tx, ref address,
                                             ref to_address, ref symbol,
                                             ref amount, ref protocol,
                                             ref decimal, ref usdt_nums,
                                             ref blockchain, ref memo) =
                           *_other {
                        self_params ==
                            (tx, address, to_address, symbol, amount,
                             protocol, decimal, usdt_nums, blockchain, memo)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/mine.rs",
                                                             56u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/mine.rs",
                                                 56u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Eq for Call<T> { }
    impl <T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(&self, _f: &mut ::frame_support::dispatch::fmt::Formatter)
         ->
             ::frame_support::dispatch::result::Result<(),
                                                       ::frame_support::dispatch::fmt::Error> {
            match *self {
                Call::create_mine(ref tx, ref address, ref to_address,
                                  ref symbol, ref amount, ref protocol,
                                  ref decimal, ref usdt_nums, ref blockchain,
                                  ref memo) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"create_mine",
                                                                    &(tx.clone(),
                                                                      address.clone(),
                                                                      to_address.clone(),
                                                                      symbol.clone(),
                                                                      amount.clone(),
                                                                      protocol.clone(),
                                                                      decimal.clone(),
                                                                      usdt_nums.clone(),
                                                                      blockchain.clone(),
                                                                      memo.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/mine.rs",
                                                 56u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Dispatchable for Call<T> {
        type
        Trait
        =
        T;
        type
        Origin
        =
        T::Origin;
        type
        Error
        =
        &'static str;
        fn dispatch(self, _origin: Self::Origin)
         -> ::frame_support::dispatch::DispatchResult<Self::Error> {
            match self {
                Call::create_mine(tx, address, to_address, symbol, amount,
                                  protocol, decimal, usdt_nums, blockchain,
                                  memo) => {
                    <Module<T>>::create_mine(_origin, tx, address, to_address,
                                             symbol, amount, protocol,
                                             decimal, usdt_nums, blockchain,
                                             memo)
                }
                Call::__PhantomItem(_, _) => {
                    {
                        {
                            {
                                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                           &match (&"__PhantomItem should never be used.",)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::core::fmt::Display::fmt)],
                                                                                            }),
                                                           &("bin/node/runtime/src/mine.rs",
                                                             56u32, 1u32))
                            }
                        }
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type
        Call
        =
        Call<T>;
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn dispatch<D: ::frame_support::dispatch::Dispatchable<Trait =
                        T>>(d: D, origin: D::Origin)
         -> ::frame_support::dispatch::DispatchResult<D::Error> {
            d.dispatch(origin)
        }
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn call_functions()
         -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("create_mine"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("tx"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("to_address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("symbol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("amount"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("u64"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("protocol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("decimal"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("u64"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("usdt_nums"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("u32"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("blockchain"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("memo"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[]),}]
        }
    }
    impl <T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        pub fn module_constants_metadata()
         -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl <T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for
     Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as
                ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl <T: Trait> Module<T> {
        fn mining(mine_parm: MineParm, sender: T::AccountId) -> Result {
            {
                if !<AllMiners<T>>::exists(sender.clone()) {
                    { return Err("account not register"); };
                }
            };
            let block_num = <system::Module<T>>::block_number();
            let day_block_nums = <BlockNumberOf<T>>::from(BLOCK_NUMS);
            let now_day = block_num / day_block_nums;
            let now_time = <timestamp::Module<T>>::get();
            let balance = <T::Balance>::from(12);
            let balance1 = <T::Balance>::from(12);
            let balance2 =
                balance.checked_add(&balance1).ok_or("balance overflow")?;

            #[cfg(feature = "std")]
            {
                {
                    ::std::io::_print(::core::fmt::Arguments::new_v1(&["-----------begin:",
                                                                       ",",
                                                                       ",now:",
                                                                       "------------\n"],
                                                                     &match (&now_time,
                                                                             &block_num,
                                                                             &now_day)
                                                                          {
                                                                          (arg0,
                                                                           arg1,
                                                                           arg2)
                                                                          =>
                                                                          [::core::fmt::ArgumentV1::new(arg0,
                                                                                                        ::core::fmt::Debug::fmt),
                                                                           ::core::fmt::ArgumentV1::new(arg1,
                                                                                                        ::core::fmt::Debug::fmt),
                                                                           ::core::fmt::ArgumentV1::new(arg2,
                                                                                                        ::core::fmt::Debug::fmt)],
                                                                      }));
                };
            }
            let owned_mineindex =
                <OwnedMineIndex<T>>::get(&(sender.clone(), now_day));
            if owned_mineindex > mining_maximum() {
                return Err("your mining frequency exceeds the maximum frequency");
            }
            let person_mine_record =
                PersonMineRecord::new(&mine_parm, sender.clone(), now_time,
                                      block_num, balance2)?;
            <OwnerMineRecord<T>>::insert(&mine_parm.tx, person_mine_record);
            <OwnerWorkForceItem<T>>::add(&sender, mine_parm.usdt_nums,
                                         now_day, block_num)?;
            let new_owned_mineindex =
                owned_mineindex.checked_add(1).ok_or("mining function add overflow")?;
            <OwnedMineIndex<T>>::insert(&(sender.clone(), now_day),
                                        new_owned_mineindex);

            #[cfg(feature = "std")]
            {
                {
                    ::std::io::_print(::core::fmt::Arguments::new_v1(&["-----------four:",
                                                                       "------------\n"],
                                                                     &match (&new_owned_mineindex,)
                                                                          {
                                                                          (arg0,)
                                                                          =>
                                                                          [::core::fmt::ArgumentV1::new(arg0,
                                                                                                        ::core::fmt::Debug::fmt)],
                                                                      }));
                };
            }
            Self::deposit_event(RawEvent::Mined(sender, new_owned_mineindex));
            Ok(())
        }
    }
    fn mining_maximum() -> u64 { return 10; }
}
mod mine_linked {
    use support::{decl_storage, decl_module, decl_event, Parameter,
                  StorageValue, StorageMap, dispatch::Result, ensure,
                  dispatch::Vec};
    use system::{ensure_signed};
    use sp_runtime::traits::{Hash, Member, SimpleArithmetic, Bounded,
                             MaybeDisplay, CheckedAdd};
    use codec::{Encode, Decode};
    use rstd::{result};
    const DAY_SECONDS: u32 = 86400;
    const BLOCK_TIME: u32 = 3;
    pub const BLOCK_NUMS: u32 = DAY_SECONDS / BLOCK_TIME;
    pub struct MineParm {
        pub action: Vec<u8>,
        pub tx: Vec<u8>,
        pub address: Vec<u8>,
        pub to_address: Vec<u8>,
        pub symbol: Vec<u8>,
        pub amount: u64,
        pub protocol: Vec<u8>,
        pub decimal: u64,
        pub usdt_nums: u32,
        pub blockchain: Vec<u8>,
        pub memo: Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MineParm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MineParm {
                action: ref __self_0_0,
                tx: ref __self_0_1,
                address: ref __self_0_2,
                to_address: ref __self_0_3,
                symbol: ref __self_0_4,
                amount: ref __self_0_5,
                protocol: ref __self_0_6,
                decimal: ref __self_0_7,
                usdt_nums: ref __self_0_8,
                blockchain: ref __self_0_9,
                memo: ref __self_0_10 } => {
                    let mut debug_trait_builder = f.debug_struct("MineParm");
                    let _ =
                        debug_trait_builder.field("action", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("tx", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("address", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("to_address",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("symbol", &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("amount", &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("protocol",
                                                  &&(*__self_0_6));
                    let _ =
                        debug_trait_builder.field("decimal", &&(*__self_0_7));
                    let _ =
                        debug_trait_builder.field("usdt_nums",
                                                  &&(*__self_0_8));
                    let _ =
                        debug_trait_builder.field("blockchain",
                                                  &&(*__self_0_9));
                    let _ =
                        debug_trait_builder.field("memo", &&(*__self_0_10));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for MineParm { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MineParm {
        #[inline]
        fn eq(&self, other: &MineParm) -> bool {
            match *other {
                MineParm {
                action: ref __self_1_0,
                tx: ref __self_1_1,
                address: ref __self_1_2,
                to_address: ref __self_1_3,
                symbol: ref __self_1_4,
                amount: ref __self_1_5,
                protocol: ref __self_1_6,
                decimal: ref __self_1_7,
                usdt_nums: ref __self_1_8,
                blockchain: ref __self_1_9,
                memo: ref __self_1_10 } =>
                match *self {
                    MineParm {
                    action: ref __self_0_0,
                    tx: ref __self_0_1,
                    address: ref __self_0_2,
                    to_address: ref __self_0_3,
                    symbol: ref __self_0_4,
                    amount: ref __self_0_5,
                    protocol: ref __self_0_6,
                    decimal: ref __self_0_7,
                    usdt_nums: ref __self_0_8,
                    blockchain: ref __self_0_9,
                    memo: ref __self_0_10 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6) &&
                        (*__self_0_7) == (*__self_1_7) &&
                        (*__self_0_8) == (*__self_1_8) &&
                        (*__self_0_9) == (*__self_1_9) &&
                        (*__self_0_10) == (*__self_1_10),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MineParm) -> bool {
            match *other {
                MineParm {
                action: ref __self_1_0,
                tx: ref __self_1_1,
                address: ref __self_1_2,
                to_address: ref __self_1_3,
                symbol: ref __self_1_4,
                amount: ref __self_1_5,
                protocol: ref __self_1_6,
                decimal: ref __self_1_7,
                usdt_nums: ref __self_1_8,
                blockchain: ref __self_1_9,
                memo: ref __self_1_10 } =>
                match *self {
                    MineParm {
                    action: ref __self_0_0,
                    tx: ref __self_0_1,
                    address: ref __self_0_2,
                    to_address: ref __self_0_3,
                    symbol: ref __self_0_4,
                    amount: ref __self_0_5,
                    protocol: ref __self_0_6,
                    decimal: ref __self_0_7,
                    usdt_nums: ref __self_0_8,
                    blockchain: ref __self_0_9,
                    memo: ref __self_0_10 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6) ||
                        (*__self_0_7) != (*__self_1_7) ||
                        (*__self_0_8) != (*__self_1_8) ||
                        (*__self_0_9) != (*__self_1_9) ||
                        (*__self_0_10) != (*__self_1_10),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for MineParm { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for MineParm {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for MineParm {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.action);
                    dest.push(&self.tx);
                    dest.push(&self.address);
                    dest.push(&self.to_address);
                    dest.push(&self.symbol);
                    dest.push(&self.amount);
                    dest.push(&self.protocol);
                    dest.push(&self.decimal);
                    dest.push(&self.usdt_nums);
                    dest.push(&self.blockchain);
                    dest.push(&self.memo);
                }
            }
            impl _parity_scale_codec::EncodeLike for MineParm { }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for MineParm {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(MineParm{action:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.action".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                tx:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.tx".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                address:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.address".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                to_address:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.to_address".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                symbol:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.symbol".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                amount:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.amount".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                protocol:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.protocol".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                decimal:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.decimal".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                usdt_nums:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.usdt_nums".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                blockchain:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.blockchain".into()),
                                            Ok(a) => a,
                                        }
                                    },
                                memo:
                                    {
                                        let res =
                                            _parity_scale_codec::Decode::decode(input);
                                        match res {
                                            Err(_) =>
                                            return Err("Error decoding field MineParm.memo".into()),
                                            Ok(a) => a,
                                        }
                                    },})
                }
            }
        };
    pub struct PersonMineWorkForce<BlockNumber> {
        mine_cnt: u64,
        usdt_nums: u32,
        work_force: u64,
        settle_blocknumber: BlockNumber,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <BlockNumber: ::core::fmt::Debug> ::core::fmt::Debug for
     PersonMineWorkForce<BlockNumber> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                PersonMineWorkForce {
                mine_cnt: ref __self_0_0,
                usdt_nums: ref __self_0_1,
                work_force: ref __self_0_2,
                settle_blocknumber: ref __self_0_3 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("PersonMineWorkForce");
                    let _ =
                        debug_trait_builder.field("mine_cnt",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("usdt_nums",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("work_force",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("settle_blocknumber",
                                                  &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl <BlockNumber> ::core::marker::StructuralPartialEq for
     PersonMineWorkForce<BlockNumber> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <BlockNumber: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
     PersonMineWorkForce<BlockNumber> {
        #[inline]
        fn eq(&self, other: &PersonMineWorkForce<BlockNumber>) -> bool {
            match *other {
                PersonMineWorkForce {
                mine_cnt: ref __self_1_0,
                usdt_nums: ref __self_1_1,
                work_force: ref __self_1_2,
                settle_blocknumber: ref __self_1_3 } =>
                match *self {
                    PersonMineWorkForce {
                    mine_cnt: ref __self_0_0,
                    usdt_nums: ref __self_0_1,
                    work_force: ref __self_0_2,
                    settle_blocknumber: ref __self_0_3 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &PersonMineWorkForce<BlockNumber>) -> bool {
            match *other {
                PersonMineWorkForce {
                mine_cnt: ref __self_1_0,
                usdt_nums: ref __self_1_1,
                work_force: ref __self_1_2,
                settle_blocknumber: ref __self_1_3 } =>
                match *self {
                    PersonMineWorkForce {
                    mine_cnt: ref __self_0_0,
                    usdt_nums: ref __self_0_1,
                    work_force: ref __self_0_2,
                    settle_blocknumber: ref __self_0_3 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3),
                },
            }
        }
    }
    impl <BlockNumber> ::core::marker::StructuralEq for
     PersonMineWorkForce<BlockNumber> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <BlockNumber: ::core::cmp::Eq> ::core::cmp::Eq for
     PersonMineWorkForce<BlockNumber> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<BlockNumber>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <BlockNumber> _parity_scale_codec::Encode for
             PersonMineWorkForce<BlockNumber> where
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.mine_cnt);
                    dest.push(&self.usdt_nums);
                    dest.push(&self.work_force);
                    dest.push(&self.settle_blocknumber);
                }
            }
            impl <BlockNumber> _parity_scale_codec::EncodeLike for
             PersonMineWorkForce<BlockNumber> where
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <BlockNumber> _parity_scale_codec::Decode for
             PersonMineWorkForce<BlockNumber> where
             BlockNumber: _parity_scale_codec::Decode,
             BlockNumber: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(PersonMineWorkForce{mine_cnt:
                                               {
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field PersonMineWorkForce.mine_cnt".into()),
                                                       Ok(a) => a,
                                                   }
                                               },
                                           usdt_nums:
                                               {
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field PersonMineWorkForce.usdt_nums".into()),
                                                       Ok(a) => a,
                                                   }
                                               },
                                           work_force:
                                               {
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field PersonMineWorkForce.work_force".into()),
                                                       Ok(a) => a,
                                                   }
                                               },
                                           settle_blocknumber:
                                               {
                                                   let res =
                                                       _parity_scale_codec::Decode::decode(input);
                                                   match res {
                                                       Err(_) =>
                                                       return Err("Error decoding field PersonMineWorkForce.settle_blocknumber".into()),
                                                       Ok(a) => a,
                                                   }
                                               },})
                }
            }
        };
    pub struct PersonMine<Storage, Key,
                          BlockNumber>(rstd::marker::PhantomData<(Storage,
                                                                  Key,
                                                                  BlockNumber)>);
    impl <Storage, Key, BlockNumber> PersonMine<Storage, Key, BlockNumber>
     where Key: Parameter, BlockNumber: Parameter + Member + MaybeDisplay +
     SimpleArithmetic + Default + Bounded + Copy,
     Storage: StorageMap<(Key, BlockNumber), PersonMineWorkForce<BlockNumber>,
     Query = Option<PersonMineWorkForce<BlockNumber>>> {
        fn write(key: &Key, day: BlockNumber,
                 personmine_work_force: PersonMineWorkForce<BlockNumber>) {
            Storage::insert(&(key.clone(), day), personmine_work_force);
        }
        fn read(key: &Key, day_num: BlockNumber)
         -> PersonMineWorkForce<BlockNumber> {
            let zero_block = BlockNumber::from(0 as u32);
            Storage::get(&(key.clone(),
                           day_num)).unwrap_or_else(||
                                                        PersonMineWorkForce{mine_cnt:
                                                                                0,
                                                                            usdt_nums:
                                                                                0,
                                                                            work_force:
                                                                                0,
                                                                            settle_blocknumber:
                                                                                zero_block,})
        }
        fn calculate_workforce() -> u64 { 10 }
        pub fn add(key: &Key, usdt_nums: u32, now_day: BlockNumber,
                   block_num: BlockNumber) -> Result {
            let mut personmine_work_force = Self::read(key, now_day);
            let block_nums = BlockNumber::from(BLOCK_NUMS);
            let last_day =
                personmine_work_force.settle_blocknumber.checked_div(&block_nums).ok_or("add function: div causes error of last_day")?;
            let now_day =
                block_num.checked_div(&block_nums).ok_or("user add function: div causes error of now_day")?;
            let now_workforce = Self::calculate_workforce();
            personmine_work_force.settle_blocknumber = block_num;
            if last_day == now_day {
                personmine_work_force.mine_cnt =
                    personmine_work_force.mine_cnt.checked_add(1).ok_or("add function: add causes overflow of mine_cnt")?;
                personmine_work_force.usdt_nums =
                    personmine_work_force.usdt_nums.checked_add(usdt_nums).ok_or("add function: add causes overflow of usdt_nums")?;
                personmine_work_force.work_force =
                    personmine_work_force.work_force.checked_add(now_workforce).ok_or("add function: add causes overflow of work_force")?;
            } else {
                personmine_work_force.mine_cnt = 1;
                personmine_work_force.usdt_nums = usdt_nums;
                personmine_work_force.work_force = now_workforce;
            }
            Self::write(key, now_day, personmine_work_force);
            Ok(())
        }
    }
    pub struct PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
        timestamp: Moment,
        blocknum: BlockNumber,
        miner_address: AccountId,
        from_address: Vec<u8>,
        to_address: Vec<u8>,
        symbol: Vec<u8>,
        amount: Balance,
        blockchain: Vec<u8>,
        tx: Vec<u8>,
        usdt_amount: u32,
        pcount_workforce: u64,
        pamount_workforce: u64,
        reward: Balance,
        superior_reward: Balance,
        on_reward: Balance,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Moment: ::core::fmt::Debug, BlockNumber: ::core::fmt::Debug,
          Balance: ::core::fmt::Debug, AccountId: ::core::fmt::Debug>
     ::core::fmt::Debug for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                PersonMineRecord {
                timestamp: ref __self_0_0,
                blocknum: ref __self_0_1,
                miner_address: ref __self_0_2,
                from_address: ref __self_0_3,
                to_address: ref __self_0_4,
                symbol: ref __self_0_5,
                amount: ref __self_0_6,
                blockchain: ref __self_0_7,
                tx: ref __self_0_8,
                usdt_amount: ref __self_0_9,
                pcount_workforce: ref __self_0_10,
                pamount_workforce: ref __self_0_11,
                reward: ref __self_0_12,
                superior_reward: ref __self_0_13,
                on_reward: ref __self_0_14 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("PersonMineRecord");
                    let _ =
                        debug_trait_builder.field("timestamp",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("blocknum",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("miner_address",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("from_address",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("to_address",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("symbol", &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("amount", &&(*__self_0_6));
                    let _ =
                        debug_trait_builder.field("blockchain",
                                                  &&(*__self_0_7));
                    let _ = debug_trait_builder.field("tx", &&(*__self_0_8));
                    let _ =
                        debug_trait_builder.field("usdt_amount",
                                                  &&(*__self_0_9));
                    let _ =
                        debug_trait_builder.field("pcount_workforce",
                                                  &&(*__self_0_10));
                    let _ =
                        debug_trait_builder.field("pamount_workforce",
                                                  &&(*__self_0_11));
                    let _ =
                        debug_trait_builder.field("reward", &&(*__self_0_12));
                    let _ =
                        debug_trait_builder.field("superior_reward",
                                                  &&(*__self_0_13));
                    let _ =
                        debug_trait_builder.field("on_reward",
                                                  &&(*__self_0_14));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl <Moment, BlockNumber, Balance, AccountId>
     ::core::marker::StructuralPartialEq for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Moment: ::core::cmp::PartialEq, BlockNumber: ::core::cmp::PartialEq,
          Balance: ::core::cmp::PartialEq, AccountId: ::core::cmp::PartialEq>
     ::core::cmp::PartialEq for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
        #[inline]
        fn eq(&self,
              other:
                  &PersonMineRecord<Moment, BlockNumber, Balance, AccountId>)
         -> bool {
            match *other {
                PersonMineRecord {
                timestamp: ref __self_1_0,
                blocknum: ref __self_1_1,
                miner_address: ref __self_1_2,
                from_address: ref __self_1_3,
                to_address: ref __self_1_4,
                symbol: ref __self_1_5,
                amount: ref __self_1_6,
                blockchain: ref __self_1_7,
                tx: ref __self_1_8,
                usdt_amount: ref __self_1_9,
                pcount_workforce: ref __self_1_10,
                pamount_workforce: ref __self_1_11,
                reward: ref __self_1_12,
                superior_reward: ref __self_1_13,
                on_reward: ref __self_1_14 } =>
                match *self {
                    PersonMineRecord {
                    timestamp: ref __self_0_0,
                    blocknum: ref __self_0_1,
                    miner_address: ref __self_0_2,
                    from_address: ref __self_0_3,
                    to_address: ref __self_0_4,
                    symbol: ref __self_0_5,
                    amount: ref __self_0_6,
                    blockchain: ref __self_0_7,
                    tx: ref __self_0_8,
                    usdt_amount: ref __self_0_9,
                    pcount_workforce: ref __self_0_10,
                    pamount_workforce: ref __self_0_11,
                    reward: ref __self_0_12,
                    superior_reward: ref __self_0_13,
                    on_reward: ref __self_0_14 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6) &&
                        (*__self_0_7) == (*__self_1_7) &&
                        (*__self_0_8) == (*__self_1_8) &&
                        (*__self_0_9) == (*__self_1_9) &&
                        (*__self_0_10) == (*__self_1_10) &&
                        (*__self_0_11) == (*__self_1_11) &&
                        (*__self_0_12) == (*__self_1_12) &&
                        (*__self_0_13) == (*__self_1_13) &&
                        (*__self_0_14) == (*__self_1_14),
                },
            }
        }
        #[inline]
        fn ne(&self,
              other:
                  &PersonMineRecord<Moment, BlockNumber, Balance, AccountId>)
         -> bool {
            match *other {
                PersonMineRecord {
                timestamp: ref __self_1_0,
                blocknum: ref __self_1_1,
                miner_address: ref __self_1_2,
                from_address: ref __self_1_3,
                to_address: ref __self_1_4,
                symbol: ref __self_1_5,
                amount: ref __self_1_6,
                blockchain: ref __self_1_7,
                tx: ref __self_1_8,
                usdt_amount: ref __self_1_9,
                pcount_workforce: ref __self_1_10,
                pamount_workforce: ref __self_1_11,
                reward: ref __self_1_12,
                superior_reward: ref __self_1_13,
                on_reward: ref __self_1_14 } =>
                match *self {
                    PersonMineRecord {
                    timestamp: ref __self_0_0,
                    blocknum: ref __self_0_1,
                    miner_address: ref __self_0_2,
                    from_address: ref __self_0_3,
                    to_address: ref __self_0_4,
                    symbol: ref __self_0_5,
                    amount: ref __self_0_6,
                    blockchain: ref __self_0_7,
                    tx: ref __self_0_8,
                    usdt_amount: ref __self_0_9,
                    pcount_workforce: ref __self_0_10,
                    pamount_workforce: ref __self_0_11,
                    reward: ref __self_0_12,
                    superior_reward: ref __self_0_13,
                    on_reward: ref __self_0_14 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6) ||
                        (*__self_0_7) != (*__self_1_7) ||
                        (*__self_0_8) != (*__self_1_8) ||
                        (*__self_0_9) != (*__self_1_9) ||
                        (*__self_0_10) != (*__self_1_10) ||
                        (*__self_0_11) != (*__self_1_11) ||
                        (*__self_0_12) != (*__self_1_12) ||
                        (*__self_0_13) != (*__self_1_13) ||
                        (*__self_0_14) != (*__self_1_14),
                },
            }
        }
    }
    impl <Moment, BlockNumber, Balance, AccountId>
     ::core::marker::StructuralEq for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Moment: ::core::cmp::Eq, BlockNumber: ::core::cmp::Eq,
          Balance: ::core::cmp::Eq, AccountId: ::core::cmp::Eq>
     ::core::cmp::Eq for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Moment>;
                let _: ::core::cmp::AssertParamIsEq<BlockNumber>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Balance>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<Balance>;
                let _: ::core::cmp::AssertParamIsEq<Balance>;
                let _: ::core::cmp::AssertParamIsEq<Balance>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <Moment, BlockNumber, Balance, AccountId>
             _parity_scale_codec::Encode for
             PersonMineRecord<Moment, BlockNumber, Balance, AccountId> where
             Moment: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.timestamp);
                    dest.push(&self.blocknum);
                    dest.push(&self.miner_address);
                    dest.push(&self.from_address);
                    dest.push(&self.to_address);
                    dest.push(&self.symbol);
                    dest.push(&self.amount);
                    dest.push(&self.blockchain);
                    dest.push(&self.tx);
                    dest.push(&self.usdt_amount);
                    dest.push(&self.pcount_workforce);
                    dest.push(&self.pamount_workforce);
                    dest.push(&self.reward);
                    dest.push(&self.superior_reward);
                    dest.push(&self.on_reward);
                }
            }
            impl <Moment, BlockNumber, Balance, AccountId>
             _parity_scale_codec::EncodeLike for
             PersonMineRecord<Moment, BlockNumber, Balance, AccountId> where
             Moment: _parity_scale_codec::Encode,
             Moment: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             BlockNumber: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode,
             Balance: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <Moment, BlockNumber, Balance, AccountId>
             _parity_scale_codec::Decode for
             PersonMineRecord<Moment, BlockNumber, Balance, AccountId> where
             Moment: _parity_scale_codec::Decode,
             Moment: _parity_scale_codec::Decode,
             BlockNumber: _parity_scale_codec::Decode,
             BlockNumber: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode,
             Balance: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(PersonMineRecord{timestamp:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.timestamp".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        blocknum:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.blocknum".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        miner_address:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.miner_address".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        from_address:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.from_address".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        to_address:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.to_address".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        symbol:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.symbol".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        amount:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.amount".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        blockchain:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.blockchain".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        tx:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.tx".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        usdt_amount:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.usdt_amount".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        pcount_workforce:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.pcount_workforce".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        pamount_workforce:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.pamount_workforce".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        reward:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.reward".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        superior_reward:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.superior_reward".into()),
                                                    Ok(a) => a,
                                                }
                                            },
                                        on_reward:
                                            {
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field PersonMineRecord.on_reward".into()),
                                                    Ok(a) => a,
                                                }
                                            },})
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Moment: ::core::clone::Clone, BlockNumber: ::core::clone::Clone,
          Balance: ::core::clone::Clone, AccountId: ::core::clone::Clone>
     ::core::clone::Clone for
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
        #[inline]
        fn clone(&self)
         -> PersonMineRecord<Moment, BlockNumber, Balance, AccountId> {
            match *self {
                PersonMineRecord {
                timestamp: ref __self_0_0,
                blocknum: ref __self_0_1,
                miner_address: ref __self_0_2,
                from_address: ref __self_0_3,
                to_address: ref __self_0_4,
                symbol: ref __self_0_5,
                amount: ref __self_0_6,
                blockchain: ref __self_0_7,
                tx: ref __self_0_8,
                usdt_amount: ref __self_0_9,
                pcount_workforce: ref __self_0_10,
                pamount_workforce: ref __self_0_11,
                reward: ref __self_0_12,
                superior_reward: ref __self_0_13,
                on_reward: ref __self_0_14 } =>
                PersonMineRecord{timestamp:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 blocknum:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 miner_address:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),
                                 from_address:
                                     ::core::clone::Clone::clone(&(*__self_0_3)),
                                 to_address:
                                     ::core::clone::Clone::clone(&(*__self_0_4)),
                                 symbol:
                                     ::core::clone::Clone::clone(&(*__self_0_5)),
                                 amount:
                                     ::core::clone::Clone::clone(&(*__self_0_6)),
                                 blockchain:
                                     ::core::clone::Clone::clone(&(*__self_0_7)),
                                 tx:
                                     ::core::clone::Clone::clone(&(*__self_0_8)),
                                 usdt_amount:
                                     ::core::clone::Clone::clone(&(*__self_0_9)),
                                 pcount_workforce:
                                     ::core::clone::Clone::clone(&(*__self_0_10)),
                                 pamount_workforce:
                                     ::core::clone::Clone::clone(&(*__self_0_11)),
                                 reward:
                                     ::core::clone::Clone::clone(&(*__self_0_12)),
                                 superior_reward:
                                     ::core::clone::Clone::clone(&(*__self_0_13)),
                                 on_reward:
                                     ::core::clone::Clone::clone(&(*__self_0_14)),},
            }
        }
    }
    impl <Moment, BlockNumber, Balance, AccountId>
     PersonMineRecord<Moment, BlockNumber, Balance, AccountId> where
     Balance: Copy {
        pub fn new(mine_parm: &MineParm, sender: AccountId, moment: Moment,
                   block_number: BlockNumber, balances: Balance)
         ->
             result::Result<PersonMineRecord<Moment, BlockNumber, Balance,
                                             AccountId>, &'static str> {
            if mine_parm.amount > u64::max_value() {
                return Err("overflow f64");
            }
            let s = [1, 2].to_vec();
            let res =
                PersonMineRecord{timestamp: moment,
                                 blocknum: block_number,
                                 miner_address: sender,
                                 from_address: mine_parm.address.clone(),
                                 to_address: mine_parm.to_address.clone(),
                                 symbol: s.clone(),
                                 amount: balances,
                                 blockchain: s.clone(),
                                 tx: mine_parm.tx.clone(),
                                 usdt_amount: mine_parm.usdt_nums,
                                 pcount_workforce: 1,
                                 pamount_workforce: 1,
                                 reward: balances,
                                 superior_reward: balances,
                                 on_reward: balances,};
            Ok(res)
        }
        pub fn record() { }
    }
}
use impls::{CurrencyToVoteHandler, Author, LinearWeightToFee,
            TargetedFeeAdjustment};
/// Constant values used within the runtime.
pub mod constants {
    //! A set of constant values used in substrate runtime.
    /// Money matters.
    pub mod currency {
        use node_primitives::Balance;
        pub const MILLICENTS: Balance = 1_000_000_000;
        pub const CENTS: Balance = 1_000 * MILLICENTS;
        pub const DOLLARS: Balance = 100 * CENTS;
    }
    /// Time.
    pub mod time {
        use node_primitives::{Moment, BlockNumber};
        /// Since BABE is probabilistic this is the average expected block time that
        /// we are targetting. Blocks will be produced at a minimum duration defined
        /// by `SLOT_DURATION`, but some slots will not be allocated to any
        /// authority and hence no block will be produced. We expect to have this
        /// block time on average following the defined slot duration and the value
        /// of `c` configured for BABE (where `1 - c` represents the probability of
        /// a slot being empty).
        /// This value is only used indirectly to define the unit constants below
        /// that are expressed in blocks. The rest of the code should use
        /// `SLOT_DURATION` instead (like the timestamp module for calculating the
        /// minimum period).
        ///
        /// If using BABE with secondary slots (default) then all of the slots will
        /// always be assigned, in which case `MILLISECS_PER_BLOCK` and
        /// `SLOT_DURATION` should have the same value.
        ///
        /// <https://research.web3.foundation/en/latest/polkadot/BABE/Babe/#6-practical-results>
        pub const MILLISECS_PER_BLOCK: Moment = 3000;
        pub const SECS_PER_BLOCK: Moment = MILLISECS_PER_BLOCK / 1000;
        pub const SLOT_DURATION: Moment = MILLISECS_PER_BLOCK;
        pub const PRIMARY_PROBABILITY: (u64, u64) = (1, 4);
        pub const EPOCH_DURATION_IN_BLOCKS: BlockNumber = 10 * MINUTES;
        pub const EPOCH_DURATION_IN_SLOTS: u64 =
            {
                const SLOT_FILL_RATE: f64 =
                    MILLISECS_PER_BLOCK as f64 / SLOT_DURATION as f64;
                (EPOCH_DURATION_IN_BLOCKS as f64 * SLOT_FILL_RATE) as u64
            };
        pub const MINUTES: BlockNumber = 60 / (SECS_PER_BLOCK as BlockNumber);
        pub const HOURS: BlockNumber = MINUTES * 60;
        pub const DAYS: BlockNumber = HOURS * 24;
    }
}
use constants::{time::*, currency::*};
/// Transx function used within the runtime.
pub mod transx {
    use rstd::prelude::*;
    use rstd::{cmp, result, mem, fmt::Debug};
    use codec::{Codec, Encode, Decode, Input, Output};
    use support::{decl_module, decl_storage, decl_event, dispatch::Result};
    use support::traits::{Currency, ReservableCurrency, OnUnbalanced, Get};
    use node_primitives::{AccountId, AccountIndex, Balance, BlockNumber, Hash,
                          Index, Moment, Signature, Count, USD, Workforce};
    use system::ensure_signed;
    use sp_runtime::Permill;
    use sp_runtime::RuntimeDebug;
    use sp_runtime::traits::StaticLookup;
    type BalanceOf<T>
        =
        <<T as Trait>::Currency as
        Currency<<T as system::Trait>::AccountId>>::Balance;
    /// The module's configuration trait.
    pub trait Trait: system::Trait {
        type
        Event: From<Event<Self>> +
        Into<<Self as system::Trait>::Event>;
        /// The currency trait.
        type
        Currency: Currency<Self::AccountId>;
        type
        BTCLimitCount: Get<Count>;
        type
        ETHLimitCount: Get<Count>;
        type
        EOSLimitCount: Get<Count>;
        type
        USDTLimitCount: Get<Count>;
        type
        DCEPLimitCount: Get<Count>;
        type
        DOTLimitCount: Get<Count>;
        type
        DashLimitCount: Get<Count>;
        type
        ADALimitCount: Get<Count>;
        type
        DCAPLimitCount: Get<Count>;
        type
        TUSDTLimitCount: Get<Count>;
        type
        BTCMaxPortion: Get<Permill>;
        type
        ETHMaxPortion: Get<Permill>;
        type
        EOSMaxPortion: Get<Permill>;
        type
        USDTMaxPortion: Get<Permill>;
        type
        DCEPaxPortion: Get<Permill>;
        type
        DOTMaxPortion: Get<Permill>;
        type
        DashMaxPortion: Get<Permill>;
        type
        ADAMaxPortion: Get<Permill>;
        type
        DCAPMaxPortion: Get<Permill>;
        type
        TUSDTMaxPortion: Get<Permill>;
        type
        BTCLimitAmount: Get<USD>;
        type
        ETHLimitAmount: Get<USD>;
        type
        EOSLimitAmount: Get<USD>;
        type
        USDTLimitAmount: Get<USD>;
        type
        DCEPLimitAmount: Get<USD>;
        type
        DOTLimitAmount: Get<USD>;
        type
        DashLimitAmount: Get<USD>;
        type
        ADALimitAmount: Get<USD>;
        type
        DCAPLimitAmount: Get<USD>;
        type
        TUSDTLimitAmount: Get<USD>;
        type
        BTCMaxLimitAmount: Get<USD>;
        type
        ETHMaxLimitAmount: Get<USD>;
        type
        EOSMaxLimitAmount: Get<USD>;
        type
        USDTMaxLimitAmount: Get<USD>;
        type
        DCEPMaxLimitAmount: Get<USD>;
        type
        DOTMaxLimitAmount: Get<USD>;
        type
        DashMaxLimitAmount: Get<USD>;
        type
        ADAMaxLimitAmount: Get<USD>;
        type
        DCAPMaxLimitAmount: Get<USD>;
        type
        TUSDTMaxLimitAmount: Get<USD>;
        type
        InitialTotalCount: Get<Count>;
        type
        InitialTotalAmount: Get<USD>;
        type
        InitialTotalWorkforce: Get<Permill>;
        type
        FrequencyWorkforceProportion: Get<Permill>;
        type
        AmountWorkforceProportion: Get<Permill>;
        type
        SenderWorkforceProportion: Get<Permill>;
        type
        ReceiverWorkforceProportion: Get<Permill>;
        type
        SuperiorShareRatio: Get<Permill>;
        type
        OnsuperiorShareRatio: Get<Permill>;
        type
        DailyMinimumReward: Get<BalanceOf<Self>>;
        type
        MinerSharefeeRatio: Get<Permill>;
        type
        PledgeAmount: Get<BalanceOf<Self>>;
        type
        SettlePeriodBlock: Get<BlockNumber>;
        type
        FoundingTeamProportion: Get<Permill>;
    }
    pub struct MinerInfo<AccountId> {
        pub accountid: AccountId,
        pub mac: Vec<u8>,
        pub superior_address: AccountId,
        pub onsuperior_address: AccountId,
        pub register_time: Moment,
        pub status: Vec<u8>,
        pub miner: Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::fmt::Debug> ::core::fmt::Debug for
     MinerInfo<AccountId> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MinerInfo {
                accountid: ref __self_0_0,
                mac: ref __self_0_1,
                superior_address: ref __self_0_2,
                onsuperior_address: ref __self_0_3,
                register_time: ref __self_0_4,
                status: ref __self_0_5,
                miner: ref __self_0_6 } => {
                    let mut debug_trait_builder = f.debug_struct("MinerInfo");
                    let _ =
                        debug_trait_builder.field("accountid",
                                                  &&(*__self_0_0));
                    let _ = debug_trait_builder.field("mac", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("superior_address",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("onsuperior_address",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("register_time",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("status", &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("miner", &&(*__self_0_6));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl <AccountId> ::core::marker::StructuralPartialEq for
     MinerInfo<AccountId> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
     MinerInfo<AccountId> {
        #[inline]
        fn eq(&self, other: &MinerInfo<AccountId>) -> bool {
            match *other {
                MinerInfo {
                accountid: ref __self_1_0,
                mac: ref __self_1_1,
                superior_address: ref __self_1_2,
                onsuperior_address: ref __self_1_3,
                register_time: ref __self_1_4,
                status: ref __self_1_5,
                miner: ref __self_1_6 } =>
                match *self {
                    MinerInfo {
                    accountid: ref __self_0_0,
                    mac: ref __self_0_1,
                    superior_address: ref __self_0_2,
                    onsuperior_address: ref __self_0_3,
                    register_time: ref __self_0_4,
                    status: ref __self_0_5,
                    miner: ref __self_0_6 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MinerInfo<AccountId>) -> bool {
            match *other {
                MinerInfo {
                accountid: ref __self_1_0,
                mac: ref __self_1_1,
                superior_address: ref __self_1_2,
                onsuperior_address: ref __self_1_3,
                register_time: ref __self_1_4,
                status: ref __self_1_5,
                miner: ref __self_1_6 } =>
                match *self {
                    MinerInfo {
                    accountid: ref __self_0_0,
                    mac: ref __self_0_1,
                    superior_address: ref __self_0_2,
                    onsuperior_address: ref __self_0_3,
                    register_time: ref __self_0_4,
                    status: ref __self_0_5,
                    miner: ref __self_0_6 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6),
                },
            }
        }
    }
    impl <AccountId> ::core::marker::StructuralEq for MinerInfo<AccountId> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::Eq> ::core::cmp::Eq for MinerInfo<AccountId>
     {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<Moment>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::clone::Clone> ::core::clone::Clone for
     MinerInfo<AccountId> {
        #[inline]
        fn clone(&self) -> MinerInfo<AccountId> {
            match *self {
                MinerInfo {
                accountid: ref __self_0_0,
                mac: ref __self_0_1,
                superior_address: ref __self_0_2,
                onsuperior_address: ref __self_0_3,
                register_time: ref __self_0_4,
                status: ref __self_0_5,
                miner: ref __self_0_6 } =>
                MinerInfo{accountid:
                              ::core::clone::Clone::clone(&(*__self_0_0)),
                          mac: ::core::clone::Clone::clone(&(*__self_0_1)),
                          superior_address:
                              ::core::clone::Clone::clone(&(*__self_0_2)),
                          onsuperior_address:
                              ::core::clone::Clone::clone(&(*__self_0_3)),
                          register_time:
                              ::core::clone::Clone::clone(&(*__self_0_4)),
                          status: ::core::clone::Clone::clone(&(*__self_0_5)),
                          miner:
                              ::core::clone::Clone::clone(&(*__self_0_6)),},
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId> _parity_scale_codec::Encode for
             MinerInfo<AccountId> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    dest.push(&self.accountid);
                    dest.push(&self.mac);
                    dest.push(&self.superior_address);
                    dest.push(&self.onsuperior_address);
                    dest.push(&self.register_time);
                    dest.push(&self.status);
                    dest.push(&self.miner);
                }
            }
            impl <AccountId> _parity_scale_codec::EncodeLike for
             MinerInfo<AccountId> where
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId> _parity_scale_codec::Decode for
             MinerInfo<AccountId> where
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(MinerInfo{accountid:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.accountid".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 mac:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.mac".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 superior_address:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.superior_address".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 onsuperior_address:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.onsuperior_address".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 register_time:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.register_time".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 status:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.status".into()),
                                             Ok(a) => a,
                                         }
                                     },
                                 miner:
                                     {
                                         let res =
                                             _parity_scale_codec::Decode::decode(input);
                                         match res {
                                             Err(_) =>
                                             return Err("Error decoding field MinerInfo.miner".into()),
                                             Ok(a) => a,
                                         }
                                     },})
                }
            }
        };
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{StorageValue
                                                                    as _,
                                                                    StorageMap
                                                                    as _,
                                                                    StorageLinkedMap
                                                                    as _,
                                                                    StorageDoubleMap
                                                                    as _};
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate support as hidden_include;
    }
    trait Store {
        type
        TokenInfo;
        type
        OwnedMinerInfo;
    }
    impl <T: Trait + 'static> Store for Module<T> {
        type
        TokenInfo
        =
        TokenInfo<T>;
        type
        OwnedMinerInfo
        =
        OwnedMinerInfo<T>;
    }
    impl <T: Trait + 'static> Module<T> {
        #[doc = " store all miner\'s token address,include BTC,ETH,..."]
        pub fn token_info<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<(T::AccountId,
                                                                                                           Option<Vec<u8>>)>>(key:
                                                                                                                                  K)
         -> Vec<u8> {
            <TokenInfo<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<(T::AccountId,
                                                                                                Option<Vec<u8>>),
                                                                                               Vec<u8>>>::get(key)
        }
        #[doc = " store all miner\'s minerinfo"]
        pub fn owned_minerinfo<K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<(T::AccountId)>>(key:
                                                                                                                                    K)
         -> Option<MinerInfo<AccountId>> {
            <OwnedMinerInfo<T> as
                self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StorageMap<(T::AccountId),
                                                                                               MinerInfo<AccountId>>>::get(key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructTokenInfo<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_TokenInfo:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructTokenInfo<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_TokenInfo.get_or_init(||
                                                              {
                                                                  let def_val:
                                                                          Vec<u8> =
                                                                      Default::default();
                                                                  <Vec<u8> as
                                                                      Encode>::encode(&def_val)
                                                              }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructTokenInfo<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructTokenInfo<T> { }
    #[doc(hidden)]
    pub struct __GetByteStructOwnedMinerInfo<T>(pub self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T)>);
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_OwnedMinerInfo:
           self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8>>
           =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
     for __GetByteStructOwnedMinerInfo<T> {
        fn default_byte(&self)
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::vec::Vec<u8> {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_OwnedMinerInfo.get_or_init(||
                                                                   {
                                                                       let def_val:
                                                                               Option<MinerInfo<AccountId>> =
                                                                           Default::default();
                                                                       <Option<MinerInfo<AccountId>>
                                                                           as
                                                                           Encode>::encode(&def_val)
                                                                   }).clone()
        }
    }
    unsafe impl <T: Trait> Send for __GetByteStructOwnedMinerInfo<T> { }
    unsafe impl <T: Trait> Sync for __GetByteStructOwnedMinerInfo<T> { }
    impl <T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata()
         ->
             self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata {
            self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata{prefix:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Transx"),
                                                                                                 entries:
                                                                                                     self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("TokenInfo"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Default,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("(T::AccountId, Option<Vec<u8>>)"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("Vec<u8>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructTokenInfo::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[" store all miner\'s token address,include BTC,ETH,..."]),},
                                                                                                                                                                                                    self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryMetadata{name:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("OwnedMinerInfo"),
                                                                                                                                                                                                                                                                                              modifier:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryModifier::Optional,
                                                                                                                                                                                                                                                                                              ty:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageEntryType::Map{hasher:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageHasher::Blake2_256,
                                                                                                                                                                                                                                                                                                                                                                                             key:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("(T::AccountId)"),
                                                                                                                                                                                                                                                                                                                                                                                             value:
                                                                                                                                                                                                                                                                                                                                                                                                 self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode("MinerInfo<AccountId>"),
                                                                                                                                                                                                                                                                                                                                                                                             is_linked:
                                                                                                                                                                                                                                                                                                                                                                                                 false,},
                                                                                                                                                                                                                                                                                              default:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByteGetter(&__GetByteStructOwnedMinerInfo::<T>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData))),
                                                                                                                                                                                                                                                                                              documentation:
                                                                                                                                                                                                                                                                                                  self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DecodeDifferent::Encode(&[" store all miner\'s minerinfo"]),}][..]),}
        }
    }
    #[doc = r" Tag a type as an instance of a module."]
    #[doc = r""]
    #[doc = r" Defines storage prefixes, they must be unique."]
    #[doc(hidden)]
    pub trait __GeneratedInstantiable: 'static {
        #[doc = r" The prefix used by any storage entry of an instance."]
        const
        PREFIX:
        &'static str;
    }
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance =>
                match *self { __InherentHiddenInstance => true, },
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Encode for __InherentHiddenInstance {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                }
            }
            impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance
             {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl _parity_scale_codec::Decode for __InherentHiddenInstance {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    Ok(__InherentHiddenInstance)
                }
            }
        };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl __GeneratedInstantiable for __InherentHiddenInstance {
        const
        PREFIX:
        &'static str
        =
        "Transx";
    }
    #[doc = " store all miner\'s token address,include BTC,ETH,..."]
    pub struct TokenInfo<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<(T::AccountId,
                                                                                                Option<Vec<u8>>),
                                                                                               Vec<u8>>
     for TokenInfo<T> {
        type
        Query
        =
        Vec<u8>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "TokenInfo".as_bytes() }
        fn from_optional_value_to_query(v: Option<Vec<u8>>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<Vec<u8>> {
            Some(v)
        }
    }
    #[doc = " store all miner\'s minerinfo"]
    pub struct OwnedMinerInfo<T: Trait>(self::sp_api_hidden_includes_decl_storage::hidden_include::rstd::marker::PhantomData<(T,)>);
    impl <T: Trait>
     self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<(T::AccountId),
                                                                                               MinerInfo<AccountId>>
     for OwnedMinerInfo<T> {
        type
        Query
        =
        Option<MinerInfo<AccountId>>;
        type
        Hasher
        =
        self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_256;
        fn module_prefix() -> &'static [u8] {
            __InherentHiddenInstance::PREFIX.as_bytes()
        }
        fn storage_prefix() -> &'static [u8] { "OwnedMinerInfo".as_bytes() }
        fn from_optional_value_to_query(v: Option<MinerInfo<AccountId>>)
         -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query)
         -> Option<MinerInfo<AccountId>> {
            v
        }
    }
    pub struct Module<T: Trait>(::frame_support::rstd::marker::PhantomData<(T)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T>
     {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) =>
                Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T>
     {
    }
    impl <T: Trait> ::core::marker::StructuralPartialEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for
     Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) =>
                match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl <T: Trait> ::core::marker::StructuralEq for Module<T> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _:
                        ::core::cmp::AssertParamIsEq<::frame_support::rstd::marker::PhantomData<(T)>>;
            }
        }
    }
    impl <T: Trait> core::fmt::Debug for Module<T> where T: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnInitialize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OnFinalize<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> ::frame_support::dispatch::WeighBlock<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait>
     ::frame_support::sp_runtime::traits::OffchainWorker<T::BlockNumber> for
     Module<T> {
    }
    impl <T: Trait> Module<T> {
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <system::Module<T>>::deposit_event(event.into())
        }
    }
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl <T: Trait> Module<T> {
        #[doc = r" register miner"]
        pub fn register_miner(origin: T::Origin,
                              superior_address:
                                  <T::Lookup as StaticLookup>::Source,
                              onsuperior_address:
                                  <T::Lookup as StaticLookup>::Source)
         -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("register_miner",
                                                                                "node_runtime::transx",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/transx.rs"),
                                                                                Some(105u32),
                                                                                Some("node_runtime::transx"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = ensure_signed(origin)?;
                Self::deposit_event(RawEvent::RegsitedMiner(who));
                Ok(())
            }
        }
        #[doc = r" miner bond other token's address,etc, BTC"]
        pub fn bond_address(origin: T::Origin,
                            addresses: Vec<(Vec<u8>, Vec<u8>)>) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("bond_address",
                                                                                "node_runtime::transx",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/transx.rs"),
                                                                                Some(105u32),
                                                                                Some("node_runtime::transx"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = ensure_signed(origin)?;
                Self::deposit_event(RawEvent::BondedAddress(who));
                Ok(())
            }
        }
        #[doc = r" update bond other token's address"]
        pub fn update_bond_address(origin: T::Origin, token_symbol: Vec<u8>,
                                   token_address: Vec<u8>) -> Result {
            use ::frame_support::rstd::if_std;
            use ::frame_support::tracing;
            let span =
                {
                    if ::tracing::dispatcher::has_been_set() &&
                           tracing::Level::DEBUG <=
                               ::tracing::level_filters::STATIC_MAX_LEVEL {
                        use ::tracing::callsite;
                        use ::tracing::callsite::Callsite;
                        let callsite =
                            {
                                use ::tracing::{callsite,
                                                subscriber::Interest,
                                                Metadata, __macro_support::*};
                                struct MyCallsite;
                                static META: Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("update_bond_address",
                                                                                "node_runtime::transx",
                                                                                tracing::Level::DEBUG,
                                                                                Some("bin/node/runtime/src/transx.rs"),
                                                                                Some(105u32),
                                                                                Some("node_runtime::transx"),
                                                                                ::tracing_core::field::FieldSet::new(&[],
                                                                                                                     ::tracing_core::callsite::Identifier(&MyCallsite)),
                                                                                ::tracing::metadata::Kind::SPAN)
                                    };
                                static INTEREST: AtomicUsize =
                                    AtomicUsize::new(0);
                                static REGISTRATION: Once = Once::new();
                                impl MyCallsite {
                                    #[inline]
                                    fn interest(&self) -> Interest {
                                        match INTEREST.load(Ordering::Relaxed)
                                            {
                                            0 => Interest::never(),
                                            2 => Interest::always(),
                                            _ => Interest::sometimes(),
                                        }
                                    }
                                }
                                impl callsite::Callsite for MyCallsite {
                                    fn set_interest(&self,
                                                    interest: Interest) {
                                        let interest =
                                            match () {
                                                _ if interest.is_never() => 0,
                                                _ if interest.is_always() =>
                                                2,
                                                _ => 1,
                                            };
                                        INTEREST.store(interest,
                                                       Ordering::SeqCst);
                                    }
                                    fn metadata(&self) -> &Metadata { &META }
                                }
                                REGISTRATION.call_once(||
                                                           {
                                                               callsite::register(&MyCallsite);
                                                           });
                                &MyCallsite
                            };
                        let meta = callsite.metadata();
                        if {
                               let interest = callsite.interest();
                               if interest.is_never() {
                                   false
                               } else if interest.is_always() {
                                   true
                               } else {
                                   let meta = callsite.metadata();
                                   ::tracing::dispatcher::get_default(|current|
                                                                          current.enabled(meta))
                               }
                           } {
                            ::tracing::Span::new(meta,
                                                 &{
                                                      meta.fields().value_set(&[])
                                                  })
                        } else { ::tracing::Span::none() }
                    } else { ::tracing::Span::none() }
                };
            let _enter = span.enter();
            {
                let who = ensure_signed(origin)?;
                Self::deposit_event(RawEvent::UpdatedBondAddress(who));
                Ok(())
            }
        }
    }
    #[doc = r" The module declaration."]
    pub enum Call<T: Trait> {

        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(::frame_support::rstd::marker::PhantomData<(T)>,
                      ::frame_support::dispatch::Never),

        #[allow(non_camel_case_types)]
        #[doc = r" register miner"]
        register_miner(<T::Lookup as StaticLookup>::Source,
                       <T::Lookup as StaticLookup>::Source),

        #[allow(non_camel_case_types)]
        #[doc = r" miner bond other token's address,etc, BTC"]
        bond_address(Vec<(Vec<u8>, Vec<u8>)>),

        #[allow(non_camel_case_types)]
        #[doc = r" update bond other token's address"]
        update_bond_address(Vec<u8>, Vec<u8>),
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Encode for Call<T> where
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode
             {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        Call::register_miner(ref aa, ref ba) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        Call::bond_address(ref aa) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                        }
                        Call::update_bond_address(ref aa, ref ba) => {
                            dest.push_byte(2usize as u8);
                            dest.push(aa);
                            dest.push(ba);
                        }
                        _ => (),
                    }
                }
            }
            impl <T: Trait> _parity_scale_codec::EncodeLike for Call<T> where
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Encode
             {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <T: Trait> _parity_scale_codec::Decode for Call<T> where
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Decode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Decode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Decode,
             <T::Lookup as StaticLookup>::Source: _parity_scale_codec::Decode
             {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(Call::register_miner({
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: register_miner.0".into()),
                                                            Ok(a) => a,
                                                        }
                                                    },
                                                    {
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: register_miner.1".into()),
                                                            Ok(a) => a,
                                                        }
                                                    }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(Call::bond_address({
                                                      let res =
                                                          _parity_scale_codec::Decode::decode(input);
                                                      match res {
                                                          Err(_) =>
                                                          return Err("Error decoding field Call :: bond_address.0".into()),
                                                          Ok(a) => a,
                                                      }
                                                  }))
                        }
                        x if x == 2usize as u8 => {
                            Ok(Call::update_bond_address({
                                                             let res =
                                                                 _parity_scale_codec::Decode::decode(input);
                                                             match res {
                                                                 Err(_) =>
                                                                 return Err("Error decoding field Call :: update_bond_address.0".into()),
                                                                 Ok(a) => a,
                                                             }
                                                         },
                                                         {
                                                             let res =
                                                                 _parity_scale_codec::Decode::decode(input);
                                                             match res {
                                                                 Err(_) =>
                                                                 return Err("Error decoding field Call :: update_bond_address.1".into()),
                                                                 Ok(a) => a,
                                                             }
                                                         }))
                        }
                        x => Err("No such variant in enum Call".into()),
                    }
                }
            }
        };
    impl <T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self)
         -> ::frame_support::dispatch::DispatchInfo {
            if let Call::register_miner(ref superior_address,
                                        ref onsuperior_address) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&<T::Lookup as
                                                                StaticLookup>::Source,
                                                               &<T::Lookup as
                                                                StaticLookup>::Source)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                     (superior_address,
                                                                                                      onsuperior_address));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&<T::Lookup
                                                                       as
                                                                       StaticLookup>::Source,
                                                                      &<T::Lookup
                                                                       as
                                                                       StaticLookup>::Source)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                                   (superior_address,
                                                                                                                    onsuperior_address));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/transx.rs",
                                                         105u32, 1u32))
                        }
                    }
                }
            }
            if let Call::bond_address(ref addresses) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<(Vec<u8>,
                                                                     Vec<u8>)>,)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                               (addresses,));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<(Vec<u8>,
                                                                            Vec<u8>)>,)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                             (addresses,));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/transx.rs",
                                                         105u32, 1u32))
                        }
                    }
                }
            }
            if let Call::update_bond_address(ref token_symbol,
                                             ref token_address) = self {
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,
                                                               &Vec<u8>)>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                       (token_symbol,
                                                                                        token_address));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(&Vec<u8>,
                                                                      &Vec<u8>)>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                                     (token_symbol,
                                                                                                      token_address));
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
                return ::frame_support::dispatch::DispatchInfo{weight,
                                                               class,
                                                               pays_fee,};
            }
            if let Call::__PhantomItem(_, _) = self {
                {
                    {
                        {
                            ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                       &match (&"__PhantomItem should never be used.",)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::core::fmt::Display::fmt)],
                                                                                        }),
                                                       &("bin/node/runtime/src/transx.rs",
                                                         105u32, 1u32))
                        }
                    }
                }
            }
            let weight =
                <dyn ::frame_support::dispatch::WeighData<_>>::weigh_data(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                          ());
            let class =
                <dyn ::frame_support::dispatch::ClassifyDispatch<_>>::classify_dispatch(&::frame_support::dispatch::SimpleDispatchInfo::default(),
                                                                                        ());
            let pays_fee =
                <dyn ::frame_support::dispatch::PaysFee>::pays_fee(&::frame_support::dispatch::SimpleDispatchInfo::default());
            ::frame_support::dispatch::DispatchInfo{weight, class, pays_fee,}
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::register_miner(ref superior_address,
                                     ref onsuperior_address) =>
                Call::register_miner((*superior_address).clone(),
                                     (*onsuperior_address).clone()),
                Call::bond_address(ref addresses) =>
                Call::bond_address((*addresses).clone()),
                Call::update_bond_address(ref token_symbol, ref token_address)
                =>
                Call::update_bond_address((*token_symbol).clone(),
                                          (*token_address).clone()),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/transx.rs",
                                                 105u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::register_miner(ref superior_address,
                                     ref onsuperior_address) => {
                    let self_params = (superior_address, onsuperior_address);
                    if let Call::register_miner(ref superior_address,
                                                ref onsuperior_address) =
                           *_other {
                        self_params == (superior_address, onsuperior_address)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/transx.rs",
                                                             105u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::bond_address(ref addresses) => {
                    let self_params = (addresses,);
                    if let Call::bond_address(ref addresses) = *_other {
                        self_params == (addresses,)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/transx.rs",
                                                             105u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                Call::update_bond_address(ref token_symbol, ref token_address)
                => {
                    let self_params = (token_symbol, token_address);
                    if let Call::update_bond_address(ref token_symbol,
                                                     ref token_address) =
                           *_other {
                        self_params == (token_symbol, token_address)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                {
                                    ::std::rt::begin_panic("internal error: entered unreachable code",
                                                           &("bin/node/runtime/src/transx.rs",
                                                             105u32, 1u32))
                                }
                            }
                            _ => false,
                        }
                    }
                }
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/transx.rs",
                                                 105u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Eq for Call<T> { }
    impl <T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(&self, _f: &mut ::frame_support::dispatch::fmt::Formatter)
         ->
             ::frame_support::dispatch::result::Result<(),
                                                       ::frame_support::dispatch::fmt::Error> {
            match *self {
                Call::register_miner(ref superior_address,
                                     ref onsuperior_address) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"register_miner",
                                                                    &(superior_address.clone(),
                                                                      onsuperior_address.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::bond_address(ref addresses) =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"bond_address",
                                                                    &(addresses.clone(),))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                Call::update_bond_address(ref token_symbol, ref token_address)
                =>
                _f.write_fmt(::core::fmt::Arguments::new_v1(&["", ""],
                                                            &match (&"update_bond_address",
                                                                    &(token_symbol.clone(),
                                                                      token_address.clone()))
                                                                 {
                                                                 (arg0, arg1)
                                                                 =>
                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                               ::core::fmt::Display::fmt),
                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                               ::core::fmt::Debug::fmt)],
                                                             })),
                _ => {
                    {
                        ::std::rt::begin_panic("internal error: entered unreachable code",
                                               &("bin/node/runtime/src/transx.rs",
                                                 105u32, 1u32))
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Dispatchable for Call<T> {
        type
        Trait
        =
        T;
        type
        Origin
        =
        T::Origin;
        type
        Error
        =
        &'static str;
        fn dispatch(self, _origin: Self::Origin)
         -> ::frame_support::dispatch::DispatchResult<Self::Error> {
            match self {
                Call::register_miner(superior_address, onsuperior_address) =>
                {
                    <Module<T>>::register_miner(_origin, superior_address,
                                                onsuperior_address)
                }
                Call::bond_address(addresses) => {
                    <Module<T>>::bond_address(_origin, addresses)
                }
                Call::update_bond_address(token_symbol, token_address) => {
                    <Module<T>>::update_bond_address(_origin, token_symbol,
                                                     token_address)
                }
                Call::__PhantomItem(_, _) => {
                    {
                        {
                            {
                                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                                                                           &match (&"__PhantomItem should never be used.",)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::core::fmt::Display::fmt)],
                                                                                            }),
                                                           &("bin/node/runtime/src/transx.rs",
                                                             105u32, 1u32))
                            }
                        }
                    }
                }
            }
        }
    }
    impl <T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type
        Call
        =
        Call<T>;
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn dispatch<D: ::frame_support::dispatch::Dispatchable<Trait =
                        T>>(d: D, origin: D::Origin)
         -> ::frame_support::dispatch::DispatchResult<D::Error> {
            d.dispatch(origin)
        }
    }
    impl <T: Trait> Module<T> {
        #[doc(hidden)]
        pub fn call_functions()
         -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("register_miner"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("superior_address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("<T::Lookup as StaticLookup>::Source"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("onsuperior_address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("<T::Lookup as StaticLookup>::Source"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[r" register miner"]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("bond_address"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("addresses"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<(Vec<u8>, Vec<u8>)>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[r" miner bond other token's address,etc, BTC"]),},
              ::frame_support::dispatch::FunctionMetadata{name:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode("update_bond_address"),
                                                          arguments:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("token_symbol"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),},
                                                                                                                   ::frame_support::dispatch::FunctionArgumentMetadata{name:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("token_address"),
                                                                                                                                                                       ty:
                                                                                                                                                                           ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),}]),
                                                          documentation:
                                                              ::frame_support::dispatch::DecodeDifferent::Encode(&[r" update bond other token's address"]),}]
        }
    }
    impl <T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        pub fn module_constants_metadata()
         -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl <T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for
     Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as
                ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    /// [`RawEvent`] specialized for the configuration [`Trait`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Trait`]: trait.Trait.html
    pub type Event<T> = RawEvent<<T as system::Trait>::AccountId>;
    /// Events for this module.
    ///
    pub enum RawEvent<AccountId> {
        RegsitedMiner(AccountId),
        BondedAddress(AccountId),
        UpdatedBondAddress(AccountId),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::clone::Clone> ::core::clone::Clone for
     RawEvent<AccountId> {
        #[inline]
        fn clone(&self) -> RawEvent<AccountId> {
            match (&*self,) {
                (&RawEvent::RegsitedMiner(ref __self_0),) =>
                RawEvent::RegsitedMiner(::core::clone::Clone::clone(&(*__self_0))),
                (&RawEvent::BondedAddress(ref __self_0),) =>
                RawEvent::BondedAddress(::core::clone::Clone::clone(&(*__self_0))),
                (&RawEvent::UpdatedBondAddress(ref __self_0),) =>
                RawEvent::UpdatedBondAddress(::core::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    impl <AccountId> ::core::marker::StructuralPartialEq for
     RawEvent<AccountId> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
     RawEvent<AccountId> {
        #[inline]
        fn eq(&self, other: &RawEvent<AccountId>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::RegsitedMiner(ref __self_0),
                         &RawEvent::RegsitedMiner(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&RawEvent::BondedAddress(ref __self_0),
                         &RawEvent::BondedAddress(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&RawEvent::UpdatedBondAddress(ref __self_0),
                         &RawEvent::UpdatedBondAddress(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<AccountId>) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as isize;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&RawEvent::RegsitedMiner(ref __self_0),
                         &RawEvent::RegsitedMiner(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&RawEvent::BondedAddress(ref __self_0),
                         &RawEvent::BondedAddress(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&RawEvent::UpdatedBondAddress(ref __self_0),
                         &RawEvent::UpdatedBondAddress(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    impl <AccountId> ::core::marker::StructuralEq for RawEvent<AccountId> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <AccountId: ::core::cmp::Eq> ::core::cmp::Eq for RawEvent<AccountId>
     {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
            }
        }
    }
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId> _parity_scale_codec::Encode for
             RawEvent<AccountId> where AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
                fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                                  dest:
                                                                      &mut EncOut) {
                    match *self {
                        RawEvent::RegsitedMiner(ref aa) => {
                            dest.push_byte(0usize as u8);
                            dest.push(aa);
                        }
                        RawEvent::BondedAddress(ref aa) => {
                            dest.push_byte(1usize as u8);
                            dest.push(aa);
                        }
                        RawEvent::UpdatedBondAddress(ref aa) => {
                            dest.push_byte(2usize as u8);
                            dest.push(aa);
                        }
                        _ => (),
                    }
                }
            }
            impl <AccountId> _parity_scale_codec::EncodeLike for
             RawEvent<AccountId> where AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode,
             AccountId: _parity_scale_codec::Encode {
            }
        };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl <AccountId> _parity_scale_codec::Decode for
             RawEvent<AccountId> where AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode,
             AccountId: _parity_scale_codec::Decode {
                fn decode<DecIn: _parity_scale_codec::Input>(input:
                                                                 &mut DecIn)
                 -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match input.read_byte()? {
                        x if x == 0usize as u8 => {
                            Ok(RawEvent::RegsitedMiner({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: RegsitedMiner.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                        }
                        x if x == 1usize as u8 => {
                            Ok(RawEvent::BondedAddress({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field RawEvent :: BondedAddress.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                        }
                        x if x == 2usize as u8 => {
                            Ok(RawEvent::UpdatedBondAddress({
                                                                let res =
                                                                    _parity_scale_codec::Decode::decode(input);
                                                                match res {
                                                                    Err(_) =>
                                                                    return Err("Error decoding field RawEvent :: UpdatedBondAddress.0".into()),
                                                                    Ok(a) =>
                                                                    a,
                                                                }
                                                            }))
                        }
                        x => Err("No such variant in enum RawEvent".into()),
                    }
                }
            }
        };
    impl <AccountId> core::fmt::Debug for RawEvent<AccountId> where
     AccountId: core::fmt::Debug {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::RegsitedMiner(ref a0) =>
                fmt.debug_tuple("RawEvent::RegsitedMiner").field(a0).finish(),
                Self::BondedAddress(ref a0) =>
                fmt.debug_tuple("RawEvent::BondedAddress").field(a0).finish(),
                Self::UpdatedBondAddress(ref a0) =>
                fmt.debug_tuple("RawEvent::UpdatedBondAddress").field(a0).finish(),
                _ => Ok(()),
            }
        }
    }
    impl <AccountId> From<RawEvent<AccountId>> for () {
        fn from(_: RawEvent<AccountId>) -> () { () }
    }
    impl <AccountId> RawEvent<AccountId> {
        #[allow(dead_code)]
        pub fn metadata()
         -> &'static [::frame_support::event::EventMetadata] {
            &[::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("RegsitedMiner"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("BondedAddress"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),},
              ::frame_support::event::EventMetadata{name:
                                                        ::frame_support::event::DecodeDifferent::Encode("UpdatedBondAddress"),
                                                    arguments:
                                                        ::frame_support::event::DecodeDifferent::Encode(&["AccountId"]),
                                                    documentation:
                                                        ::frame_support::event::DecodeDifferent::Encode(&[]),}]
        }
    }
}
/// Runtime version.
pub const VERSION: RuntimeVersion =
    RuntimeVersion{spec_name: { std::borrow::Cow::Borrowed("node") },
                   impl_name:
                       { std::borrow::Cow::Borrowed("substrate-node") },
                   authoring_version: 10,
                   spec_version: 197,
                   impl_version: 197,
                   apis: RUNTIME_API_VERSIONS,};
/// Native version.
#[cfg(any (feature = "std", test))]
pub fn native_version() -> NativeVersion {
    NativeVersion{runtime_version: VERSION,
                  can_author_with: Default::default(),}
}
type NegativeImbalance = <Balances as Currency<AccountId>>::NegativeImbalance;
pub type DealWithFees
    =
    SplitTwoWays<Balance, NegativeImbalance, _4, Treasury, _1, Author>;
pub struct BlockHashCount;
impl BlockHashCount {
    pub fn get() -> BlockNumber { 250 }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for BlockHashCount
 {
    fn get() -> I { I::from(250) }
}
pub struct MaximumBlockWeight;
impl MaximumBlockWeight {
    pub fn get() -> Weight { 1_000_000_000 }
}
impl <I: From<Weight>> ::frame_support::traits::Get<I> for MaximumBlockWeight
 {
    fn get() -> I { I::from(1_000_000_000) }
}
pub struct MaximumBlockLength;
impl MaximumBlockLength {
    pub fn get() -> u32 { 5 * 1024 * 1024 }
}
impl <I: From<u32>> ::frame_support::traits::Get<I> for MaximumBlockLength {
    fn get() -> I { I::from(5 * 1024 * 1024) }
}
pub struct Version;
impl Version {
    pub fn get() -> RuntimeVersion { VERSION }
}
impl <I: From<RuntimeVersion>> ::frame_support::traits::Get<I> for Version {
    fn get() -> I { I::from(VERSION) }
}
pub struct AvailableBlockRatio;
impl AvailableBlockRatio {
    pub fn get() -> Perbill { Perbill::from_percent(75) }
}
impl <I: From<Perbill>> ::frame_support::traits::Get<I> for
 AvailableBlockRatio {
    fn get() -> I { I::from(Perbill::from_percent(75)) }
}
impl system::Trait for Runtime {
    type
    Origin
    =
    Origin;
    type
    Call
    =
    Call;
    type
    Index
    =
    Index;
    type
    BlockNumber
    =
    BlockNumber;
    type
    Hash
    =
    Hash;
    type
    Hashing
    =
    BlakeTwo256;
    type
    AccountId
    =
    AccountId;
    type
    Lookup
    =
    Indices;
    type
    Header
    =
    generic::Header<BlockNumber, BlakeTwo256>;
    type
    Event
    =
    Event;
    type
    BlockHashCount
    =
    BlockHashCount;
    type
    MaximumBlockWeight
    =
    MaximumBlockWeight;
    type
    MaximumBlockLength
    =
    MaximumBlockLength;
    type
    AvailableBlockRatio
    =
    AvailableBlockRatio;
    type
    Version
    =
    Version;
}
impl utility::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    Call
    =
    Call;
}
pub struct EpochDuration;
impl EpochDuration {
    pub fn get() -> u64 { EPOCH_DURATION_IN_SLOTS }
}
impl <I: From<u64>> ::frame_support::traits::Get<I> for EpochDuration {
    fn get() -> I { I::from(EPOCH_DURATION_IN_SLOTS) }
}
pub struct ExpectedBlockTime;
impl ExpectedBlockTime {
    pub fn get() -> Moment { MILLISECS_PER_BLOCK }
}
impl <I: From<Moment>> ::frame_support::traits::Get<I> for ExpectedBlockTime {
    fn get() -> I { I::from(MILLISECS_PER_BLOCK) }
}
impl babe::Trait for Runtime {
    type
    EpochDuration
    =
    EpochDuration;
    type
    ExpectedBlockTime
    =
    ExpectedBlockTime;
    type
    EpochChangeTrigger
    =
    babe::ExternalTrigger;
}
impl indices::Trait for Runtime {
    type
    AccountIndex
    =
    AccountIndex;
    type
    IsDeadAccount
    =
    Balances;
    type
    ResolveHint
    =
    indices::SimpleResolveHint<Self::AccountId, Self::AccountIndex>;
    type
    Event
    =
    Event;
}
pub struct ExistentialDeposit;
impl ExistentialDeposit {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for ExistentialDeposit
 {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct TransferFee;
impl TransferFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for TransferFee {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct CreationFee;
impl CreationFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for CreationFee {
    fn get() -> I { I::from(1 * CENTS) }
}
impl balances::Trait for Runtime {
    type
    Balance
    =
    Balance;
    type
    OnFreeBalanceZero
    =
    ((Staking, Contracts), Session);
    type
    OnNewAccount
    =
    Indices;
    type
    Event
    =
    Event;
    type
    DustRemoval
    =
    ();
    type
    TransferPayment
    =
    ();
    type
    ExistentialDeposit
    =
    ExistentialDeposit;
    type
    TransferFee
    =
    TransferFee;
    type
    CreationFee
    =
    CreationFee;
}
pub struct TransactionBaseFee;
impl TransactionBaseFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for TransactionBaseFee
 {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct TransactionByteFee;
impl TransactionByteFee {
    pub fn get() -> Balance { 10 * MILLICENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for TransactionByteFee
 {
    fn get() -> I { I::from(10 * MILLICENTS) }
}
pub struct WeightFeeCoefficient;
impl WeightFeeCoefficient {
    pub fn get() -> Balance { 1_000 }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 WeightFeeCoefficient {
    fn get() -> I { I::from(1_000) }
}
pub struct TargetBlockFullness;
impl TargetBlockFullness {
    pub fn get() -> Perbill { Perbill::from_percent(25) }
}
impl <I: From<Perbill>> ::frame_support::traits::Get<I> for
 TargetBlockFullness {
    fn get() -> I { I::from(Perbill::from_percent(25)) }
}
impl transaction_payment::Trait for Runtime {
    type
    Currency
    =
    Balances;
    type
    OnTransactionPayment
    =
    DealWithFees;
    type
    TransactionBaseFee
    =
    TransactionBaseFee;
    type
    TransactionByteFee
    =
    TransactionByteFee;
    type
    WeightToFee
    =
    LinearWeightToFee<WeightFeeCoefficient>;
    type
    FeeMultiplierUpdate
    =
    TargetedFeeAdjustment<TargetBlockFullness>;
}
pub struct MinimumPeriod;
impl MinimumPeriod {
    pub fn get() -> Moment { SLOT_DURATION / 2 }
}
impl <I: From<Moment>> ::frame_support::traits::Get<I> for MinimumPeriod {
    fn get() -> I { I::from(SLOT_DURATION / 2) }
}
impl timestamp::Trait for Runtime {
    type
    Moment
    =
    Moment;
    type
    OnTimestampSet
    =
    Babe;
    type
    MinimumPeriod
    =
    MinimumPeriod;
}
pub struct UncleGenerations;
impl UncleGenerations {
    pub fn get() -> BlockNumber { 5 }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 UncleGenerations {
    fn get() -> I { I::from(5) }
}
impl authorship::Trait for Runtime {
    type
    FindAuthor
    =
    session::FindAccountFromAuthorIndex<Self, Babe>;
    type
    UncleGenerations
    =
    UncleGenerations;
    type
    FilterUncle
    =
    ();
    type
    EventHandler
    =
    (Staking, ImOnline);
}
pub struct SessionKeys {
    pub grandpa: <Grandpa as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
    pub babe: <Babe as ::sp_runtime::BoundToRuntimeAppPublic>::Public,
    pub im_online: <ImOnline as
                   ::sp_runtime::BoundToRuntimeAppPublic>::Public,
    pub authority_discovery: <AuthorityDiscovery as
                             ::sp_runtime::BoundToRuntimeAppPublic>::Public,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::default::Default for SessionKeys {
    #[inline]
    fn default() -> SessionKeys {
        SessionKeys{grandpa: ::core::default::Default::default(),
                    babe: ::core::default::Default::default(),
                    im_online: ::core::default::Default::default(),
                    authority_discovery: ::core::default::Default::default(),}
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SessionKeys {
    #[inline]
    fn clone(&self) -> SessionKeys {
        match *self {
            SessionKeys {
            grandpa: ref __self_0_0,
            babe: ref __self_0_1,
            im_online: ref __self_0_2,
            authority_discovery: ref __self_0_3 } =>
            SessionKeys{grandpa: ::core::clone::Clone::clone(&(*__self_0_0)),
                        babe: ::core::clone::Clone::clone(&(*__self_0_1)),
                        im_online:
                            ::core::clone::Clone::clone(&(*__self_0_2)),
                        authority_discovery:
                            ::core::clone::Clone::clone(&(*__self_0_3)),},
        }
    }
}
impl ::core::marker::StructuralPartialEq for SessionKeys { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for SessionKeys {
    #[inline]
    fn eq(&self, other: &SessionKeys) -> bool {
        match *other {
            SessionKeys {
            grandpa: ref __self_1_0,
            babe: ref __self_1_1,
            im_online: ref __self_1_2,
            authority_discovery: ref __self_1_3 } =>
            match *self {
                SessionKeys {
                grandpa: ref __self_0_0,
                babe: ref __self_0_1,
                im_online: ref __self_0_2,
                authority_discovery: ref __self_0_3 } =>
                (*__self_0_0) == (*__self_1_0) &&
                    (*__self_0_1) == (*__self_1_1) &&
                    (*__self_0_2) == (*__self_1_2) &&
                    (*__self_0_3) == (*__self_1_3),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &SessionKeys) -> bool {
        match *other {
            SessionKeys {
            grandpa: ref __self_1_0,
            babe: ref __self_1_1,
            im_online: ref __self_1_2,
            authority_discovery: ref __self_1_3 } =>
            match *self {
                SessionKeys {
                grandpa: ref __self_0_0,
                babe: ref __self_0_1,
                im_online: ref __self_0_2,
                authority_discovery: ref __self_0_3 } =>
                (*__self_0_0) != (*__self_1_0) ||
                    (*__self_0_1) != (*__self_1_1) ||
                    (*__self_0_2) != (*__self_1_2) ||
                    (*__self_0_3) != (*__self_1_3),
            },
        }
    }
}
impl ::core::marker::StructuralEq for SessionKeys { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for SessionKeys {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _:
                    ::core::cmp::AssertParamIsEq<<Grandpa as
                                                 ::sp_runtime::BoundToRuntimeAppPublic>::Public>;
            let _:
                    ::core::cmp::AssertParamIsEq<<Babe as
                                                 ::sp_runtime::BoundToRuntimeAppPublic>::Public>;
            let _:
                    ::core::cmp::AssertParamIsEq<<ImOnline as
                                                 ::sp_runtime::BoundToRuntimeAppPublic>::Public>;
            let _:
                    ::core::cmp::AssertParamIsEq<<AuthorityDiscovery as
                                                 ::sp_runtime::BoundToRuntimeAppPublic>::Public>;
        }
    }
}
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for SessionKeys {
            fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                              dest:
                                                                  &mut EncOut) {
                dest.push(&self.grandpa);
                dest.push(&self.babe);
                dest.push(&self.im_online);
                dest.push(&self.authority_discovery);
            }
        }
        impl _parity_scale_codec::EncodeLike for SessionKeys { }
    };
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for SessionKeys {
            fn decode<DecIn: _parity_scale_codec::Input>(input: &mut DecIn)
             -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(SessionKeys{grandpa:
                                   {
                                       let res =
                                           _parity_scale_codec::Decode::decode(input);
                                       match res {
                                           Err(_) =>
                                           return Err("Error decoding field SessionKeys.grandpa".into()),
                                           Ok(a) => a,
                                       }
                                   },
                               babe:
                                   {
                                       let res =
                                           _parity_scale_codec::Decode::decode(input);
                                       match res {
                                           Err(_) =>
                                           return Err("Error decoding field SessionKeys.babe".into()),
                                           Ok(a) => a,
                                       }
                                   },
                               im_online:
                                   {
                                       let res =
                                           _parity_scale_codec::Decode::decode(input);
                                       match res {
                                           Err(_) =>
                                           return Err("Error decoding field SessionKeys.im_online".into()),
                                           Ok(a) => a,
                                       }
                                   },
                               authority_discovery:
                                   {
                                       let res =
                                           _parity_scale_codec::Decode::decode(input);
                                       match res {
                                           Err(_) =>
                                           return Err("Error decoding field SessionKeys.authority_discovery".into()),
                                           Ok(a) => a,
                                       }
                                   },})
            }
        }
    };
impl core::fmt::Debug for SessionKeys {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("SessionKeys").field("grandpa",
                                              &self.grandpa).field("babe",
                                                                   &self.babe).field("im_online",
                                                                                     &self.im_online).field("authority_discovery",
                                                                                                            &self.authority_discovery).finish()
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _IMPL_SERIALIZE_FOR_SessionKeys: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[allow(unused_macros)]
        macro_rules! try {
            ($ __expr : expr) =>
            {
                match $ __expr
                {
                    _serde :: export :: Ok (__val) => __val, _serde :: export
                    :: Err (__err) =>
                    { return _serde :: export :: Err (__err) ; }
                }
            }
        }
        #[automatically_derived]
        impl _serde::Serialize for SessionKeys {
            fn serialize<__S>(&self, __serializer: __S)
             -> _serde::export::Result<__S::Ok, __S::Error> where
             __S: _serde::Serializer {
                let mut __serde_state =
                    match _serde::Serializer::serialize_struct(__serializer,
                                                               "SessionKeys",
                                                               false as usize
                                                                   + 1 + 1 + 1
                                                                   + 1) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "grandpa",
                                                                    &self.grandpa)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "babe",
                                                                    &self.babe)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "im_online",
                                                                    &self.im_online)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "authority_discovery",
                                                                    &self.authority_discovery)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _IMPL_DESERIALIZE_FOR_SessionKeys: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[allow(unused_macros)]
        macro_rules! try {
            ($ __expr : expr) =>
            {
                match $ __expr
                {
                    _serde :: export :: Ok (__val) => __val, _serde :: export
                    :: Err (__err) =>
                    { return _serde :: export :: Err (__err) ; }
                }
            }
        }
        #[automatically_derived]
        impl <'de> _serde::Deserialize<'de> for SessionKeys {
            fn deserialize<__D>(__deserializer: __D)
             -> _serde::export::Result<Self, __D::Error> where
             __D: _serde::Deserializer<'de> {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type
                    Value
                    =
                    __Field;
                    fn expecting(&self,
                                 __formatter: &mut _serde::export::Formatter)
                     -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter,
                                                             "field identifier")
                    }
                    fn visit_u64<__E>(self, __value: u64)
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ =>
                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                 &"field index 0 <= i < 4")),
                        }
                    }
                    fn visit_str<__E>(self, __value: &str)
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            "grandpa" =>
                            _serde::export::Ok(__Field::__field0),
                            "babe" => _serde::export::Ok(__Field::__field1),
                            "im_online" =>
                            _serde::export::Ok(__Field::__field2),
                            "authority_discovery" =>
                            _serde::export::Ok(__Field::__field3),
                            _ => { _serde::export::Ok(__Field::__ignore) }
                        }
                    }
                    fn visit_bytes<__E>(self, __value: &[u8])
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            b"grandpa" =>
                            _serde::export::Ok(__Field::__field0),
                            b"babe" => _serde::export::Ok(__Field::__field1),
                            b"im_online" =>
                            _serde::export::Ok(__Field::__field2),
                            b"authority_discovery" =>
                            _serde::export::Ok(__Field::__field3),
                            _ => { _serde::export::Ok(__Field::__ignore) }
                        }
                    }
                }
                impl <'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                     __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<SessionKeys>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type
                    Value
                    =
                    SessionKeys;
                    fn expecting(&self,
                                 __formatter: &mut _serde::export::Formatter)
                     -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter,
                                                             "struct SessionKeys")
                    }
                    #[inline]
                    fn visit_seq<__A>(self, mut __seq: __A)
                     -> _serde::export::Result<Self::Value, __A::Error> where
                     __A: _serde::de::SeqAccess<'de> {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<<Grandpa
                                                                              as
                                                                              ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                 &"struct SessionKeys with 4 elements"));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<<Babe
                                                                              as
                                                                              ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                 &"struct SessionKeys with 4 elements"));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<<ImOnline
                                                                              as
                                                                              ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                 &"struct SessionKeys with 4 elements"));
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<<AuthorityDiscovery
                                                                              as
                                                                              ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                 &"struct SessionKeys with 4 elements"));
                                }
                            };
                        _serde::export::Ok(SessionKeys{grandpa: __field0,
                                                       babe: __field1,
                                                       im_online: __field2,
                                                       authority_discovery:
                                                           __field3,})
                    }
                    #[inline]
                    fn visit_map<__A>(self, mut __map: __A)
                     -> _serde::export::Result<Self::Value, __A::Error> where
                     __A: _serde::de::MapAccess<'de> {
                        let mut __field0:
                                _serde::export::Option<<Grandpa as
                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public> =
                            _serde::export::None;
                        let mut __field1:
                                _serde::export::Option<<Babe as
                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public> =
                            _serde::export::None;
                        let mut __field2:
                                _serde::export::Option<<ImOnline as
                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public> =
                            _serde::export::None;
                        let mut __field3:
                                _serde::export::Option<<AuthorityDiscovery as
                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("grandpa"));
                                    }
                                    __field0 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<<Grandpa
                                                                                                       as
                                                                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("babe"));
                                    }
                                    __field1 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<<Babe
                                                                                                       as
                                                                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("im_online"));
                                    }
                                    __field2 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<<ImOnline
                                                                                                       as
                                                                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("authority_discovery"));
                                    }
                                    __field3 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<<AuthorityDiscovery
                                                                                                       as
                                                                                                       ::sp_runtime::BoundToRuntimeAppPublic>::Public>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                _ => {
                                    let _ =
                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                }
                            }
                        }
                        let __field0 =
                            match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("grandpa")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field1 =
                            match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("babe")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field2 =
                            match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("im_online")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field3 =
                            match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("authority_discovery")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        _serde::export::Ok(SessionKeys{grandpa: __field0,
                                                       babe: __field1,
                                                       im_online: __field2,
                                                       authority_discovery:
                                                           __field3,})
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["grandpa", "babe", "im_online", "authority_discovery"];
                _serde::Deserializer::deserialize_struct(__deserializer,
                                                         "SessionKeys",
                                                         FIELDS,
                                                         __Visitor{marker:
                                                                       _serde::export::PhantomData::<SessionKeys>,
                                                                   lifetime:
                                                                       _serde::export::PhantomData,})
            }
        }
    };
impl SessionKeys {
    /// Generate a set of keys with optionally using the given seed.
    ///
    /// The generated key pairs are stored in the keystore.
    ///
    /// Returns the concatenated SCALE encoded public keys.
    pub fn generate(seed: Option<::sp_runtime::rstd::vec::Vec<u8>>)
     -> ::sp_runtime::rstd::vec::Vec<u8> {
        let keys =
            Self{grandpa:
                     <<Grandpa as
                      ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                         ::sp_runtime::RuntimeAppPublic>::generate_pair(seed.clone()),
                 babe:
                     <<Babe as ::sp_runtime::BoundToRuntimeAppPublic>::Public
                         as
                         ::sp_runtime::RuntimeAppPublic>::generate_pair(seed.clone()),
                 im_online:
                     <<ImOnline as
                      ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                         ::sp_runtime::RuntimeAppPublic>::generate_pair(seed.clone()),
                 authority_discovery:
                     <<AuthorityDiscovery as
                      ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                         ::sp_runtime::RuntimeAppPublic>::generate_pair(seed.clone()),};
        ::sp_runtime::codec::Encode::encode(&keys)
    }
}
impl ::sp_runtime::traits::OpaqueKeys for SessionKeys {
    type
    KeyTypeIdProviders
    =
    (Grandpa, Babe, ImOnline, AuthorityDiscovery);
    fn key_ids() -> &'static [::sp_runtime::KeyTypeId] {
        &[<<Grandpa as ::sp_runtime::BoundToRuntimeAppPublic>::Public as
              ::sp_runtime::RuntimeAppPublic>::ID,
          <<Babe as ::sp_runtime::BoundToRuntimeAppPublic>::Public as
              ::sp_runtime::RuntimeAppPublic>::ID,
          <<ImOnline as ::sp_runtime::BoundToRuntimeAppPublic>::Public as
              ::sp_runtime::RuntimeAppPublic>::ID,
          <<AuthorityDiscovery as
           ::sp_runtime::BoundToRuntimeAppPublic>::Public as
              ::sp_runtime::RuntimeAppPublic>::ID]
    }
    fn get_raw(&self, i: ::sp_runtime::KeyTypeId) -> &[u8] {
        match i {
            i if
            i ==
                <<Grandpa as ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                    ::sp_runtime::RuntimeAppPublic>::ID =>
            self.grandpa.as_ref(),
            i if
            i ==
                <<Babe as ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                    ::sp_runtime::RuntimeAppPublic>::ID => self.babe.as_ref(),
            i if
            i ==
                <<ImOnline as ::sp_runtime::BoundToRuntimeAppPublic>::Public
                    as ::sp_runtime::RuntimeAppPublic>::ID =>
            self.im_online.as_ref(),
            i if
            i ==
                <<AuthorityDiscovery as
                 ::sp_runtime::BoundToRuntimeAppPublic>::Public as
                    ::sp_runtime::RuntimeAppPublic>::ID =>
            self.authority_discovery.as_ref(),
            _ => &[],
        }
    }
}
pub struct DisabledValidatorsThreshold;
impl DisabledValidatorsThreshold {
    pub fn get() -> Perbill { Perbill::from_percent(17) }
}
impl <I: From<Perbill>> ::frame_support::traits::Get<I> for
 DisabledValidatorsThreshold {
    fn get() -> I { I::from(Perbill::from_percent(17)) }
}
impl session::Trait for Runtime {
    type
    OnSessionEnding
    =
    Staking;
    type
    SessionHandler
    =
    <SessionKeys as OpaqueKeys>::KeyTypeIdProviders;
    type
    ShouldEndSession
    =
    Babe;
    type
    Event
    =
    Event;
    type
    Keys
    =
    SessionKeys;
    type
    ValidatorId
    =
    <Self as system::Trait>::AccountId;
    type
    ValidatorIdOf
    =
    staking::StashOf<Self>;
    type
    SelectInitialValidators
    =
    Staking;
    type
    DisabledValidatorsThreshold
    =
    DisabledValidatorsThreshold;
}
impl session::historical::Trait for Runtime {
    type
    FullIdentification
    =
    staking::Exposure<AccountId, Balance>;
    type
    FullIdentificationOf
    =
    staking::ExposureOf<Runtime>;
}
const REWARD_CURVE: PiecewiseLinear<'static> =
    {
        extern crate sp_runtime as _sp_runtime;
        _sp_runtime::curve::PiecewiseLinear::<'static>{points:
                                                           &[(_sp_runtime::Perbill::from_parts(0u32),
                                                              _sp_runtime::Perbill::from_parts(25000000u32)),
                                                             (_sp_runtime::Perbill::from_parts(500000000u32),
                                                              _sp_runtime::Perbill::from_parts(100000000u32)),
                                                             (_sp_runtime::Perbill::from_parts(514743000u32),
                                                              _sp_runtime::Perbill::from_parts(86136000u32)),
                                                             (_sp_runtime::Perbill::from_parts(529486000u32),
                                                              _sp_runtime::Perbill::from_parts(74835000u32)),
                                                             (_sp_runtime::Perbill::from_parts(544229000u32),
                                                              _sp_runtime::Perbill::from_parts(65623000u32)),
                                                             (_sp_runtime::Perbill::from_parts(558972000u32),
                                                              _sp_runtime::Perbill::from_parts(58114000u32)),
                                                             (_sp_runtime::Perbill::from_parts(573715000u32),
                                                              _sp_runtime::Perbill::from_parts(51993000u32)),
                                                             (_sp_runtime::Perbill::from_parts(588456000u32),
                                                              _sp_runtime::Perbill::from_parts(47004000u32)),
                                                             (_sp_runtime::Perbill::from_parts(603197000u32),
                                                              _sp_runtime::Perbill::from_parts(42937000u32)),
                                                             (_sp_runtime::Perbill::from_parts(617937000u32),
                                                              _sp_runtime::Perbill::from_parts(39622000u32)),
                                                             (_sp_runtime::Perbill::from_parts(632675000u32),
                                                              _sp_runtime::Perbill::from_parts(36920000u32)),
                                                             (_sp_runtime::Perbill::from_parts(647415000u32),
                                                              _sp_runtime::Perbill::from_parts(34717000u32)),
                                                             (_sp_runtime::Perbill::from_parts(662156000u32),
                                                              _sp_runtime::Perbill::from_parts(32921000u32)),
                                                             (_sp_runtime::Perbill::from_parts(676897000u32),
                                                              _sp_runtime::Perbill::from_parts(31457000u32)),
                                                             (_sp_runtime::Perbill::from_parts(691632000u32),
                                                              _sp_runtime::Perbill::from_parts(30264000u32)),
                                                             (_sp_runtime::Perbill::from_parts(706375000u32),
                                                              _sp_runtime::Perbill::from_parts(29291000u32)),
                                                             (_sp_runtime::Perbill::from_parts(721114000u32),
                                                              _sp_runtime::Perbill::from_parts(28498000u32)),
                                                             (_sp_runtime::Perbill::from_parts(735842000u32),
                                                              _sp_runtime::Perbill::from_parts(27852000u32)),
                                                             (_sp_runtime::Perbill::from_parts(750579000u32),
                                                              _sp_runtime::Perbill::from_parts(27325000u32)),
                                                             (_sp_runtime::Perbill::from_parts(765292000u32),
                                                              _sp_runtime::Perbill::from_parts(26896000u32)),
                                                             (_sp_runtime::Perbill::from_parts(780013000u32),
                                                              _sp_runtime::Perbill::from_parts(26546000u32)),
                                                             (_sp_runtime::Perbill::from_parts(794712000u32),
                                                              _sp_runtime::Perbill::from_parts(26261000u32)),
                                                             (_sp_runtime::Perbill::from_parts(809448000u32),
                                                              _sp_runtime::Perbill::from_parts(26028000u32)),
                                                             (_sp_runtime::Perbill::from_parts(824189000u32),
                                                              _sp_runtime::Perbill::from_parts(25838000u32)),
                                                             (_sp_runtime::Perbill::from_parts(838837000u32),
                                                              _sp_runtime::Perbill::from_parts(25684000u32)),
                                                             (_sp_runtime::Perbill::from_parts(853524000u32),
                                                              _sp_runtime::Perbill::from_parts(25558000u32)),
                                                             (_sp_runtime::Perbill::from_parts(868243000u32),
                                                              _sp_runtime::Perbill::from_parts(25455000u32)),
                                                             (_sp_runtime::Perbill::from_parts(882966000u32),
                                                              _sp_runtime::Perbill::from_parts(25371000u32)),
                                                             (_sp_runtime::Perbill::from_parts(897571000u32),
                                                              _sp_runtime::Perbill::from_parts(25303000u32)),
                                                             (_sp_runtime::Perbill::from_parts(912311000u32),
                                                              _sp_runtime::Perbill::from_parts(25247000u32)),
                                                             (_sp_runtime::Perbill::from_parts(926819000u32),
                                                              _sp_runtime::Perbill::from_parts(25202000u32)),
                                                             (_sp_runtime::Perbill::from_parts(941413000u32),
                                                              _sp_runtime::Perbill::from_parts(25165000u32)),
                                                             (_sp_runtime::Perbill::from_parts(955889000u32),
                                                              _sp_runtime::Perbill::from_parts(25135000u32)),
                                                             (_sp_runtime::Perbill::from_parts(970009000u32),
                                                              _sp_runtime::Perbill::from_parts(25111000u32)),
                                                             (_sp_runtime::Perbill::from_parts(984340000u32),
                                                              _sp_runtime::Perbill::from_parts(25091000u32)),
                                                             (_sp_runtime::Perbill::from_parts(998289000u32),
                                                              _sp_runtime::Perbill::from_parts(25075000u32)),
                                                             (_sp_runtime::Perbill::from_parts(1000000000u32),
                                                              _sp_runtime::Perbill::from_parts(25073000u32))],
                                                       maximum:
                                                           _sp_runtime::Perbill::from_parts(100000000u32),}
    };
pub struct SessionsPerEra;
impl SessionsPerEra {
    pub fn get() -> sp_staking::SessionIndex { 6 }
}
impl <I: From<sp_staking::SessionIndex>> ::frame_support::traits::Get<I> for
 SessionsPerEra {
    fn get() -> I { I::from(6) }
}
pub struct BondingDuration;
impl BondingDuration {
    pub fn get() -> staking::EraIndex { 24 * 28 }
}
impl <I: From<staking::EraIndex>> ::frame_support::traits::Get<I> for
 BondingDuration {
    fn get() -> I { I::from(24 * 28) }
}
pub struct SlashDeferDuration;
impl SlashDeferDuration {
    pub fn get() -> staking::EraIndex { 24 * 7 }
}
impl <I: From<staking::EraIndex>> ::frame_support::traits::Get<I> for
 SlashDeferDuration {
    fn get() -> I { I::from(24 * 7) }
}
pub struct RewardCurve;
impl RewardCurve {
    pub fn get() -> &'static PiecewiseLinear<'static> { &REWARD_CURVE }
}
impl <I: From<&'static PiecewiseLinear<'static>>>
 ::frame_support::traits::Get<I> for RewardCurve {
    fn get() -> I { I::from(&REWARD_CURVE) }
}
impl staking::Trait for Runtime {
    type
    Currency
    =
    Balances;
    type
    Time
    =
    Timestamp;
    type
    CurrencyToVote
    =
    CurrencyToVoteHandler;
    type
    RewardRemainder
    =
    Treasury;
    type
    Event
    =
    Event;
    type
    Slash
    =
    Treasury;
    type
    Reward
    =
    ();
    type
    SessionsPerEra
    =
    SessionsPerEra;
    type
    BondingDuration
    =
    BondingDuration;
    type
    SlashDeferDuration
    =
    SlashDeferDuration;
    /// A super-majority of the council can cancel the slash.
    type
    SlashCancelOrigin
    =
    collective::EnsureProportionAtLeast<_3, _4, AccountId, CouncilCollective>;
    type
    SessionInterface
    =
    Self;
    type
    RewardCurve
    =
    RewardCurve;
}
pub struct LaunchPeriod;
impl LaunchPeriod {
    pub fn get() -> BlockNumber { 28 * 24 * 60 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for LaunchPeriod {
    fn get() -> I { I::from(28 * 24 * 60 * MINUTES) }
}
pub struct VotingPeriod;
impl VotingPeriod {
    pub fn get() -> BlockNumber { 28 * 24 * 60 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for VotingPeriod {
    fn get() -> I { I::from(28 * 24 * 60 * MINUTES) }
}
pub struct EmergencyVotingPeriod;
impl EmergencyVotingPeriod {
    pub fn get() -> BlockNumber { 3 * 24 * 60 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 EmergencyVotingPeriod {
    fn get() -> I { I::from(3 * 24 * 60 * MINUTES) }
}
pub struct MinimumDeposit;
impl MinimumDeposit {
    pub fn get() -> Balance { 100 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for MinimumDeposit {
    fn get() -> I { I::from(100 * DOLLARS) }
}
pub struct EnactmentPeriod;
impl EnactmentPeriod {
    pub fn get() -> BlockNumber { 30 * 24 * 60 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 EnactmentPeriod {
    fn get() -> I { I::from(30 * 24 * 60 * MINUTES) }
}
pub struct CooloffPeriod;
impl CooloffPeriod {
    pub fn get() -> BlockNumber { 28 * 24 * 60 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for CooloffPeriod
 {
    fn get() -> I { I::from(28 * 24 * 60 * MINUTES) }
}
pub struct PreimageByteDeposit;
impl PreimageByteDeposit {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 PreimageByteDeposit {
    fn get() -> I { I::from(1 * CENTS) }
}
impl democracy::Trait for Runtime {
    type
    Proposal
    =
    Call;
    type
    Event
    =
    Event;
    type
    Currency
    =
    Balances;
    type
    EnactmentPeriod
    =
    EnactmentPeriod;
    type
    LaunchPeriod
    =
    LaunchPeriod;
    type
    VotingPeriod
    =
    VotingPeriod;
    type
    EmergencyVotingPeriod
    =
    EmergencyVotingPeriod;
    type
    MinimumDeposit
    =
    MinimumDeposit;
    /// A straight majority of the council can decide what their next motion is.
    type
    ExternalOrigin
    =
    collective::EnsureProportionAtLeast<_1, _2, AccountId, CouncilCollective>;
    /// A super-majority can have the next scheduled referendum be a straight majority-carries vote.
    type
    ExternalMajorityOrigin
    =
    collective::EnsureProportionAtLeast<_3, _4, AccountId, CouncilCollective>;
    /// A unanimous council can have the next scheduled referendum be a straight default-carries
    /// (NTB) vote.
    type
    ExternalDefaultOrigin
    =
    collective::EnsureProportionAtLeast<_1, _1, AccountId, CouncilCollective>;
    /// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote
    /// be tabled immediately and with a shorter voting/enactment period.
    type
    FastTrackOrigin
    =
    collective::EnsureProportionAtLeast<_2, _3, AccountId,
                                        TechnicalCollective>;
    type
    CancellationOrigin
    =
    collective::EnsureProportionAtLeast<_2, _3, AccountId, CouncilCollective>;
    type
    VetoOrigin
    =
    collective::EnsureMember<AccountId, TechnicalCollective>;
    type
    CooloffPeriod
    =
    CooloffPeriod;
    type
    PreimageByteDeposit
    =
    PreimageByteDeposit;
    type
    Slash
    =
    Treasury;
}
type CouncilCollective = collective::Instance1;
impl collective::Trait<CouncilCollective> for Runtime {
    type
    Origin
    =
    Origin;
    type
    Proposal
    =
    Call;
    type
    Event
    =
    Event;
}
pub struct CandidacyBond;
impl CandidacyBond {
    pub fn get() -> Balance { 10 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for CandidacyBond {
    fn get() -> I { I::from(10 * DOLLARS) }
}
pub struct VotingBond;
impl VotingBond {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for VotingBond {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct TermDuration;
impl TermDuration {
    pub fn get() -> BlockNumber { 7 * DAYS }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for TermDuration {
    fn get() -> I { I::from(7 * DAYS) }
}
pub struct DesiredMembers;
impl DesiredMembers {
    pub fn get() -> u32 { 13 }
}
impl <I: From<u32>> ::frame_support::traits::Get<I> for DesiredMembers {
    fn get() -> I { I::from(13) }
}
pub struct DesiredRunnersUp;
impl DesiredRunnersUp {
    pub fn get() -> u32 { 7 }
}
impl <I: From<u32>> ::frame_support::traits::Get<I> for DesiredRunnersUp {
    fn get() -> I { I::from(7) }
}
impl elections_phragmen::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    Currency2
    =
    Balances;
    type
    CurrencyToVote
    =
    CurrencyToVoteHandler;
    type
    CandidacyBond
    =
    CandidacyBond;
    type
    VotingBond
    =
    VotingBond;
    type
    TermDuration
    =
    TermDuration;
    type
    DesiredMembers
    =
    DesiredMembers;
    type
    DesiredRunnersUp
    =
    DesiredRunnersUp;
    type
    LoserCandidate
    =
    ();
    type
    BadReport
    =
    ();
    type
    KickedMember
    =
    ();
    type
    ChangeMembers
    =
    Council;
}
type TechnicalCollective = collective::Instance2;
impl collective::Trait<TechnicalCollective> for Runtime {
    type
    Origin
    =
    Origin;
    type
    Proposal
    =
    Call;
    type
    Event
    =
    Event;
}
impl membership::Trait<membership::Instance1> for Runtime {
    type
    Event
    =
    Event;
    type
    AddOrigin
    =
    collective::EnsureProportionMoreThan<_1, _2, AccountId,
                                         CouncilCollective>;
    type
    RemoveOrigin
    =
    collective::EnsureProportionMoreThan<_1, _2, AccountId,
                                         CouncilCollective>;
    type
    SwapOrigin
    =
    collective::EnsureProportionMoreThan<_1, _2, AccountId,
                                         CouncilCollective>;
    type
    ResetOrigin
    =
    collective::EnsureProportionMoreThan<_1, _2, AccountId,
                                         CouncilCollective>;
    type
    MembershipInitialized
    =
    TechnicalCommittee;
    type
    MembershipChanged
    =
    TechnicalCommittee;
}
pub struct ProposalBond;
impl ProposalBond {
    pub fn get() -> Permill { Permill::from_percent(5) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for ProposalBond {
    fn get() -> I { I::from(Permill::from_percent(5)) }
}
pub struct ProposalBondMinimum;
impl ProposalBondMinimum {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 ProposalBondMinimum {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct SpendPeriod;
impl SpendPeriod {
    pub fn get() -> BlockNumber { 1 * DAYS }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for SpendPeriod {
    fn get() -> I { I::from(1 * DAYS) }
}
pub struct Burn;
impl Burn {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for Burn {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
impl treasury::Trait for Runtime {
    type
    Currency
    =
    Balances;
    type
    ApproveOrigin
    =
    collective::EnsureMembers<_4, AccountId, CouncilCollective>;
    type
    RejectOrigin
    =
    collective::EnsureMembers<_2, AccountId, CouncilCollective>;
    type
    Event
    =
    Event;
    type
    ProposalRejection
    =
    ();
    type
    ProposalBond
    =
    ProposalBond;
    type
    ProposalBondMinimum
    =
    ProposalBondMinimum;
    type
    SpendPeriod
    =
    SpendPeriod;
    type
    Burn
    =
    Burn;
}
impl register::Trait for Runtime {
    type
    PledgeAmount
    =
    PledgeAmount;
    type
    Event
    =
    Event;
    type
    Currency1
    =
    Balances;
}
pub struct ProposalExpire;
impl ProposalExpire {
    pub fn get() -> BlockNumber { 7 * DAYS }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for ProposalExpire
 {
    fn get() -> I { I::from(7 * DAYS) }
}
pub struct VoteRewardPeriod;
impl VoteRewardPeriod {
    pub fn get() -> BlockNumber { 1 * DAYS }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 VoteRewardPeriod {
    fn get() -> I { I::from(1 * DAYS) }
}
pub struct ReportReserve;
impl ReportReserve {
    pub fn get() -> Balance { 10 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for ReportReserve {
    fn get() -> I { I::from(10 * DOLLARS) }
}
pub struct ReportReward;
impl ReportReward {
    pub fn get() -> Balance { 250 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for ReportReward {
    fn get() -> I { I::from(250 * DOLLARS) }
}
pub struct IllegalPunishment;
impl IllegalPunishment {
    pub fn get() -> Balance { 500 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for IllegalPunishment
 {
    fn get() -> I { I::from(500 * DOLLARS) }
}
pub struct CouncilReward;
impl CouncilReward {
    pub fn get() -> Balance { 10 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for CouncilReward {
    fn get() -> I { I::from(10 * DOLLARS) }
}
pub struct Threshould;
impl Threshould {
    pub fn get() -> u32 { 7 }
}
impl <I: From<u32>> ::frame_support::traits::Get<I> for Threshould {
    fn get() -> I { I::from(7) }
}
impl report::Trait for Runtime {
    type
    Thredshould
    =
    Threshould;
    type
    ConcilOrigin
    =
    collective::EnsureMember<AccountId, CouncilCollective>;
    type
    Currency0
    =
    Balances;
    type
    ProposalExpire
    =
    ProposalExpire;
    type
    VoteRewardPeriod
    =
    VoteRewardPeriod;
    type
    ReportReserve
    =
    ReportReserve;
    type
    IllegalPunishment
    =
    IllegalPunishment;
    type
    CouncilReward
    =
    CouncilReward;
    type
    ReportReward
    =
    ReportReward;
    type
    Event
    =
    Event;
}
pub struct ContractTransferFee;
impl ContractTransferFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 ContractTransferFee {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct ContractCreationFee;
impl ContractCreationFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 ContractCreationFee {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct ContractTransactionBaseFee;
impl ContractTransactionBaseFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 ContractTransactionBaseFee {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct ContractTransactionByteFee;
impl ContractTransactionByteFee {
    pub fn get() -> Balance { 10 * MILLICENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for
 ContractTransactionByteFee {
    fn get() -> I { I::from(10 * MILLICENTS) }
}
pub struct ContractFee;
impl ContractFee {
    pub fn get() -> Balance { 1 * CENTS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for ContractFee {
    fn get() -> I { I::from(1 * CENTS) }
}
pub struct TombstoneDeposit;
impl TombstoneDeposit {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for TombstoneDeposit {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct RentByteFee;
impl RentByteFee {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for RentByteFee {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct RentDepositOffset;
impl RentDepositOffset {
    pub fn get() -> Balance { 1000 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for RentDepositOffset
 {
    fn get() -> I { I::from(1000 * DOLLARS) }
}
pub struct SurchargeReward;
impl SurchargeReward {
    pub fn get() -> Balance { 150 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for SurchargeReward {
    fn get() -> I { I::from(150 * DOLLARS) }
}
impl contracts::Trait for Runtime {
    type
    Currency
    =
    Balances;
    type
    Time
    =
    Timestamp;
    type
    Randomness
    =
    RandomnessCollectiveFlip;
    type
    Call
    =
    Call;
    type
    Event
    =
    Event;
    type
    DetermineContractAddress
    =
    contracts::SimpleAddressDeterminator<Runtime>;
    type
    ComputeDispatchFee
    =
    contracts::DefaultDispatchFeeComputor<Runtime>;
    type
    TrieIdGenerator
    =
    contracts::TrieIdFromParentCounter<Runtime>;
    type
    GasPayment
    =
    ();
    type
    RentPayment
    =
    ();
    type
    SignedClaimHandicap
    =
    contracts::DefaultSignedClaimHandicap;
    type
    TombstoneDeposit
    =
    TombstoneDeposit;
    type
    StorageSizeOffset
    =
    contracts::DefaultStorageSizeOffset;
    type
    RentByteFee
    =
    RentByteFee;
    type
    RentDepositOffset
    =
    RentDepositOffset;
    type
    SurchargeReward
    =
    SurchargeReward;
    type
    TransferFee
    =
    ContractTransferFee;
    type
    CreationFee
    =
    ContractCreationFee;
    type
    TransactionBaseFee
    =
    ContractTransactionBaseFee;
    type
    TransactionByteFee
    =
    ContractTransactionByteFee;
    type
    ContractFee
    =
    ContractFee;
    type
    CallBaseFee
    =
    contracts::DefaultCallBaseFee;
    type
    InstantiateBaseFee
    =
    contracts::DefaultInstantiateBaseFee;
    type
    MaxDepth
    =
    contracts::DefaultMaxDepth;
    type
    MaxValueSize
    =
    contracts::DefaultMaxValueSize;
    type
    BlockGasLimit
    =
    contracts::DefaultBlockGasLimit;
}
impl sudo::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    Proposal
    =
    Call;
}
type SubmitTransaction
    =
    TransactionSubmitter<ImOnlineId, Runtime, UncheckedExtrinsic>;
pub struct SessionDuration;
impl SessionDuration {
    pub fn get() -> BlockNumber { EPOCH_DURATION_IN_SLOTS as _ }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 SessionDuration {
    fn get() -> I { I::from(EPOCH_DURATION_IN_SLOTS as _) }
}
impl im_online::Trait for Runtime {
    type
    AuthorityId
    =
    ImOnlineId;
    type
    Call
    =
    Call;
    type
    Event
    =
    Event;
    type
    SubmitTransaction
    =
    SubmitTransaction;
    type
    ReportUnresponsiveness
    =
    Offences;
    type
    SessionDuration
    =
    SessionDuration;
}
impl offences::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    IdentificationTuple
    =
    session::historical::IdentificationTuple<Self>;
    type
    OnOffenceHandler
    =
    Staking;
}
impl authority_discovery::Trait for Runtime { }
impl grandpa::Trait for Runtime {
    type
    Event
    =
    Event;
}
pub struct WindowSize;
impl WindowSize {
    pub fn get() -> BlockNumber { 101 }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for WindowSize {
    fn get() -> I { I::from(101) }
}
pub struct ReportLatency;
impl ReportLatency {
    pub fn get() -> BlockNumber { 1000 }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for ReportLatency
 {
    fn get() -> I { I::from(1000) }
}
impl finality_tracker::Trait for Runtime {
    type
    OnFinalizationStalled
    =
    Grandpa;
    type
    WindowSize
    =
    WindowSize;
    type
    ReportLatency
    =
    ReportLatency;
}
pub struct ReservationFee;
impl ReservationFee {
    pub fn get() -> Balance { 1 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for ReservationFee {
    fn get() -> I { I::from(1 * DOLLARS) }
}
pub struct MinLength;
impl MinLength {
    pub fn get() -> usize { 3 }
}
impl <I: From<usize>> ::frame_support::traits::Get<I> for MinLength {
    fn get() -> I { I::from(3) }
}
pub struct MaxLength;
impl MaxLength {
    pub fn get() -> usize { 16 }
}
impl <I: From<usize>> ::frame_support::traits::Get<I> for MaxLength {
    fn get() -> I { I::from(16) }
}
impl nicks::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    Currency
    =
    Balances;
    type
    ReservationFee
    =
    ReservationFee;
    type
    Slashed
    =
    Treasury;
    type
    ForceOrigin
    =
    collective::EnsureMember<AccountId, CouncilCollective>;
    type
    MinLength
    =
    MinLength;
    type
    MaxLength
    =
    MaxLength;
}
impl system::offchain::CreateTransaction<Runtime, UncheckedExtrinsic> for
 Runtime {
    type
    Public
    =
    <Signature as traits::Verify>::Signer;
    type
    Signature
    =
    Signature;
    fn create_transaction<TSigner: system::offchain::Signer<Self::Public,
                                                            Self::Signature>>(call:
                                                                                  Call,
                                                                              public:
                                                                                  Self::Public,
                                                                              account:
                                                                                  AccountId,
                                                                              index:
                                                                                  Index)
     ->
         Option<(Call,
                 <UncheckedExtrinsic as
                 traits::Extrinsic>::SignaturePayload)> {
        let period = 1 << 8;
        let current_block = System::block_number().saturated_into::<u64>();
        let tip = 0;
        let extra: SignedExtra =
            (system::CheckVersion::<Runtime>::new(),
             system::CheckGenesis::<Runtime>::new(),
             system::CheckEra::<Runtime>::from(generic::Era::mortal(period,
                                                                    current_block)),
             system::CheckNonce::<Runtime>::from(index),
             system::CheckWeight::<Runtime>::new(),
             transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
             Default::default());
        let raw_payload = SignedPayload::new(call, extra).ok()?;
        let signature = TSigner::sign(public, &raw_payload)?;
        let address = Indices::unlookup(account);
        let (call, extra, _) = raw_payload.deconstruct();
        Some((call, (address, signature, extra)))
    }
}
pub struct BTCLimitCount;
impl BTCLimitCount {
    pub fn get() -> Count { 100 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for BTCLimitCount {
    fn get() -> I { I::from(100) }
}
pub struct ETHLimitCount;
impl ETHLimitCount {
    pub fn get() -> Count { 200 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for ETHLimitCount {
    fn get() -> I { I::from(200) }
}
pub struct EOSLimitCount;
impl EOSLimitCount {
    pub fn get() -> Count { 1000 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for EOSLimitCount {
    fn get() -> I { I::from(1000) }
}
pub struct USDTLimitCount;
impl USDTLimitCount {
    pub fn get() -> Count { 100 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for USDTLimitCount {
    fn get() -> I { I::from(100) }
}
pub struct DCEPLimitCount;
impl DCEPLimitCount {
    pub fn get() -> Count { 2000 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for DCEPLimitCount {
    fn get() -> I { I::from(2000) }
}
pub struct DOTLimitCount;
impl DOTLimitCount {
    pub fn get() -> Count { 500 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for DOTLimitCount {
    fn get() -> I { I::from(500) }
}
pub struct DashLimitCount;
impl DashLimitCount {
    pub fn get() -> Count { 50 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for DashLimitCount {
    fn get() -> I { I::from(50) }
}
pub struct ADALimitCount;
impl ADALimitCount {
    pub fn get() -> Count { 100 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for ADALimitCount {
    fn get() -> I { I::from(100) }
}
pub struct DCAPLimitCount;
impl DCAPLimitCount {
    pub fn get() -> Count { 4000 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for DCAPLimitCount {
    fn get() -> I { I::from(4000) }
}
pub struct TUSDTLimitCount;
impl TUSDTLimitCount {
    pub fn get() -> Count { 4000 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for TUSDTLimitCount {
    fn get() -> I { I::from(4000) }
}
pub struct BTCMaxPortion;
impl BTCMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(70) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for BTCMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(70)) }
}
pub struct ETHMaxPortion;
impl ETHMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(10) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for ETHMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(10)) }
}
pub struct EOSMaxPortion;
impl EOSMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(8) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for EOSMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(8)) }
}
pub struct USDTMaxPortion;
impl USDTMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for USDTMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct DCEPaxPortion;
impl DCEPaxPortion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for DCEPaxPortion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct DOTMaxPortion;
impl DOTMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(10) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for DOTMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(10)) }
}
pub struct DashMaxPortion;
impl DashMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(5) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for DashMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(5)) }
}
pub struct ADAMaxPortion;
impl ADAMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(5) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for ADAMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(5)) }
}
pub struct DCAPMaxPortion;
impl DCAPMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for DCAPMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct TUSDTMaxPortion;
impl TUSDTMaxPortion {
    pub fn get() -> Permill { Permill::from_percent(70) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for TUSDTMaxPortion {
    fn get() -> I { I::from(Permill::from_percent(70)) }
}
pub struct BTCLimitAmount;
impl BTCLimitAmount {
    pub fn get() -> USD { 100000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for BTCLimitAmount {
    fn get() -> I { I::from(100000) }
}
pub struct ETHLimitAmount;
impl ETHLimitAmount {
    pub fn get() -> USD { 50000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for ETHLimitAmount {
    fn get() -> I { I::from(50000) }
}
pub struct EOSLimitAmount;
impl EOSLimitAmount {
    pub fn get() -> USD { 50000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for EOSLimitAmount {
    fn get() -> I { I::from(50000) }
}
pub struct USDTLimitAmount;
impl USDTLimitAmount {
    pub fn get() -> USD { 100000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for USDTLimitAmount {
    fn get() -> I { I::from(100000) }
}
pub struct DCEPLimitAmount;
impl DCEPLimitAmount {
    pub fn get() -> USD { 1000000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DCEPLimitAmount {
    fn get() -> I { I::from(1000000) }
}
pub struct DOTLimitAmount;
impl DOTLimitAmount {
    pub fn get() -> USD { 50000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DOTLimitAmount {
    fn get() -> I { I::from(50000) }
}
pub struct DashLimitAmount;
impl DashLimitAmount {
    pub fn get() -> USD { 20000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DashLimitAmount {
    fn get() -> I { I::from(20000) }
}
pub struct ADALimitAmount;
impl ADALimitAmount {
    pub fn get() -> USD { 20000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for ADALimitAmount {
    fn get() -> I { I::from(20000) }
}
pub struct DCAPLimitAmount;
impl DCAPLimitAmount {
    pub fn get() -> USD { 2000000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DCAPLimitAmount {
    fn get() -> I { I::from(2000000) }
}
pub struct TUSDTLimitAmount;
impl TUSDTLimitAmount {
    pub fn get() -> USD { 2000000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for TUSDTLimitAmount {
    fn get() -> I { I::from(2000000) }
}
pub struct BTCMaxLimitAmount;
impl BTCMaxLimitAmount {
    pub fn get() -> USD { 100000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for BTCMaxLimitAmount {
    fn get() -> I { I::from(100000) }
}
pub struct ETHMaxLimitAmount;
impl ETHMaxLimitAmount {
    pub fn get() -> USD { 40000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for ETHMaxLimitAmount {
    fn get() -> I { I::from(40000) }
}
pub struct EOSMaxLimitAmount;
impl EOSMaxLimitAmount {
    pub fn get() -> USD { 10000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for EOSMaxLimitAmount {
    fn get() -> I { I::from(10000) }
}
pub struct USDTMaxLimitAmount;
impl USDTMaxLimitAmount {
    pub fn get() -> USD { 50000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for USDTMaxLimitAmount {
    fn get() -> I { I::from(50000) }
}
pub struct DCEPMaxLimitAmount;
impl DCEPMaxLimitAmount {
    pub fn get() -> USD { 5000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DCEPMaxLimitAmount {
    fn get() -> I { I::from(5000) }
}
pub struct DOTMaxLimitAmount;
impl DOTMaxLimitAmount {
    pub fn get() -> USD { 20000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DOTMaxLimitAmount {
    fn get() -> I { I::from(20000) }
}
pub struct DashMaxLimitAmount;
impl DashMaxLimitAmount {
    pub fn get() -> USD { 5000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DashMaxLimitAmount {
    fn get() -> I { I::from(5000) }
}
pub struct ADAMaxLimitAmount;
impl ADAMaxLimitAmount {
    pub fn get() -> USD { 5000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for ADAMaxLimitAmount {
    fn get() -> I { I::from(5000) }
}
pub struct DCAPMaxLimitAmount;
impl DCAPMaxLimitAmount {
    pub fn get() -> USD { 10000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for DCAPMaxLimitAmount {
    fn get() -> I { I::from(10000) }
}
pub struct TUSDTMaxLimitAmount;
impl TUSDTMaxLimitAmount {
    pub fn get() -> USD { 50000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for TUSDTMaxLimitAmount {
    fn get() -> I { I::from(50000) }
}
pub struct InitialTotalCount;
impl InitialTotalCount {
    pub fn get() -> Count { 10000 }
}
impl <I: From<Count>> ::frame_support::traits::Get<I> for InitialTotalCount {
    fn get() -> I { I::from(10000) }
}
pub struct InitialTotalAmount;
impl InitialTotalAmount {
    pub fn get() -> USD { 1000000 }
}
impl <I: From<USD>> ::frame_support::traits::Get<I> for InitialTotalAmount {
    fn get() -> I { I::from(1000000) }
}
pub struct InitialTotalWorkforce;
impl InitialTotalWorkforce {
    pub fn get() -> Workforce { Permill::from_percent(70) }
}
impl <I: From<Workforce>> ::frame_support::traits::Get<I> for
 InitialTotalWorkforce {
    fn get() -> I { I::from(Permill::from_percent(70)) }
}
pub struct FrequencyWorkforceProportion;
impl FrequencyWorkforceProportion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 FrequencyWorkforceProportion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct AmountWorkforceProportion;
impl AmountWorkforceProportion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 AmountWorkforceProportion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct SenderWorkforceProportion;
impl SenderWorkforceProportion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 SenderWorkforceProportion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct ReceiverWorkforceProportion;
impl ReceiverWorkforceProportion {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 ReceiverWorkforceProportion {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct SuperiorShareRatio;
impl SuperiorShareRatio {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for SuperiorShareRatio
 {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct OnsuperiorShareRatio;
impl OnsuperiorShareRatio {
    pub fn get() -> Permill { Permill::from_percent(25) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 OnsuperiorShareRatio {
    fn get() -> I { I::from(Permill::from_percent(25)) }
}
pub struct DailyMinimumReward;
impl DailyMinimumReward {
    pub fn get() -> Balance { 1000 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for DailyMinimumReward
 {
    fn get() -> I { I::from(1000 * DOLLARS) }
}
pub struct MinerSharefeeRatio;
impl MinerSharefeeRatio {
    pub fn get() -> Permill { Permill::from_percent(50) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for MinerSharefeeRatio
 {
    fn get() -> I { I::from(Permill::from_percent(50)) }
}
pub struct PledgeAmount;
impl PledgeAmount {
    pub fn get() -> Balance { 500 * DOLLARS }
}
impl <I: From<Balance>> ::frame_support::traits::Get<I> for PledgeAmount {
    fn get() -> I { I::from(500 * DOLLARS) }
}
pub struct SettlePeriodBlock;
impl SettlePeriodBlock {
    pub fn get() -> BlockNumber { 28800 }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 SettlePeriodBlock {
    fn get() -> I { I::from(28800) }
}
pub struct FoundingTeamProportion;
impl FoundingTeamProportion {
    pub fn get() -> Permill { Permill::from_percent(10) }
}
impl <I: From<Permill>> ::frame_support::traits::Get<I> for
 FoundingTeamProportion {
    fn get() -> I { I::from(Permill::from_percent(10)) }
}
/// Used for the module transx in `./transx.rs`
impl transx::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    Currency
    =
    Balances;
    type
    BTCLimitCount
    =
    BTCLimitCount;
    type
    ETHLimitCount
    =
    ETHLimitCount;
    type
    EOSLimitCount
    =
    EOSLimitCount;
    type
    USDTLimitCount
    =
    USDTLimitCount;
    type
    DCEPLimitCount
    =
    DCEPLimitCount;
    type
    DOTLimitCount
    =
    DOTLimitCount;
    type
    DashLimitCount
    =
    DashLimitCount;
    type
    ADALimitCount
    =
    ADALimitCount;
    type
    DCAPLimitCount
    =
    DCAPLimitCount;
    type
    TUSDTLimitCount
    =
    TUSDTLimitCount;
    type
    BTCMaxPortion
    =
    BTCMaxPortion;
    type
    ETHMaxPortion
    =
    ETHMaxPortion;
    type
    EOSMaxPortion
    =
    EOSMaxPortion;
    type
    USDTMaxPortion
    =
    USDTMaxPortion;
    type
    DCEPaxPortion
    =
    DCEPaxPortion;
    type
    DOTMaxPortion
    =
    DOTMaxPortion;
    type
    DashMaxPortion
    =
    DashMaxPortion;
    type
    ADAMaxPortion
    =
    ADAMaxPortion;
    type
    DCAPMaxPortion
    =
    DCAPMaxPortion;
    type
    TUSDTMaxPortion
    =
    TUSDTMaxPortion;
    type
    BTCLimitAmount
    =
    BTCLimitAmount;
    type
    ETHLimitAmount
    =
    ETHLimitAmount;
    type
    EOSLimitAmount
    =
    EOSLimitAmount;
    type
    USDTLimitAmount
    =
    USDTLimitAmount;
    type
    DCEPLimitAmount
    =
    DCEPLimitAmount;
    type
    DOTLimitAmount
    =
    DOTLimitAmount;
    type
    DashLimitAmount
    =
    DashLimitAmount;
    type
    ADALimitAmount
    =
    ADALimitAmount;
    type
    DCAPLimitAmount
    =
    DCAPLimitAmount;
    type
    TUSDTLimitAmount
    =
    TUSDTLimitAmount;
    type
    BTCMaxLimitAmount
    =
    BTCMaxLimitAmount;
    type
    ETHMaxLimitAmount
    =
    ETHMaxLimitAmount;
    type
    EOSMaxLimitAmount
    =
    EOSMaxLimitAmount;
    type
    USDTMaxLimitAmount
    =
    USDTMaxLimitAmount;
    type
    DCEPMaxLimitAmount
    =
    DCEPMaxLimitAmount;
    type
    DOTMaxLimitAmount
    =
    DOTMaxLimitAmount;
    type
    DashMaxLimitAmount
    =
    DashMaxLimitAmount;
    type
    ADAMaxLimitAmount
    =
    ADAMaxLimitAmount;
    type
    DCAPMaxLimitAmount
    =
    DCAPMaxLimitAmount;
    type
    TUSDTMaxLimitAmount
    =
    TUSDTMaxLimitAmount;
    type
    InitialTotalCount
    =
    InitialTotalCount;
    type
    InitialTotalAmount
    =
    InitialTotalAmount;
    type
    InitialTotalWorkforce
    =
    InitialTotalWorkforce;
    type
    FrequencyWorkforceProportion
    =
    FrequencyWorkforceProportion;
    type
    AmountWorkforceProportion
    =
    AmountWorkforceProportion;
    type
    SenderWorkforceProportion
    =
    SenderWorkforceProportion;
    type
    ReceiverWorkforceProportion
    =
    ReceiverWorkforceProportion;
    type
    SuperiorShareRatio
    =
    SuperiorShareRatio;
    type
    OnsuperiorShareRatio
    =
    OnsuperiorShareRatio;
    type
    DailyMinimumReward
    =
    DailyMinimumReward;
    type
    MinerSharefeeRatio
    =
    MinerSharefeeRatio;
    type
    PledgeAmount
    =
    PledgeAmount;
    type
    SettlePeriodBlock
    =
    SettlePeriodBlock;
    type
    FoundingTeamProportion
    =
    FoundingTeamProportion;
}
pub struct TranRuntime;
impl TranRuntime {
    pub fn get() -> Runtime { Runtime }
}
impl <I: From<Runtime>> ::frame_support::traits::Get<I> for TranRuntime {
    fn get() -> I { I::from(Runtime) }
}
impl mine::Trait for Runtime {
    type
    Event
    =
    Event;
    type
    MineIndex
    =
    u64;
}
pub struct ArchiveDuration;
impl ArchiveDuration {
    pub fn get() -> BlockNumber { 10 * MINUTES }
}
impl <I: From<BlockNumber>> ::frame_support::traits::Get<I> for
 ArchiveDuration {
    fn get() -> I { I::from(10 * MINUTES) }
}
#[doc(hidden)]
mod sp_api_hidden_includes_construct_runtime {
    pub extern crate support as hidden_include;
}
pub struct Runtime;
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Runtime {
    #[inline]
    fn clone(&self) -> Runtime { { *self } }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for Runtime { }
impl ::core::marker::StructuralPartialEq for Runtime { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Runtime {
    #[inline]
    fn eq(&self, other: &Runtime) -> bool {
        match *other { Runtime => match *self { Runtime => true, }, }
    }
}
impl ::core::marker::StructuralEq for Runtime { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Runtime {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () { { } }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Runtime {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Runtime => {
                let mut debug_trait_builder = f.debug_tuple("Runtime");
                debug_trait_builder.finish()
            }
        }
    }
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::GetNodeBlockType
 for Runtime {
    type
    NodeBlock
    =
    node_primitives::Block;
}
impl self::sp_api_hidden_includes_construct_runtime::hidden_include::sp_runtime::traits::GetRuntimeBlockType
 for Runtime {
    type
    RuntimeBlock
    =
    Block;
}
#[allow(non_camel_case_types)]
pub enum Event {
    system(system::Event),
    utility(utility::Event<>),
    indices(indices::Event<Runtime>),
    balances(balances::Event<Runtime>),
    staking(staking::Event<Runtime>),
    session(session::Event<>),
    democracy(democracy::Event<Runtime>),
    collective_Instance1(collective::Event<Runtime, collective::Instance1>),
    collective_Instance2(collective::Event<Runtime, collective::Instance2>),
    elections_phragmen(elections_phragmen::Event<Runtime>),
    membership_Instance1(membership::Event<Runtime, membership::Instance1>),
    grandpa(grandpa::Event<>),
    treasury(treasury::Event<Runtime>),
    contracts(contracts::Event<Runtime>),
    sudo(sudo::Event<Runtime>),
    im_online(im_online::Event<Runtime>),
    offences(offences::Event<>),
    nicks(nicks::Event<Runtime>),
    transx(transx::Event<Runtime>),
    register(register::Event<Runtime>),
    mine(mine::Event<Runtime>),
    report(report::Event<Runtime>),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::clone::Clone for Event {
    #[inline]
    fn clone(&self) -> Event {
        match (&*self,) {
            (&Event::system(ref __self_0),) =>
            Event::system(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::utility(ref __self_0),) =>
            Event::utility(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::indices(ref __self_0),) =>
            Event::indices(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::balances(ref __self_0),) =>
            Event::balances(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::staking(ref __self_0),) =>
            Event::staking(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::session(ref __self_0),) =>
            Event::session(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::democracy(ref __self_0),) =>
            Event::democracy(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::collective_Instance1(ref __self_0),) =>
            Event::collective_Instance1(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::collective_Instance2(ref __self_0),) =>
            Event::collective_Instance2(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::elections_phragmen(ref __self_0),) =>
            Event::elections_phragmen(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::membership_Instance1(ref __self_0),) =>
            Event::membership_Instance1(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::grandpa(ref __self_0),) =>
            Event::grandpa(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::treasury(ref __self_0),) =>
            Event::treasury(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::contracts(ref __self_0),) =>
            Event::contracts(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::sudo(ref __self_0),) =>
            Event::sudo(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::im_online(ref __self_0),) =>
            Event::im_online(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::offences(ref __self_0),) =>
            Event::offences(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::nicks(ref __self_0),) =>
            Event::nicks(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::transx(ref __self_0),) =>
            Event::transx(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::register(ref __self_0),) =>
            Event::register(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::mine(ref __self_0),) =>
            Event::mine(::core::clone::Clone::clone(&(*__self_0))),
            (&Event::report(ref __self_0),) =>
            Event::report(::core::clone::Clone::clone(&(*__self_0))),
        }
    }
}
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralPartialEq for Event { }
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::cmp::PartialEq for Event {
    #[inline]
    fn eq(&self, other: &Event) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Event::system(ref __self_0),
                     &Event::system(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::utility(ref __self_0),
                     &Event::utility(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::indices(ref __self_0),
                     &Event::indices(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::balances(ref __self_0),
                     &Event::balances(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::staking(ref __self_0),
                     &Event::staking(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::session(ref __self_0),
                     &Event::session(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::democracy(ref __self_0),
                     &Event::democracy(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::collective_Instance1(ref __self_0),
                     &Event::collective_Instance1(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::collective_Instance2(ref __self_0),
                     &Event::collective_Instance2(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::elections_phragmen(ref __self_0),
                     &Event::elections_phragmen(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::membership_Instance1(ref __self_0),
                     &Event::membership_Instance1(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::grandpa(ref __self_0),
                     &Event::grandpa(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::treasury(ref __self_0),
                     &Event::treasury(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::contracts(ref __self_0),
                     &Event::contracts(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::sudo(ref __self_0), &Event::sudo(ref __arg_1_0))
                    => (*__self_0) == (*__arg_1_0),
                    (&Event::im_online(ref __self_0),
                     &Event::im_online(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::offences(ref __self_0),
                     &Event::offences(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::nicks(ref __self_0),
                     &Event::nicks(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::transx(ref __self_0),
                     &Event::transx(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::register(ref __self_0),
                     &Event::register(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Event::mine(ref __self_0), &Event::mine(ref __arg_1_0))
                    => (*__self_0) == (*__arg_1_0),
                    (&Event::report(ref __self_0),
                     &Event::report(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { false }
        }
    }
    #[inline]
    fn ne(&self, other: &Event) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Event::system(ref __self_0),
                     &Event::system(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::utility(ref __self_0),
                     &Event::utility(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::indices(ref __self_0),
                     &Event::indices(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::balances(ref __self_0),
                     &Event::balances(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::staking(ref __self_0),
                     &Event::staking(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::session(ref __self_0),
                     &Event::session(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::democracy(ref __self_0),
                     &Event::democracy(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::collective_Instance1(ref __self_0),
                     &Event::collective_Instance1(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::collective_Instance2(ref __self_0),
                     &Event::collective_Instance2(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::elections_phragmen(ref __self_0),
                     &Event::elections_phragmen(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::membership_Instance1(ref __self_0),
                     &Event::membership_Instance1(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::grandpa(ref __self_0),
                     &Event::grandpa(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::treasury(ref __self_0),
                     &Event::treasury(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::contracts(ref __self_0),
                     &Event::contracts(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::sudo(ref __self_0), &Event::sudo(ref __arg_1_0))
                    => (*__self_0) != (*__arg_1_0),
                    (&Event::im_online(ref __self_0),
                     &Event::im_online(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::offences(ref __self_0),
                     &Event::offences(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::nicks(ref __self_0),
                     &Event::nicks(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::transx(ref __self_0),
                     &Event::transx(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::register(ref __self_0),
                     &Event::register(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Event::mine(ref __self_0), &Event::mine(ref __arg_1_0))
                    => (*__self_0) != (*__arg_1_0),
                    (&Event::report(ref __self_0),
                     &Event::report(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { true }
        }
    }
}
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralEq for Event { }
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::cmp::Eq for Event {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<system::Event>;
            let _: ::core::cmp::AssertParamIsEq<utility::Event<>>;
            let _: ::core::cmp::AssertParamIsEq<indices::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<balances::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<staking::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<session::Event<>>;
            let _: ::core::cmp::AssertParamIsEq<democracy::Event<Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<collective::Event<Runtime,
                                                                   collective::Instance1>>;
            let _:
                    ::core::cmp::AssertParamIsEq<collective::Event<Runtime,
                                                                   collective::Instance2>>;
            let _:
                    ::core::cmp::AssertParamIsEq<elections_phragmen::Event<Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<membership::Event<Runtime,
                                                                   membership::Instance1>>;
            let _: ::core::cmp::AssertParamIsEq<grandpa::Event<>>;
            let _: ::core::cmp::AssertParamIsEq<treasury::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<contracts::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<sudo::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<im_online::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<offences::Event<>>;
            let _: ::core::cmp::AssertParamIsEq<nicks::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<transx::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<register::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<mine::Event<Runtime>>;
            let _: ::core::cmp::AssertParamIsEq<report::Event<Runtime>>;
        }
    }
}
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Event {
            fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                              dest:
                                                                  &mut EncOut) {
                match *self {
                    Event::system(ref aa) => {
                        dest.push_byte(0usize as u8);
                        dest.push(aa);
                    }
                    Event::utility(ref aa) => {
                        dest.push_byte(1usize as u8);
                        dest.push(aa);
                    }
                    Event::indices(ref aa) => {
                        dest.push_byte(2usize as u8);
                        dest.push(aa);
                    }
                    Event::balances(ref aa) => {
                        dest.push_byte(3usize as u8);
                        dest.push(aa);
                    }
                    Event::staking(ref aa) => {
                        dest.push_byte(4usize as u8);
                        dest.push(aa);
                    }
                    Event::session(ref aa) => {
                        dest.push_byte(5usize as u8);
                        dest.push(aa);
                    }
                    Event::democracy(ref aa) => {
                        dest.push_byte(6usize as u8);
                        dest.push(aa);
                    }
                    Event::collective_Instance1(ref aa) => {
                        dest.push_byte(7usize as u8);
                        dest.push(aa);
                    }
                    Event::collective_Instance2(ref aa) => {
                        dest.push_byte(8usize as u8);
                        dest.push(aa);
                    }
                    Event::elections_phragmen(ref aa) => {
                        dest.push_byte(9usize as u8);
                        dest.push(aa);
                    }
                    Event::membership_Instance1(ref aa) => {
                        dest.push_byte(10usize as u8);
                        dest.push(aa);
                    }
                    Event::grandpa(ref aa) => {
                        dest.push_byte(11usize as u8);
                        dest.push(aa);
                    }
                    Event::treasury(ref aa) => {
                        dest.push_byte(12usize as u8);
                        dest.push(aa);
                    }
                    Event::contracts(ref aa) => {
                        dest.push_byte(13usize as u8);
                        dest.push(aa);
                    }
                    Event::sudo(ref aa) => {
                        dest.push_byte(14usize as u8);
                        dest.push(aa);
                    }
                    Event::im_online(ref aa) => {
                        dest.push_byte(15usize as u8);
                        dest.push(aa);
                    }
                    Event::offences(ref aa) => {
                        dest.push_byte(16usize as u8);
                        dest.push(aa);
                    }
                    Event::nicks(ref aa) => {
                        dest.push_byte(17usize as u8);
                        dest.push(aa);
                    }
                    Event::transx(ref aa) => {
                        dest.push_byte(18usize as u8);
                        dest.push(aa);
                    }
                    Event::register(ref aa) => {
                        dest.push_byte(19usize as u8);
                        dest.push(aa);
                    }
                    Event::mine(ref aa) => {
                        dest.push_byte(20usize as u8);
                        dest.push(aa);
                    }
                    Event::report(ref aa) => {
                        dest.push_byte(21usize as u8);
                        dest.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for Event { }
    };
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Event {
            fn decode<DecIn: _parity_scale_codec::Input>(input: &mut DecIn)
             -> core::result::Result<Self, _parity_scale_codec::Error> {
                match input.read_byte()? {
                    x if x == 0usize as u8 => {
                        Ok(Event::system({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Event :: system.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 1usize as u8 => {
                        Ok(Event::utility({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Event :: utility.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 2usize as u8 => {
                        Ok(Event::indices({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Event :: indices.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 3usize as u8 => {
                        Ok(Event::balances({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Event :: balances.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 4usize as u8 => {
                        Ok(Event::staking({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Event :: staking.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 5usize as u8 => {
                        Ok(Event::session({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Event :: session.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 6usize as u8 => {
                        Ok(Event::democracy({
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Event :: democracy.0".into()),
                                                    Ok(a) => a,
                                                }
                                            }))
                    }
                    x if x == 7usize as u8 => {
                        Ok(Event::collective_Instance1({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field Event :: collective_Instance1.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                    }
                    x if x == 8usize as u8 => {
                        Ok(Event::collective_Instance2({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field Event :: collective_Instance2.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                    }
                    x if x == 9usize as u8 => {
                        Ok(Event::elections_phragmen({
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field Event :: elections_phragmen.0".into()),
                                                             Ok(a) => a,
                                                         }
                                                     }))
                    }
                    x if x == 10usize as u8 => {
                        Ok(Event::membership_Instance1({
                                                           let res =
                                                               _parity_scale_codec::Decode::decode(input);
                                                           match res {
                                                               Err(_) =>
                                                               return Err("Error decoding field Event :: membership_Instance1.0".into()),
                                                               Ok(a) => a,
                                                           }
                                                       }))
                    }
                    x if x == 11usize as u8 => {
                        Ok(Event::grandpa({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Event :: grandpa.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 12usize as u8 => {
                        Ok(Event::treasury({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Event :: treasury.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 13usize as u8 => {
                        Ok(Event::contracts({
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Event :: contracts.0".into()),
                                                    Ok(a) => a,
                                                }
                                            }))
                    }
                    x if x == 14usize as u8 => {
                        Ok(Event::sudo({
                                           let res =
                                               _parity_scale_codec::Decode::decode(input);
                                           match res {
                                               Err(_) =>
                                               return Err("Error decoding field Event :: sudo.0".into()),
                                               Ok(a) => a,
                                           }
                                       }))
                    }
                    x if x == 15usize as u8 => {
                        Ok(Event::im_online({
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Event :: im_online.0".into()),
                                                    Ok(a) => a,
                                                }
                                            }))
                    }
                    x if x == 16usize as u8 => {
                        Ok(Event::offences({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Event :: offences.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 17usize as u8 => {
                        Ok(Event::nicks({
                                            let res =
                                                _parity_scale_codec::Decode::decode(input);
                                            match res {
                                                Err(_) =>
                                                return Err("Error decoding field Event :: nicks.0".into()),
                                                Ok(a) => a,
                                            }
                                        }))
                    }
                    x if x == 18usize as u8 => {
                        Ok(Event::transx({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Event :: transx.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 19usize as u8 => {
                        Ok(Event::register({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Event :: register.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 20usize as u8 => {
                        Ok(Event::mine({
                                           let res =
                                               _parity_scale_codec::Decode::decode(input);
                                           match res {
                                               Err(_) =>
                                               return Err("Error decoding field Event :: mine.0".into()),
                                               Ok(a) => a,
                                           }
                                       }))
                    }
                    x if x == 21usize as u8 => {
                        Ok(Event::report({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Event :: report.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x => Err("No such variant in enum Event".into()),
                }
            }
        }
    };
impl core::fmt::Debug for Event {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::system(ref a0) =>
            fmt.debug_tuple("Event::system").field(a0).finish(),
            Self::utility(ref a0) =>
            fmt.debug_tuple("Event::utility").field(a0).finish(),
            Self::indices(ref a0) =>
            fmt.debug_tuple("Event::indices").field(a0).finish(),
            Self::balances(ref a0) =>
            fmt.debug_tuple("Event::balances").field(a0).finish(),
            Self::staking(ref a0) =>
            fmt.debug_tuple("Event::staking").field(a0).finish(),
            Self::session(ref a0) =>
            fmt.debug_tuple("Event::session").field(a0).finish(),
            Self::democracy(ref a0) =>
            fmt.debug_tuple("Event::democracy").field(a0).finish(),
            Self::collective_Instance1(ref a0) =>
            fmt.debug_tuple("Event::collective_Instance1").field(a0).finish(),
            Self::collective_Instance2(ref a0) =>
            fmt.debug_tuple("Event::collective_Instance2").field(a0).finish(),
            Self::elections_phragmen(ref a0) =>
            fmt.debug_tuple("Event::elections_phragmen").field(a0).finish(),
            Self::membership_Instance1(ref a0) =>
            fmt.debug_tuple("Event::membership_Instance1").field(a0).finish(),
            Self::grandpa(ref a0) =>
            fmt.debug_tuple("Event::grandpa").field(a0).finish(),
            Self::treasury(ref a0) =>
            fmt.debug_tuple("Event::treasury").field(a0).finish(),
            Self::contracts(ref a0) =>
            fmt.debug_tuple("Event::contracts").field(a0).finish(),
            Self::sudo(ref a0) =>
            fmt.debug_tuple("Event::sudo").field(a0).finish(),
            Self::im_online(ref a0) =>
            fmt.debug_tuple("Event::im_online").field(a0).finish(),
            Self::offences(ref a0) =>
            fmt.debug_tuple("Event::offences").field(a0).finish(),
            Self::nicks(ref a0) =>
            fmt.debug_tuple("Event::nicks").field(a0).finish(),
            Self::transx(ref a0) =>
            fmt.debug_tuple("Event::transx").field(a0).finish(),
            Self::register(ref a0) =>
            fmt.debug_tuple("Event::register").field(a0).finish(),
            Self::mine(ref a0) =>
            fmt.debug_tuple("Event::mine").field(a0).finish(),
            Self::report(ref a0) =>
            fmt.debug_tuple("Event::report").field(a0).finish(),
            _ => Ok(()),
        }
    }
}
impl From<system::Event> for Event {
    fn from(x: system::Event) -> Self { Event::system(x) }
}
impl From<utility::Event<>> for Event {
    fn from(x: utility::Event<>) -> Self { Event::utility(x) }
}
impl ::frame_support::rstd::convert::TryInto<utility::Event<>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     -> ::frame_support::rstd::result::Result<utility::Event<>, Self::Error> {
        match self { Self::utility(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<indices::Event<Runtime>> for Event {
    fn from(x: indices::Event<Runtime>) -> Self { Event::indices(x) }
}
impl ::frame_support::rstd::convert::TryInto<indices::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<indices::Event<Runtime>,
                                               Self::Error> {
        match self { Self::indices(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<balances::Event<Runtime>> for Event {
    fn from(x: balances::Event<Runtime>) -> Self { Event::balances(x) }
}
impl ::frame_support::rstd::convert::TryInto<balances::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<balances::Event<Runtime>,
                                               Self::Error> {
        match self { Self::balances(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<staking::Event<Runtime>> for Event {
    fn from(x: staking::Event<Runtime>) -> Self { Event::staking(x) }
}
impl ::frame_support::rstd::convert::TryInto<staking::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<staking::Event<Runtime>,
                                               Self::Error> {
        match self { Self::staking(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<session::Event<>> for Event {
    fn from(x: session::Event<>) -> Self { Event::session(x) }
}
impl ::frame_support::rstd::convert::TryInto<session::Event<>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     -> ::frame_support::rstd::result::Result<session::Event<>, Self::Error> {
        match self { Self::session(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<democracy::Event<Runtime>> for Event {
    fn from(x: democracy::Event<Runtime>) -> Self { Event::democracy(x) }
}
impl ::frame_support::rstd::convert::TryInto<democracy::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<democracy::Event<Runtime>,
                                               Self::Error> {
        match self { Self::democracy(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<collective::Event<Runtime, collective::Instance1>> for Event {
    fn from(x: collective::Event<Runtime, collective::Instance1>) -> Self {
        Event::collective_Instance1(x)
    }
}
impl ::frame_support::rstd::convert::TryInto<collective::Event<Runtime,
                                                               collective::Instance1>>
 for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<collective::Event<Runtime,
                                                                 collective::Instance1>,
                                               Self::Error> {
        match self {
            Self::collective_Instance1(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<collective::Event<Runtime, collective::Instance2>> for Event {
    fn from(x: collective::Event<Runtime, collective::Instance2>) -> Self {
        Event::collective_Instance2(x)
    }
}
impl ::frame_support::rstd::convert::TryInto<collective::Event<Runtime,
                                                               collective::Instance2>>
 for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<collective::Event<Runtime,
                                                                 collective::Instance2>,
                                               Self::Error> {
        match self {
            Self::collective_Instance2(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<elections_phragmen::Event<Runtime>> for Event {
    fn from(x: elections_phragmen::Event<Runtime>) -> Self {
        Event::elections_phragmen(x)
    }
}
impl ::frame_support::rstd::convert::TryInto<elections_phragmen::Event<Runtime>>
 for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<elections_phragmen::Event<Runtime>,
                                               Self::Error> {
        match self { Self::elections_phragmen(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<membership::Event<Runtime, membership::Instance1>> for Event {
    fn from(x: membership::Event<Runtime, membership::Instance1>) -> Self {
        Event::membership_Instance1(x)
    }
}
impl ::frame_support::rstd::convert::TryInto<membership::Event<Runtime,
                                                               membership::Instance1>>
 for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<membership::Event<Runtime,
                                                                 membership::Instance1>,
                                               Self::Error> {
        match self {
            Self::membership_Instance1(evt) => Ok(evt),
            _ => Err(()),
        }
    }
}
impl From<grandpa::Event<>> for Event {
    fn from(x: grandpa::Event<>) -> Self { Event::grandpa(x) }
}
impl ::frame_support::rstd::convert::TryInto<grandpa::Event<>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     -> ::frame_support::rstd::result::Result<grandpa::Event<>, Self::Error> {
        match self { Self::grandpa(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<treasury::Event<Runtime>> for Event {
    fn from(x: treasury::Event<Runtime>) -> Self { Event::treasury(x) }
}
impl ::frame_support::rstd::convert::TryInto<treasury::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<treasury::Event<Runtime>,
                                               Self::Error> {
        match self { Self::treasury(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<contracts::Event<Runtime>> for Event {
    fn from(x: contracts::Event<Runtime>) -> Self { Event::contracts(x) }
}
impl ::frame_support::rstd::convert::TryInto<contracts::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<contracts::Event<Runtime>,
                                               Self::Error> {
        match self { Self::contracts(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<sudo::Event<Runtime>> for Event {
    fn from(x: sudo::Event<Runtime>) -> Self { Event::sudo(x) }
}
impl ::frame_support::rstd::convert::TryInto<sudo::Event<Runtime>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<sudo::Event<Runtime>,
                                               Self::Error> {
        match self { Self::sudo(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<im_online::Event<Runtime>> for Event {
    fn from(x: im_online::Event<Runtime>) -> Self { Event::im_online(x) }
}
impl ::frame_support::rstd::convert::TryInto<im_online::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<im_online::Event<Runtime>,
                                               Self::Error> {
        match self { Self::im_online(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<offences::Event<>> for Event {
    fn from(x: offences::Event<>) -> Self { Event::offences(x) }
}
impl ::frame_support::rstd::convert::TryInto<offences::Event<>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<offences::Event<>,
                                               Self::Error> {
        match self { Self::offences(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<nicks::Event<Runtime>> for Event {
    fn from(x: nicks::Event<Runtime>) -> Self { Event::nicks(x) }
}
impl ::frame_support::rstd::convert::TryInto<nicks::Event<Runtime>> for Event
 {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<nicks::Event<Runtime>,
                                               Self::Error> {
        match self { Self::nicks(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<transx::Event<Runtime>> for Event {
    fn from(x: transx::Event<Runtime>) -> Self { Event::transx(x) }
}
impl ::frame_support::rstd::convert::TryInto<transx::Event<Runtime>> for Event
 {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<transx::Event<Runtime>,
                                               Self::Error> {
        match self { Self::transx(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<register::Event<Runtime>> for Event {
    fn from(x: register::Event<Runtime>) -> Self { Event::register(x) }
}
impl ::frame_support::rstd::convert::TryInto<register::Event<Runtime>> for
 Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<register::Event<Runtime>,
                                               Self::Error> {
        match self { Self::register(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<mine::Event<Runtime>> for Event {
    fn from(x: mine::Event<Runtime>) -> Self { Event::mine(x) }
}
impl ::frame_support::rstd::convert::TryInto<mine::Event<Runtime>> for Event {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<mine::Event<Runtime>,
                                               Self::Error> {
        match self { Self::mine(evt) => Ok(evt), _ => Err(()), }
    }
}
impl From<report::Event<Runtime>> for Event {
    fn from(x: report::Event<Runtime>) -> Self { Event::report(x) }
}
impl ::frame_support::rstd::convert::TryInto<report::Event<Runtime>> for Event
 {
    type
    Error
    =
    ();
    fn try_into(self)
     ->
         ::frame_support::rstd::result::Result<report::Event<Runtime>,
                                               Self::Error> {
        match self { Self::report(evt) => Ok(evt), _ => Err(()), }
    }
}
impl Runtime {
    #[allow(dead_code)]
    pub fn outer_event_metadata()
     -> ::frame_support::event::OuterEventMetadata {
        ::frame_support::event::OuterEventMetadata{name:
                                                       ::frame_support::event::DecodeDifferent::Encode("Event"),
                                                   events:
                                                       ::frame_support::event::DecodeDifferent::Encode(&[("system",
                                                                                                          ::frame_support::event::FnEncode(system::Event::metadata)),
                                                                                                         ("utility",
                                                                                                          ::frame_support::event::FnEncode(utility::Event::<>::metadata)),
                                                                                                         ("indices",
                                                                                                          ::frame_support::event::FnEncode(indices::Event::<Runtime>::metadata)),
                                                                                                         ("balances",
                                                                                                          ::frame_support::event::FnEncode(balances::Event::<Runtime>::metadata)),
                                                                                                         ("staking",
                                                                                                          ::frame_support::event::FnEncode(staking::Event::<Runtime>::metadata)),
                                                                                                         ("session",
                                                                                                          ::frame_support::event::FnEncode(session::Event::<>::metadata)),
                                                                                                         ("democracy",
                                                                                                          ::frame_support::event::FnEncode(democracy::Event::<Runtime>::metadata)),
                                                                                                         ("collective",
                                                                                                          ::frame_support::event::FnEncode(collective::Event::<Runtime,
                                                                                                                                                               collective::Instance1>::metadata)),
                                                                                                         ("collective",
                                                                                                          ::frame_support::event::FnEncode(collective::Event::<Runtime,
                                                                                                                                                               collective::Instance2>::metadata)),
                                                                                                         ("elections_phragmen",
                                                                                                          ::frame_support::event::FnEncode(elections_phragmen::Event::<Runtime>::metadata)),
                                                                                                         ("membership",
                                                                                                          ::frame_support::event::FnEncode(membership::Event::<Runtime,
                                                                                                                                                               membership::Instance1>::metadata)),
                                                                                                         ("grandpa",
                                                                                                          ::frame_support::event::FnEncode(grandpa::Event::<>::metadata)),
                                                                                                         ("treasury",
                                                                                                          ::frame_support::event::FnEncode(treasury::Event::<Runtime>::metadata)),
                                                                                                         ("contracts",
                                                                                                          ::frame_support::event::FnEncode(contracts::Event::<Runtime>::metadata)),
                                                                                                         ("sudo",
                                                                                                          ::frame_support::event::FnEncode(sudo::Event::<Runtime>::metadata)),
                                                                                                         ("im_online",
                                                                                                          ::frame_support::event::FnEncode(im_online::Event::<Runtime>::metadata)),
                                                                                                         ("offences",
                                                                                                          ::frame_support::event::FnEncode(offences::Event::<>::metadata)),
                                                                                                         ("nicks",
                                                                                                          ::frame_support::event::FnEncode(nicks::Event::<Runtime>::metadata)),
                                                                                                         ("transx",
                                                                                                          ::frame_support::event::FnEncode(transx::Event::<Runtime>::metadata)),
                                                                                                         ("register",
                                                                                                          ::frame_support::event::FnEncode(register::Event::<Runtime>::metadata)),
                                                                                                         ("mine",
                                                                                                          ::frame_support::event::FnEncode(mine::Event::<Runtime>::metadata)),
                                                                                                         ("report",
                                                                                                          ::frame_support::event::FnEncode(report::Event::<Runtime>::metadata))]),}
    }
    #[allow(dead_code)]
    pub fn __module_events_system()
     -> &'static [::frame_support::event::EventMetadata] {
        system::Event::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_utility()
     -> &'static [::frame_support::event::EventMetadata] {
        utility::Event::<>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_indices()
     -> &'static [::frame_support::event::EventMetadata] {
        indices::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_balances()
     -> &'static [::frame_support::event::EventMetadata] {
        balances::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_staking()
     -> &'static [::frame_support::event::EventMetadata] {
        staking::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_session()
     -> &'static [::frame_support::event::EventMetadata] {
        session::Event::<>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_democracy()
     -> &'static [::frame_support::event::EventMetadata] {
        democracy::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_collective_Instance1()
     -> &'static [::frame_support::event::EventMetadata] {
        collective::Event::<Runtime, collective::Instance1>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_collective_Instance2()
     -> &'static [::frame_support::event::EventMetadata] {
        collective::Event::<Runtime, collective::Instance2>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_elections_phragmen()
     -> &'static [::frame_support::event::EventMetadata] {
        elections_phragmen::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_membership_Instance1()
     -> &'static [::frame_support::event::EventMetadata] {
        membership::Event::<Runtime, membership::Instance1>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_grandpa()
     -> &'static [::frame_support::event::EventMetadata] {
        grandpa::Event::<>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_treasury()
     -> &'static [::frame_support::event::EventMetadata] {
        treasury::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_contracts()
     -> &'static [::frame_support::event::EventMetadata] {
        contracts::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_sudo()
     -> &'static [::frame_support::event::EventMetadata] {
        sudo::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_im_online()
     -> &'static [::frame_support::event::EventMetadata] {
        im_online::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_offences()
     -> &'static [::frame_support::event::EventMetadata] {
        offences::Event::<>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_nicks()
     -> &'static [::frame_support::event::EventMetadata] {
        nicks::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_transx()
     -> &'static [::frame_support::event::EventMetadata] {
        transx::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_register()
     -> &'static [::frame_support::event::EventMetadata] {
        register::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_mine()
     -> &'static [::frame_support::event::EventMetadata] {
        mine::Event::<Runtime>::metadata()
    }
    #[allow(dead_code)]
    pub fn __module_events_report()
     -> &'static [::frame_support::event::EventMetadata] {
        report::Event::<Runtime>::metadata()
    }
}
#[allow(non_camel_case_types)]
pub enum Origin {
    system(system::Origin<Runtime>),
    collective_Instance1(collective::Origin<Runtime, collective::Instance1>),
    collective_Instance2(collective::Origin<Runtime, collective::Instance2>),

    #[allow(dead_code)]
    Void(::frame_support::Void),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::clone::Clone for Origin {
    #[inline]
    fn clone(&self) -> Origin {
        match (&*self,) {
            (&Origin::system(ref __self_0),) =>
            Origin::system(::core::clone::Clone::clone(&(*__self_0))),
            (&Origin::collective_Instance1(ref __self_0),) =>
            Origin::collective_Instance1(::core::clone::Clone::clone(&(*__self_0))),
            (&Origin::collective_Instance2(ref __self_0),) =>
            Origin::collective_Instance2(::core::clone::Clone::clone(&(*__self_0))),
            (&Origin::Void(ref __self_0),) =>
            Origin::Void(::core::clone::Clone::clone(&(*__self_0))),
        }
    }
}
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralPartialEq for Origin { }
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::cmp::PartialEq for Origin {
    #[inline]
    fn eq(&self, other: &Origin) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Origin::system(ref __self_0),
                     &Origin::system(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Origin::collective_Instance1(ref __self_0),
                     &Origin::collective_Instance1(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Origin::collective_Instance2(ref __self_0),
                     &Origin::collective_Instance2(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Origin::Void(ref __self_0),
                     &Origin::Void(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { false }
        }
    }
    #[inline]
    fn ne(&self, other: &Origin) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Origin::system(ref __self_0),
                     &Origin::system(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Origin::collective_Instance1(ref __self_0),
                     &Origin::collective_Instance1(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Origin::collective_Instance2(ref __self_0),
                     &Origin::collective_Instance2(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Origin::Void(ref __self_0),
                     &Origin::Void(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { true }
        }
    }
}
#[allow(non_camel_case_types)]
impl ::core::marker::StructuralEq for Origin { }
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
impl ::core::cmp::Eq for Origin {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<system::Origin<Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<collective::Origin<Runtime,
                                                                    collective::Instance1>>;
            let _:
                    ::core::cmp::AssertParamIsEq<collective::Origin<Runtime,
                                                                    collective::Instance2>>;
            let _: ::core::cmp::AssertParamIsEq<::frame_support::Void>;
        }
    }
}
impl core::fmt::Debug for Origin {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::system(ref a0) =>
            fmt.debug_tuple("Origin::system").field(a0).finish(),
            Self::collective_Instance1(ref a0) =>
            fmt.debug_tuple("Origin::collective_Instance1").field(a0).finish(),
            Self::collective_Instance2(ref a0) =>
            fmt.debug_tuple("Origin::collective_Instance2").field(a0).finish(),
            Self::Void(ref a0) =>
            fmt.debug_tuple("Origin::Void").field(a0).finish(),
            _ => Ok(()),
        }
    }
}
#[allow(dead_code)]
impl Origin {
    pub const
    NONE:
    Self
    =
    Origin::system(system::RawOrigin::None);
    pub const
    ROOT:
    Self
    =
    Origin::system(system::RawOrigin::Root);
    pub fn signed(by: <Runtime as system::Trait>::AccountId) -> Self {
        Origin::system(system::RawOrigin::Signed(by))
    }
}
impl From<system::Origin<Runtime>> for Origin {
    fn from(x: system::Origin<Runtime>) -> Self { Origin::system(x) }
}
impl Into<::frame_support::rstd::result::Result<system::Origin<Runtime>,
                                                Origin>> for Origin {
    fn into(self)
     -> ::frame_support::rstd::result::Result<system::Origin<Runtime>, Self> {
        if let Origin::system(l) = self { Ok(l) } else { Err(self) }
    }
}
impl From<Option<<Runtime as system::Trait>::AccountId>> for Origin {
    fn from(x: Option<<Runtime as system::Trait>::AccountId>) -> Self {
        <system::Origin<Runtime>>::from(x).into()
    }
}
impl From<collective::Origin<Runtime, collective::Instance1>> for Origin {
    fn from(x: collective::Origin<Runtime, collective::Instance1>) -> Self {
        Origin::collective_Instance1(x)
    }
}
impl Into<::frame_support::rstd::result::Result<collective::Origin<Runtime,
                                                                   collective::Instance1>,
                                                Origin>> for Origin {
    fn into(self)
     ->
         ::frame_support::rstd::result::Result<collective::Origin<Runtime,
                                                                  collective::Instance1>,
                                               Self> {
        if let Origin::collective_Instance1(l) = self {
            Ok(l)
        } else { Err(self) }
    }
}
impl From<collective::Origin<Runtime, collective::Instance2>> for Origin {
    fn from(x: collective::Origin<Runtime, collective::Instance2>) -> Self {
        Origin::collective_Instance2(x)
    }
}
impl Into<::frame_support::rstd::result::Result<collective::Origin<Runtime,
                                                                   collective::Instance2>,
                                                Origin>> for Origin {
    fn into(self)
     ->
         ::frame_support::rstd::result::Result<collective::Origin<Runtime,
                                                                  collective::Instance2>,
                                               Self> {
        if let Origin::collective_Instance2(l) = self {
            Ok(l)
        } else { Err(self) }
    }
}
pub type System = system::Module<Runtime>;
pub type Utility = utility::Module<Runtime>;
pub type Babe = babe::Module<Runtime>;
pub type Timestamp = timestamp::Module<Runtime>;
pub type Authorship = authorship::Module<Runtime>;
pub type Indices = indices::Module<Runtime>;
pub type Balances = balances::Module<Runtime>;
pub type TransactionPayment = transaction_payment::Module<Runtime>;
pub type Staking = staking::Module<Runtime>;
pub type Session = session::Module<Runtime>;
pub type Democracy = democracy::Module<Runtime>;
pub type Council = collective::Module<Runtime, collective::Instance1>;
pub type TechnicalCommittee
    =
    collective::Module<Runtime, collective::Instance2>;
pub type Elections = elections_phragmen::Module<Runtime>;
pub type TechnicalMembership
    =
    membership::Module<Runtime, membership::Instance1>;
pub type FinalityTracker = finality_tracker::Module<Runtime>;
pub type Grandpa = grandpa::Module<Runtime>;
pub type Treasury = treasury::Module<Runtime>;
pub type Contracts = contracts::Module<Runtime>;
pub type Sudo = sudo::Module<Runtime>;
pub type ImOnline = im_online::Module<Runtime>;
pub type AuthorityDiscovery = authority_discovery::Module<Runtime>;
pub type Offences = offences::Module<Runtime>;
pub type RandomnessCollectiveFlip
    =
    randomness_collective_flip::Module<Runtime>;
pub type Nicks = nicks::Module<Runtime>;
pub type Transx = transx::Module<Runtime>;
pub type Register = register::Module<Runtime>;
pub type Mine = mine::Module<Runtime>;
pub type Report = report::Module<Runtime>;
type AllModules
    =
    ((Report,
      (Mine,
       (Register,
        (Transx,
         (Nicks,
          (RandomnessCollectiveFlip,
           (Offences,
            (AuthorityDiscovery,
             (ImOnline,
              (Sudo,
               (Contracts,
                (Treasury,
                 (Grandpa,
                  (FinalityTracker,
                   (TechnicalMembership,
                    (Elections,
                     (TechnicalCommittee,
                      (Council,
                       (Democracy,
                        (Session,
                         (Staking,
                          (TransactionPayment,
                           (Balances,
                            (Indices,
                             (Authorship,
                              (Timestamp,
                               (Babe, (Utility,)))))))))))))))))))))))))))));
pub enum Call {
    System(::frame_support::dispatch::CallableCallFor<System, Runtime>),
    Utility(::frame_support::dispatch::CallableCallFor<Utility, Runtime>),
    Babe(::frame_support::dispatch::CallableCallFor<Babe, Runtime>),
    Timestamp(::frame_support::dispatch::CallableCallFor<Timestamp, Runtime>),
    Authorship(::frame_support::dispatch::CallableCallFor<Authorship,
                                                          Runtime>),
    Indices(::frame_support::dispatch::CallableCallFor<Indices, Runtime>),
    Balances(::frame_support::dispatch::CallableCallFor<Balances, Runtime>),
    Staking(::frame_support::dispatch::CallableCallFor<Staking, Runtime>),
    Session(::frame_support::dispatch::CallableCallFor<Session, Runtime>),
    Democracy(::frame_support::dispatch::CallableCallFor<Democracy, Runtime>),
    Council(::frame_support::dispatch::CallableCallFor<Council, Runtime>),
    TechnicalCommittee(::frame_support::dispatch::CallableCallFor<TechnicalCommittee,
                                                                  Runtime>),
    Elections(::frame_support::dispatch::CallableCallFor<Elections, Runtime>),
    TechnicalMembership(::frame_support::dispatch::CallableCallFor<TechnicalMembership,
                                                                   Runtime>),
    FinalityTracker(::frame_support::dispatch::CallableCallFor<FinalityTracker,
                                                               Runtime>),
    Grandpa(::frame_support::dispatch::CallableCallFor<Grandpa, Runtime>),
    Treasury(::frame_support::dispatch::CallableCallFor<Treasury, Runtime>),
    Contracts(::frame_support::dispatch::CallableCallFor<Contracts, Runtime>),
    Sudo(::frame_support::dispatch::CallableCallFor<Sudo, Runtime>),
    ImOnline(::frame_support::dispatch::CallableCallFor<ImOnline, Runtime>),
    AuthorityDiscovery(::frame_support::dispatch::CallableCallFor<AuthorityDiscovery,
                                                                  Runtime>),
    Offences(::frame_support::dispatch::CallableCallFor<Offences, Runtime>),
    RandomnessCollectiveFlip(::frame_support::dispatch::CallableCallFor<RandomnessCollectiveFlip,
                                                                        Runtime>),
    Nicks(::frame_support::dispatch::CallableCallFor<Nicks, Runtime>),
    Transx(::frame_support::dispatch::CallableCallFor<Transx, Runtime>),
    Register(::frame_support::dispatch::CallableCallFor<Register, Runtime>),
    Mine(::frame_support::dispatch::CallableCallFor<Mine, Runtime>),
    Report(::frame_support::dispatch::CallableCallFor<Report, Runtime>),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Call {
    #[inline]
    fn clone(&self) -> Call {
        match (&*self,) {
            (&Call::System(ref __self_0),) =>
            Call::System(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Utility(ref __self_0),) =>
            Call::Utility(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Babe(ref __self_0),) =>
            Call::Babe(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Timestamp(ref __self_0),) =>
            Call::Timestamp(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Authorship(ref __self_0),) =>
            Call::Authorship(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Indices(ref __self_0),) =>
            Call::Indices(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Balances(ref __self_0),) =>
            Call::Balances(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Staking(ref __self_0),) =>
            Call::Staking(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Session(ref __self_0),) =>
            Call::Session(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Democracy(ref __self_0),) =>
            Call::Democracy(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Council(ref __self_0),) =>
            Call::Council(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::TechnicalCommittee(ref __self_0),) =>
            Call::TechnicalCommittee(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Elections(ref __self_0),) =>
            Call::Elections(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::TechnicalMembership(ref __self_0),) =>
            Call::TechnicalMembership(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::FinalityTracker(ref __self_0),) =>
            Call::FinalityTracker(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Grandpa(ref __self_0),) =>
            Call::Grandpa(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Treasury(ref __self_0),) =>
            Call::Treasury(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Contracts(ref __self_0),) =>
            Call::Contracts(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Sudo(ref __self_0),) =>
            Call::Sudo(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::ImOnline(ref __self_0),) =>
            Call::ImOnline(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::AuthorityDiscovery(ref __self_0),) =>
            Call::AuthorityDiscovery(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Offences(ref __self_0),) =>
            Call::Offences(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::RandomnessCollectiveFlip(ref __self_0),) =>
            Call::RandomnessCollectiveFlip(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Nicks(ref __self_0),) =>
            Call::Nicks(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Transx(ref __self_0),) =>
            Call::Transx(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Register(ref __self_0),) =>
            Call::Register(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Mine(ref __self_0),) =>
            Call::Mine(::core::clone::Clone::clone(&(*__self_0))),
            (&Call::Report(ref __self_0),) =>
            Call::Report(::core::clone::Clone::clone(&(*__self_0))),
        }
    }
}
impl ::core::marker::StructuralPartialEq for Call { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Call {
    #[inline]
    fn eq(&self, other: &Call) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Call::System(ref __self_0),
                     &Call::System(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Utility(ref __self_0),
                     &Call::Utility(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Babe(ref __self_0), &Call::Babe(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Timestamp(ref __self_0),
                     &Call::Timestamp(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Authorship(ref __self_0),
                     &Call::Authorship(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Indices(ref __self_0),
                     &Call::Indices(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Balances(ref __self_0),
                     &Call::Balances(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Staking(ref __self_0),
                     &Call::Staking(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Session(ref __self_0),
                     &Call::Session(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Democracy(ref __self_0),
                     &Call::Democracy(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Council(ref __self_0),
                     &Call::Council(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::TechnicalCommittee(ref __self_0),
                     &Call::TechnicalCommittee(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Elections(ref __self_0),
                     &Call::Elections(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::TechnicalMembership(ref __self_0),
                     &Call::TechnicalMembership(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::FinalityTracker(ref __self_0),
                     &Call::FinalityTracker(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Grandpa(ref __self_0),
                     &Call::Grandpa(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Treasury(ref __self_0),
                     &Call::Treasury(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Contracts(ref __self_0),
                     &Call::Contracts(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Sudo(ref __self_0), &Call::Sudo(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::ImOnline(ref __self_0),
                     &Call::ImOnline(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::AuthorityDiscovery(ref __self_0),
                     &Call::AuthorityDiscovery(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Offences(ref __self_0),
                     &Call::Offences(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::RandomnessCollectiveFlip(ref __self_0),
                     &Call::RandomnessCollectiveFlip(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Nicks(ref __self_0), &Call::Nicks(ref __arg_1_0))
                    => (*__self_0) == (*__arg_1_0),
                    (&Call::Transx(ref __self_0),
                     &Call::Transx(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Register(ref __self_0),
                     &Call::Register(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Mine(ref __self_0), &Call::Mine(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    (&Call::Report(ref __self_0),
                     &Call::Report(ref __arg_1_0)) =>
                    (*__self_0) == (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { false }
        }
    }
    #[inline]
    fn ne(&self, other: &Call) -> bool {
        {
            let __self_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*self) } as
                    isize;
            let __arg_1_vi =
                unsafe { ::core::intrinsics::discriminant_value(&*other) } as
                    isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Call::System(ref __self_0),
                     &Call::System(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Utility(ref __self_0),
                     &Call::Utility(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Babe(ref __self_0), &Call::Babe(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Timestamp(ref __self_0),
                     &Call::Timestamp(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Authorship(ref __self_0),
                     &Call::Authorship(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Indices(ref __self_0),
                     &Call::Indices(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Balances(ref __self_0),
                     &Call::Balances(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Staking(ref __self_0),
                     &Call::Staking(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Session(ref __self_0),
                     &Call::Session(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Democracy(ref __self_0),
                     &Call::Democracy(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Council(ref __self_0),
                     &Call::Council(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::TechnicalCommittee(ref __self_0),
                     &Call::TechnicalCommittee(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Elections(ref __self_0),
                     &Call::Elections(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::TechnicalMembership(ref __self_0),
                     &Call::TechnicalMembership(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::FinalityTracker(ref __self_0),
                     &Call::FinalityTracker(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Grandpa(ref __self_0),
                     &Call::Grandpa(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Treasury(ref __self_0),
                     &Call::Treasury(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Contracts(ref __self_0),
                     &Call::Contracts(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Sudo(ref __self_0), &Call::Sudo(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::ImOnline(ref __self_0),
                     &Call::ImOnline(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::AuthorityDiscovery(ref __self_0),
                     &Call::AuthorityDiscovery(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Offences(ref __self_0),
                     &Call::Offences(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::RandomnessCollectiveFlip(ref __self_0),
                     &Call::RandomnessCollectiveFlip(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Nicks(ref __self_0), &Call::Nicks(ref __arg_1_0))
                    => (*__self_0) != (*__arg_1_0),
                    (&Call::Transx(ref __self_0),
                     &Call::Transx(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Register(ref __self_0),
                     &Call::Register(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Mine(ref __self_0), &Call::Mine(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    (&Call::Report(ref __self_0),
                     &Call::Report(ref __arg_1_0)) =>
                    (*__self_0) != (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            } else { true }
        }
    }
}
impl ::core::marker::StructuralEq for Call { }
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Call {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<System,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Utility,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Babe,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Timestamp,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Authorship,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Indices,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Balances,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Staking,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Session,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Democracy,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Council,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<TechnicalCommittee,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Elections,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<TechnicalMembership,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<FinalityTracker,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Grandpa,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Treasury,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Contracts,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Sudo,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<ImOnline,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<AuthorityDiscovery,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Offences,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<RandomnessCollectiveFlip,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Nicks,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Transx,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Register,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Mine,
                                                                                            Runtime>>;
            let _:
                    ::core::cmp::AssertParamIsEq<::frame_support::dispatch::CallableCallFor<Report,
                                                                                            Runtime>>;
        }
    }
}
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Call {
            fn encode_to<EncOut: _parity_scale_codec::Output>(&self,
                                                              dest:
                                                                  &mut EncOut) {
                match *self {
                    Call::System(ref aa) => {
                        dest.push_byte(0usize as u8);
                        dest.push(aa);
                    }
                    Call::Utility(ref aa) => {
                        dest.push_byte(1usize as u8);
                        dest.push(aa);
                    }
                    Call::Babe(ref aa) => {
                        dest.push_byte(2usize as u8);
                        dest.push(aa);
                    }
                    Call::Timestamp(ref aa) => {
                        dest.push_byte(3usize as u8);
                        dest.push(aa);
                    }
                    Call::Authorship(ref aa) => {
                        dest.push_byte(4usize as u8);
                        dest.push(aa);
                    }
                    Call::Indices(ref aa) => {
                        dest.push_byte(5usize as u8);
                        dest.push(aa);
                    }
                    Call::Balances(ref aa) => {
                        dest.push_byte(6usize as u8);
                        dest.push(aa);
                    }
                    Call::Staking(ref aa) => {
                        dest.push_byte(7usize as u8);
                        dest.push(aa);
                    }
                    Call::Session(ref aa) => {
                        dest.push_byte(8usize as u8);
                        dest.push(aa);
                    }
                    Call::Democracy(ref aa) => {
                        dest.push_byte(9usize as u8);
                        dest.push(aa);
                    }
                    Call::Council(ref aa) => {
                        dest.push_byte(10usize as u8);
                        dest.push(aa);
                    }
                    Call::TechnicalCommittee(ref aa) => {
                        dest.push_byte(11usize as u8);
                        dest.push(aa);
                    }
                    Call::Elections(ref aa) => {
                        dest.push_byte(12usize as u8);
                        dest.push(aa);
                    }
                    Call::TechnicalMembership(ref aa) => {
                        dest.push_byte(13usize as u8);
                        dest.push(aa);
                    }
                    Call::FinalityTracker(ref aa) => {
                        dest.push_byte(14usize as u8);
                        dest.push(aa);
                    }
                    Call::Grandpa(ref aa) => {
                        dest.push_byte(15usize as u8);
                        dest.push(aa);
                    }
                    Call::Treasury(ref aa) => {
                        dest.push_byte(16usize as u8);
                        dest.push(aa);
                    }
                    Call::Contracts(ref aa) => {
                        dest.push_byte(17usize as u8);
                        dest.push(aa);
                    }
                    Call::Sudo(ref aa) => {
                        dest.push_byte(18usize as u8);
                        dest.push(aa);
                    }
                    Call::ImOnline(ref aa) => {
                        dest.push_byte(19usize as u8);
                        dest.push(aa);
                    }
                    Call::AuthorityDiscovery(ref aa) => {
                        dest.push_byte(20usize as u8);
                        dest.push(aa);
                    }
                    Call::Offences(ref aa) => {
                        dest.push_byte(21usize as u8);
                        dest.push(aa);
                    }
                    Call::RandomnessCollectiveFlip(ref aa) => {
                        dest.push_byte(22usize as u8);
                        dest.push(aa);
                    }
                    Call::Nicks(ref aa) => {
                        dest.push_byte(23usize as u8);
                        dest.push(aa);
                    }
                    Call::Transx(ref aa) => {
                        dest.push_byte(24usize as u8);
                        dest.push(aa);
                    }
                    Call::Register(ref aa) => {
                        dest.push_byte(25usize as u8);
                        dest.push(aa);
                    }
                    Call::Mine(ref aa) => {
                        dest.push_byte(26usize as u8);
                        dest.push(aa);
                    }
                    Call::Report(ref aa) => {
                        dest.push_byte(27usize as u8);
                        dest.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for Call { }
    };
const _: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Call {
            fn decode<DecIn: _parity_scale_codec::Input>(input: &mut DecIn)
             -> core::result::Result<Self, _parity_scale_codec::Error> {
                match input.read_byte()? {
                    x if x == 0usize as u8 => {
                        Ok(Call::System({
                                            let res =
                                                _parity_scale_codec::Decode::decode(input);
                                            match res {
                                                Err(_) =>
                                                return Err("Error decoding field Call :: System.0".into()),
                                                Ok(a) => a,
                                            }
                                        }))
                    }
                    x if x == 1usize as u8 => {
                        Ok(Call::Utility({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Utility.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 2usize as u8 => {
                        Ok(Call::Babe({
                                          let res =
                                              _parity_scale_codec::Decode::decode(input);
                                          match res {
                                              Err(_) =>
                                              return Err("Error decoding field Call :: Babe.0".into()),
                                              Ok(a) => a,
                                          }
                                      }))
                    }
                    x if x == 3usize as u8 => {
                        Ok(Call::Timestamp({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Call :: Timestamp.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 4usize as u8 => {
                        Ok(Call::Authorship({
                                                let res =
                                                    _parity_scale_codec::Decode::decode(input);
                                                match res {
                                                    Err(_) =>
                                                    return Err("Error decoding field Call :: Authorship.0".into()),
                                                    Ok(a) => a,
                                                }
                                            }))
                    }
                    x if x == 5usize as u8 => {
                        Ok(Call::Indices({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Indices.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 6usize as u8 => {
                        Ok(Call::Balances({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: Balances.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 7usize as u8 => {
                        Ok(Call::Staking({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Staking.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 8usize as u8 => {
                        Ok(Call::Session({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Session.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 9usize as u8 => {
                        Ok(Call::Democracy({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Call :: Democracy.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 10usize as u8 => {
                        Ok(Call::Council({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Council.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 11usize as u8 => {
                        Ok(Call::TechnicalCommittee({
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: TechnicalCommittee.0".into()),
                                                            Ok(a) => a,
                                                        }
                                                    }))
                    }
                    x if x == 12usize as u8 => {
                        Ok(Call::Elections({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Call :: Elections.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 13usize as u8 => {
                        Ok(Call::TechnicalMembership({
                                                         let res =
                                                             _parity_scale_codec::Decode::decode(input);
                                                         match res {
                                                             Err(_) =>
                                                             return Err("Error decoding field Call :: TechnicalMembership.0".into()),
                                                             Ok(a) => a,
                                                         }
                                                     }))
                    }
                    x if x == 14usize as u8 => {
                        Ok(Call::FinalityTracker({
                                                     let res =
                                                         _parity_scale_codec::Decode::decode(input);
                                                     match res {
                                                         Err(_) =>
                                                         return Err("Error decoding field Call :: FinalityTracker.0".into()),
                                                         Ok(a) => a,
                                                     }
                                                 }))
                    }
                    x if x == 15usize as u8 => {
                        Ok(Call::Grandpa({
                                             let res =
                                                 _parity_scale_codec::Decode::decode(input);
                                             match res {
                                                 Err(_) =>
                                                 return Err("Error decoding field Call :: Grandpa.0".into()),
                                                 Ok(a) => a,
                                             }
                                         }))
                    }
                    x if x == 16usize as u8 => {
                        Ok(Call::Treasury({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: Treasury.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 17usize as u8 => {
                        Ok(Call::Contracts({
                                               let res =
                                                   _parity_scale_codec::Decode::decode(input);
                                               match res {
                                                   Err(_) =>
                                                   return Err("Error decoding field Call :: Contracts.0".into()),
                                                   Ok(a) => a,
                                               }
                                           }))
                    }
                    x if x == 18usize as u8 => {
                        Ok(Call::Sudo({
                                          let res =
                                              _parity_scale_codec::Decode::decode(input);
                                          match res {
                                              Err(_) =>
                                              return Err("Error decoding field Call :: Sudo.0".into()),
                                              Ok(a) => a,
                                          }
                                      }))
                    }
                    x if x == 19usize as u8 => {
                        Ok(Call::ImOnline({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: ImOnline.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 20usize as u8 => {
                        Ok(Call::AuthorityDiscovery({
                                                        let res =
                                                            _parity_scale_codec::Decode::decode(input);
                                                        match res {
                                                            Err(_) =>
                                                            return Err("Error decoding field Call :: AuthorityDiscovery.0".into()),
                                                            Ok(a) => a,
                                                        }
                                                    }))
                    }
                    x if x == 21usize as u8 => {
                        Ok(Call::Offences({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: Offences.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 22usize as u8 => {
                        Ok(Call::RandomnessCollectiveFlip({
                                                              let res =
                                                                  _parity_scale_codec::Decode::decode(input);
                                                              match res {
                                                                  Err(_) =>
                                                                  return Err("Error decoding field Call :: RandomnessCollectiveFlip.0".into()),
                                                                  Ok(a) => a,
                                                              }
                                                          }))
                    }
                    x if x == 23usize as u8 => {
                        Ok(Call::Nicks({
                                           let res =
                                               _parity_scale_codec::Decode::decode(input);
                                           match res {
                                               Err(_) =>
                                               return Err("Error decoding field Call :: Nicks.0".into()),
                                               Ok(a) => a,
                                           }
                                       }))
                    }
                    x if x == 24usize as u8 => {
                        Ok(Call::Transx({
                                            let res =
                                                _parity_scale_codec::Decode::decode(input);
                                            match res {
                                                Err(_) =>
                                                return Err("Error decoding field Call :: Transx.0".into()),
                                                Ok(a) => a,
                                            }
                                        }))
                    }
                    x if x == 25usize as u8 => {
                        Ok(Call::Register({
                                              let res =
                                                  _parity_scale_codec::Decode::decode(input);
                                              match res {
                                                  Err(_) =>
                                                  return Err("Error decoding field Call :: Register.0".into()),
                                                  Ok(a) => a,
                                              }
                                          }))
                    }
                    x if x == 26usize as u8 => {
                        Ok(Call::Mine({
                                          let res =
                                              _parity_scale_codec::Decode::decode(input);
                                          match res {
                                              Err(_) =>
                                              return Err("Error decoding field Call :: Mine.0".into()),
                                              Ok(a) => a,
                                          }
                                      }))
                    }
                    x if x == 27usize as u8 => {
                        Ok(Call::Report({
                                            let res =
                                                _parity_scale_codec::Decode::decode(input);
                                            match res {
                                                Err(_) =>
                                                return Err("Error decoding field Call :: Report.0".into()),
                                                Ok(a) => a,
                                            }
                                        }))
                    }
                    x => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
impl core::fmt::Debug for Call {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::System(ref a0) =>
            fmt.debug_tuple("Call::System").field(a0).finish(),
            Self::Utility(ref a0) =>
            fmt.debug_tuple("Call::Utility").field(a0).finish(),
            Self::Babe(ref a0) =>
            fmt.debug_tuple("Call::Babe").field(a0).finish(),
            Self::Timestamp(ref a0) =>
            fmt.debug_tuple("Call::Timestamp").field(a0).finish(),
            Self::Authorship(ref a0) =>
            fmt.debug_tuple("Call::Authorship").field(a0).finish(),
            Self::Indices(ref a0) =>
            fmt.debug_tuple("Call::Indices").field(a0).finish(),
            Self::Balances(ref a0) =>
            fmt.debug_tuple("Call::Balances").field(a0).finish(),
            Self::Staking(ref a0) =>
            fmt.debug_tuple("Call::Staking").field(a0).finish(),
            Self::Session(ref a0) =>
            fmt.debug_tuple("Call::Session").field(a0).finish(),
            Self::Democracy(ref a0) =>
            fmt.debug_tuple("Call::Democracy").field(a0).finish(),
            Self::Council(ref a0) =>
            fmt.debug_tuple("Call::Council").field(a0).finish(),
            Self::TechnicalCommittee(ref a0) =>
            fmt.debug_tuple("Call::TechnicalCommittee").field(a0).finish(),
            Self::Elections(ref a0) =>
            fmt.debug_tuple("Call::Elections").field(a0).finish(),
            Self::TechnicalMembership(ref a0) =>
            fmt.debug_tuple("Call::TechnicalMembership").field(a0).finish(),
            Self::FinalityTracker(ref a0) =>
            fmt.debug_tuple("Call::FinalityTracker").field(a0).finish(),
            Self::Grandpa(ref a0) =>
            fmt.debug_tuple("Call::Grandpa").field(a0).finish(),
            Self::Treasury(ref a0) =>
            fmt.debug_tuple("Call::Treasury").field(a0).finish(),
            Self::Contracts(ref a0) =>
            fmt.debug_tuple("Call::Contracts").field(a0).finish(),
            Self::Sudo(ref a0) =>
            fmt.debug_tuple("Call::Sudo").field(a0).finish(),
            Self::ImOnline(ref a0) =>
            fmt.debug_tuple("Call::ImOnline").field(a0).finish(),
            Self::AuthorityDiscovery(ref a0) =>
            fmt.debug_tuple("Call::AuthorityDiscovery").field(a0).finish(),
            Self::Offences(ref a0) =>
            fmt.debug_tuple("Call::Offences").field(a0).finish(),
            Self::RandomnessCollectiveFlip(ref a0) =>
            fmt.debug_tuple("Call::RandomnessCollectiveFlip").field(a0).finish(),
            Self::Nicks(ref a0) =>
            fmt.debug_tuple("Call::Nicks").field(a0).finish(),
            Self::Transx(ref a0) =>
            fmt.debug_tuple("Call::Transx").field(a0).finish(),
            Self::Register(ref a0) =>
            fmt.debug_tuple("Call::Register").field(a0).finish(),
            Self::Mine(ref a0) =>
            fmt.debug_tuple("Call::Mine").field(a0).finish(),
            Self::Report(ref a0) =>
            fmt.debug_tuple("Call::Report").field(a0).finish(),
            _ => Ok(()),
        }
    }
}
impl ::frame_support::dispatch::GetDispatchInfo for Call {
    fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
        match self {
            Call::System(call) => call.get_dispatch_info(),
            Call::Utility(call) => call.get_dispatch_info(),
            Call::Babe(call) => call.get_dispatch_info(),
            Call::Timestamp(call) => call.get_dispatch_info(),
            Call::Authorship(call) => call.get_dispatch_info(),
            Call::Indices(call) => call.get_dispatch_info(),
            Call::Balances(call) => call.get_dispatch_info(),
            Call::Staking(call) => call.get_dispatch_info(),
            Call::Session(call) => call.get_dispatch_info(),
            Call::Democracy(call) => call.get_dispatch_info(),
            Call::Council(call) => call.get_dispatch_info(),
            Call::TechnicalCommittee(call) => call.get_dispatch_info(),
            Call::Elections(call) => call.get_dispatch_info(),
            Call::TechnicalMembership(call) => call.get_dispatch_info(),
            Call::FinalityTracker(call) => call.get_dispatch_info(),
            Call::Grandpa(call) => call.get_dispatch_info(),
            Call::Treasury(call) => call.get_dispatch_info(),
            Call::Contracts(call) => call.get_dispatch_info(),
            Call::Sudo(call) => call.get_dispatch_info(),
            Call::ImOnline(call) => call.get_dispatch_info(),
            Call::AuthorityDiscovery(call) => call.get_dispatch_info(),
            Call::Offences(call) => call.get_dispatch_info(),
            Call::RandomnessCollectiveFlip(call) => call.get_dispatch_info(),
            Call::Nicks(call) => call.get_dispatch_info(),
            Call::Transx(call) => call.get_dispatch_info(),
            Call::Register(call) => call.get_dispatch_info(),
            Call::Mine(call) => call.get_dispatch_info(),
            Call::Report(call) => call.get_dispatch_info(),
        }
    }
}
impl ::frame_support::dispatch::Dispatchable for Call {
    type
    Origin
    =
    Origin;
    type
    Trait
    =
    Call;
    type
    Error
    =
    ::frame_support::dispatch::DispatchError;
    fn dispatch(self, origin: Origin)
     ->
         ::frame_support::dispatch::DispatchResult<::frame_support::dispatch::DispatchError> {
        match self {
            Call::System(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module = Some(0);
                                                  error
                                              }),
            Call::Utility(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module = Some(0 + 1);
                                                  error
                                              }),
            Call::Babe(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1);
                                                  error
                                              }),
            Call::Timestamp(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Authorship(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Indices(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::Balances(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::Staking(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
            Call::Session(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Democracy(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::Council(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::TechnicalCommittee(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
            Call::Elections(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::TechnicalMembership(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::FinalityTracker(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::Grandpa(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
            Call::Treasury(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Contracts(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::Sudo(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::ImOnline(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
            Call::AuthorityDiscovery(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Offences(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::RandomnessCollectiveFlip(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::Nicks(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
            Call::Transx(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1);
                                                  error
                                              }),
            Call::Register(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1);
                                                  error
                                              }),
            Call::Mine(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1);
                                                  error
                                              }),
            Call::Report(call) =>
            call.dispatch(origin).map_err(|e|
                                              {
                                                  let mut error:
                                                          ::frame_support::dispatch::DispatchError =
                                                      e.into();
                                                  error.module =
                                                      Some(0 + 1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1 + 1 +
                                                               1 + 1 + 1);
                                                  error
                                              }),
        }
    }
}
impl ::frame_support::dispatch::IsSubType<System, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<System, Runtime>> {
        match *self { Call::System(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<System, Runtime>> for
 Call {
    fn from(call: ::frame_support::dispatch::CallableCallFor<System, Runtime>)
     -> Self {
        Call::System(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Utility, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Utility,
                                                            Runtime>> {
        match *self { Call::Utility(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Utility, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Utility, Runtime>)
     -> Self {
        Call::Utility(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Babe, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Babe, Runtime>> {
        match *self { Call::Babe(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Babe, Runtime>> for Call
 {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Babe, Runtime>)
     -> Self {
        Call::Babe(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Timestamp, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Timestamp,
                                                            Runtime>> {
        match *self { Call::Timestamp(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Timestamp, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Timestamp,
                                                           Runtime>) -> Self {
        Call::Timestamp(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Authorship, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Authorship,
                                                            Runtime>> {
        match *self { Call::Authorship(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Authorship, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Authorship,
                                                           Runtime>) -> Self {
        Call::Authorship(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Indices, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Indices,
                                                            Runtime>> {
        match *self { Call::Indices(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Indices, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Indices, Runtime>)
     -> Self {
        Call::Indices(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Balances, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Balances,
                                                            Runtime>> {
        match *self { Call::Balances(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Balances, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Balances, Runtime>)
     -> Self {
        Call::Balances(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Staking, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Staking,
                                                            Runtime>> {
        match *self { Call::Staking(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Staking, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Staking, Runtime>)
     -> Self {
        Call::Staking(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Session, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Session,
                                                            Runtime>> {
        match *self { Call::Session(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Session, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Session, Runtime>)
     -> Self {
        Call::Session(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Democracy, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Democracy,
                                                            Runtime>> {
        match *self { Call::Democracy(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Democracy, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Democracy,
                                                           Runtime>) -> Self {
        Call::Democracy(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Council, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Council,
                                                            Runtime>> {
        match *self { Call::Council(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Council, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Council, Runtime>)
     -> Self {
        Call::Council(call)
    }
}
impl ::frame_support::dispatch::IsSubType<TechnicalCommittee, Runtime> for
 Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<TechnicalCommittee,
                                                            Runtime>> {
        match *self { Call::TechnicalCommittee(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<TechnicalCommittee,
                                                     Runtime>> for Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<TechnicalCommittee,
                                                           Runtime>) -> Self {
        Call::TechnicalCommittee(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Elections, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Elections,
                                                            Runtime>> {
        match *self { Call::Elections(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Elections, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Elections,
                                                           Runtime>) -> Self {
        Call::Elections(call)
    }
}
impl ::frame_support::dispatch::IsSubType<TechnicalMembership, Runtime> for
 Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<TechnicalMembership,
                                                            Runtime>> {
        match *self {
            Call::TechnicalMembership(ref r) => Some(r),
            _ => None,
        }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<TechnicalMembership,
                                                     Runtime>> for Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<TechnicalMembership,
                                                           Runtime>) -> Self {
        Call::TechnicalMembership(call)
    }
}
impl ::frame_support::dispatch::IsSubType<FinalityTracker, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<FinalityTracker,
                                                            Runtime>> {
        match *self { Call::FinalityTracker(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<FinalityTracker,
                                                     Runtime>> for Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<FinalityTracker,
                                                           Runtime>) -> Self {
        Call::FinalityTracker(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Grandpa, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Grandpa,
                                                            Runtime>> {
        match *self { Call::Grandpa(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Grandpa, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Grandpa, Runtime>)
     -> Self {
        Call::Grandpa(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Treasury, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Treasury,
                                                            Runtime>> {
        match *self { Call::Treasury(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Treasury, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Treasury, Runtime>)
     -> Self {
        Call::Treasury(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Contracts, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Contracts,
                                                            Runtime>> {
        match *self { Call::Contracts(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Contracts, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Contracts,
                                                           Runtime>) -> Self {
        Call::Contracts(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Sudo, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Sudo, Runtime>> {
        match *self { Call::Sudo(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Sudo, Runtime>> for Call
 {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Sudo, Runtime>)
     -> Self {
        Call::Sudo(call)
    }
}
impl ::frame_support::dispatch::IsSubType<ImOnline, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<ImOnline,
                                                            Runtime>> {
        match *self { Call::ImOnline(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<ImOnline, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<ImOnline, Runtime>)
     -> Self {
        Call::ImOnline(call)
    }
}
impl ::frame_support::dispatch::IsSubType<AuthorityDiscovery, Runtime> for
 Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<AuthorityDiscovery,
                                                            Runtime>> {
        match *self { Call::AuthorityDiscovery(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<AuthorityDiscovery,
                                                     Runtime>> for Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<AuthorityDiscovery,
                                                           Runtime>) -> Self {
        Call::AuthorityDiscovery(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Offences, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Offences,
                                                            Runtime>> {
        match *self { Call::Offences(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Offences, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Offences, Runtime>)
     -> Self {
        Call::Offences(call)
    }
}
impl ::frame_support::dispatch::IsSubType<RandomnessCollectiveFlip, Runtime>
 for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<RandomnessCollectiveFlip,
                                                            Runtime>> {
        match *self {
            Call::RandomnessCollectiveFlip(ref r) => Some(r),
            _ => None,
        }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<RandomnessCollectiveFlip,
                                                     Runtime>> for Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<RandomnessCollectiveFlip,
                                                           Runtime>) -> Self {
        Call::RandomnessCollectiveFlip(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Nicks, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Nicks, Runtime>> {
        match *self { Call::Nicks(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Nicks, Runtime>> for Call
 {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Nicks, Runtime>)
     -> Self {
        Call::Nicks(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Transx, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Transx, Runtime>> {
        match *self { Call::Transx(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Transx, Runtime>> for
 Call {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Transx, Runtime>)
     -> Self {
        Call::Transx(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Register, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     ->
         Option<&::frame_support::dispatch::CallableCallFor<Register,
                                                            Runtime>> {
        match *self { Call::Register(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Register, Runtime>> for
 Call {
    fn from(call:
                ::frame_support::dispatch::CallableCallFor<Register, Runtime>)
     -> Self {
        Call::Register(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Mine, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Mine, Runtime>> {
        match *self { Call::Mine(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Mine, Runtime>> for Call
 {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Mine, Runtime>)
     -> Self {
        Call::Mine(call)
    }
}
impl ::frame_support::dispatch::IsSubType<Report, Runtime> for Call {
    #[allow(unreachable_patterns)]
    fn is_sub_type(&self)
     -> Option<&::frame_support::dispatch::CallableCallFor<Report, Runtime>> {
        match *self { Call::Report(ref r) => Some(r), _ => None, }
    }
}
impl From<::frame_support::dispatch::CallableCallFor<Report, Runtime>> for
 Call {
    fn from(call: ::frame_support::dispatch::CallableCallFor<Report, Runtime>)
     -> Self {
        Call::Report(call)
    }
}
impl Runtime {
    pub fn metadata() -> ::frame_support::metadata::RuntimeMetadataPrefixed {
        ::frame_support::metadata::RuntimeMetadataLastVersion{modules:
                                                                  ::frame_support::metadata::DecodeDifferent::Encode(&[::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("System"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(system::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(system::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ system >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_system
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_system
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(system::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<system::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Utility"),
                                                                                                                                                                 storage:
                                                                                                                                                                     None,
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(utility::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ utility >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_utility
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_utility
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(utility::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<utility::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Babe"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(babe::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(babe::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(babe::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<babe::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Timestamp"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(timestamp::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(timestamp::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(timestamp::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<timestamp::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Authorship"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(authorship::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(authorship::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(authorship::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<authorship::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Indices"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(indices::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(indices::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ indices >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_indices
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_indices
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(indices::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<indices::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Balances"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(balances::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(balances::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ balances >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_balances
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_balances
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(balances::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<balances::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("TransactionPayment"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(transaction_payment::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     None,
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(transaction_payment::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<transaction_payment::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Staking"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(staking::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(staking::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ staking >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_staking
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_staking
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(staking::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<staking::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Session"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(session::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(session::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ session >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_session
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_session
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(session::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<session::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Democracy"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(democracy::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(democracy::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ democracy >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_democracy
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_democracy
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(democracy::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<democracy::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Council"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                      collective::Instance1>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                      collective::Instance1>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ collective _ Instance1 >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_collective_Instance1
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_collective_Instance1
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                 collective::Instance1>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<collective::Module<Runtime,
                                                                                                                                                                                                                                                                                collective::Instance1>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("TechnicalCommittee"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                      collective::Instance2>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                      collective::Instance2>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ collective _ Instance2 >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_collective_Instance2
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_collective_Instance2
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(collective::Module::<Runtime,
                                                                                                                                                                                                                                                                                 collective::Instance2>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<collective::Module<Runtime,
                                                                                                                                                                                                                                                                                collective::Instance2>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Elections"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(elections_phragmen::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(elections_phragmen::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ elections_phragmen >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_elections_phragmen
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_elections_phragmen
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(elections_phragmen::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<elections_phragmen::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("TechnicalMembership"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(membership::Module::<Runtime,
                                                                                                                                                                                                                                                                                      membership::Instance1>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(membership::Module::<Runtime,
                                                                                                                                                                                                                                                                                      membership::Instance1>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ membership _ Instance1 >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_membership_Instance1
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_membership_Instance1
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(membership::Module::<Runtime,
                                                                                                                                                                                                                                                                                 membership::Instance1>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<membership::Module<Runtime,
                                                                                                                                                                                                                                                                                membership::Instance1>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("FinalityTracker"),
                                                                                                                                                                 storage:
                                                                                                                                                                     None,
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(finality_tracker::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(finality_tracker::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<finality_tracker::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Grandpa"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(grandpa::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(grandpa::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ grandpa >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_grandpa
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_grandpa
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(grandpa::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<grandpa::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Treasury"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(treasury::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(treasury::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ treasury >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_treasury
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_treasury
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(treasury::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<treasury::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Contracts"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(contracts::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(contracts::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ contracts >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_contracts
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_contracts
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(contracts::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<contracts::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Sudo"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(sudo::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(sudo::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ sudo >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_sudo
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_sudo
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(sudo::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<sudo::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("ImOnline"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(im_online::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(im_online::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ im_online >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_im_online
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_im_online
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(im_online::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<im_online::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("AuthorityDiscovery"),
                                                                                                                                                                 storage:
                                                                                                                                                                     None,
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(authority_discovery::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(authority_discovery::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<authority_discovery::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Offences"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(offences::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(offences::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ offences >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_offences
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_offences
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(offences::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<offences::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("RandomnessCollectiveFlip"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(randomness_collective_flip::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(randomness_collective_flip::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     None,
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(randomness_collective_flip::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<randomness_collective_flip::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Nicks"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(nicks::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(nicks::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ nicks >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_nicks
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_nicks
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(nicks::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<nicks::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Transx"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(transx::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(transx::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ transx >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_transx
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_transx
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(transx::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<transx::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Register"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(register::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(register::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ register >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_register
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_register
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(register::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<register::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Mine"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(mine::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(mine::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ mine >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_mine
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_mine
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(mine::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<mine::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),},
                                                                                                                       ::frame_support::metadata::ModuleMetadata{name:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode("Report"),
                                                                                                                                                                 storage:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(report::Module::<Runtime>::storage_metadata))),
                                                                                                                                                                 calls:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(report::Module::<Runtime>::call_functions))),
                                                                                                                                                                 event:
                                                                                                                                                                     Some(::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode({
                                                                                                                                                                                                                                                                     enum ProcMacroHack
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                         Value
                                                                                                                                                                                                                                                                             =
                                                                                                                                                                                                                                                                             ("Runtime :: [< __module_events_ report >]",
                                                                                                                                                                                                                                                                              0).1,
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     macro_rules! proc_macro_call {
                                                                                                                                                                                                                                                                         ()
                                                                                                                                                                                                                                                                         =>
                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                 Runtime
                                                                                                                                                                                                                                                                                 ::
                                                                                                                                                                                                                                                                                 __module_events_report
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                         Runtime::__module_events_report
                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                 }))),
                                                                                                                                                                 constants:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(report::Module::<Runtime>::module_constants_metadata)),
                                                                                                                                                                 errors:
                                                                                                                                                                     ::frame_support::metadata::DecodeDifferent::Encode(::frame_support::metadata::FnEncode(<report::Module<Runtime>
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                ::frame_support::metadata::ModuleErrorMetadata>::metadata)),}]),}.into()
    }
}
#[cfg(any (feature = "std", test))]
pub type SystemConfig = system::GenesisConfig;
#[cfg(any (feature = "std", test))]
pub type BabeConfig = babe::GenesisConfig;
#[cfg(any (feature = "std", test))]
pub type IndicesConfig = indices::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type BalancesConfig = balances::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type StakingConfig = staking::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type SessionConfig = session::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type DemocracyConfig = democracy::GenesisConfig;
#[cfg(any (feature = "std", test))]
pub type CouncilConfig
    =
    collective::GenesisConfig<Runtime, collective::Instance1>;
#[cfg(any (feature = "std", test))]
pub type TechnicalCommitteeConfig
    =
    collective::GenesisConfig<Runtime, collective::Instance2>;
#[cfg(any (feature = "std", test))]
pub type TechnicalMembershipConfig
    =
    membership::GenesisConfig<Runtime, membership::Instance1>;
#[cfg(any (feature = "std", test))]
pub type GrandpaConfig = grandpa::GenesisConfig;
#[cfg(any (feature = "std", test))]
pub type TreasuryConfig = treasury::GenesisConfig;
#[cfg(any (feature = "std", test))]
pub type ContractsConfig = contracts::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type SudoConfig = sudo::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type ImOnlineConfig = im_online::GenesisConfig<Runtime>;
#[cfg(any (feature = "std", test))]
pub type AuthorityDiscoveryConfig = authority_discovery::GenesisConfig;
#[cfg(any (feature = "std", test))]
#[serde(rename_all = "camelCase")]
#[serde(deny_unknown_fields)]
pub struct GenesisConfig {
    pub system: Option<SystemConfig>,
    pub babe: Option<BabeConfig>,
    pub indices: Option<IndicesConfig>,
    pub balances: Option<BalancesConfig>,
    pub staking: Option<StakingConfig>,
    pub session: Option<SessionConfig>,
    pub democracy: Option<DemocracyConfig>,
    pub collective_Instance1: Option<CouncilConfig>,
    pub collective_Instance2: Option<TechnicalCommitteeConfig>,
    pub membership_Instance1: Option<TechnicalMembershipConfig>,
    pub grandpa: Option<GrandpaConfig>,
    pub treasury: Option<TreasuryConfig>,
    pub contracts: Option<ContractsConfig>,
    pub sudo: Option<SudoConfig>,
    pub im_online: Option<ImOnlineConfig>,
    pub authority_discovery: Option<AuthorityDiscoveryConfig>,
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _IMPL_SERIALIZE_FOR_GenesisConfig: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[allow(unused_macros)]
        macro_rules! try {
            ($ __expr : expr) =>
            {
                match $ __expr
                {
                    _serde :: export :: Ok (__val) => __val, _serde :: export
                    :: Err (__err) =>
                    { return _serde :: export :: Err (__err) ; }
                }
            }
        }
        #[automatically_derived]
        impl _serde::Serialize for GenesisConfig {
            fn serialize<__S>(&self, __serializer: __S)
             -> _serde::export::Result<__S::Ok, __S::Error> where
             __S: _serde::Serializer {
                let mut __serde_state =
                    match _serde::Serializer::serialize_struct(__serializer,
                                                               "GenesisConfig",
                                                               false as usize
                                                                   + 1 + 1 + 1
                                                                   + 1 + 1 + 1
                                                                   + 1 + 1 + 1
                                                                   + 1 + 1 + 1
                                                                   + 1 + 1 + 1
                                                                   + 1) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "system",
                                                                    &self.system)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "babe",
                                                                    &self.babe)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "indices",
                                                                    &self.indices)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "balances",
                                                                    &self.balances)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "staking",
                                                                    &self.staking)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "session",
                                                                    &self.session)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "democracy",
                                                                    &self.democracy)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "collectiveInstance1",
                                                                    &self.collective_Instance1)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "collectiveInstance2",
                                                                    &self.collective_Instance2)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "membershipInstance1",
                                                                    &self.membership_Instance1)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "grandpa",
                                                                    &self.grandpa)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "treasury",
                                                                    &self.treasury)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "contracts",
                                                                    &self.contracts)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "sudo",
                                                                    &self.sudo)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "imOnline",
                                                                    &self.im_online)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                    "authorityDiscovery",
                                                                    &self.authority_discovery)
                    {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _IMPL_DESERIALIZE_FOR_GenesisConfig: () =
    {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[allow(unused_macros)]
        macro_rules! try {
            ($ __expr : expr) =>
            {
                match $ __expr
                {
                    _serde :: export :: Ok (__val) => __val, _serde :: export
                    :: Err (__err) =>
                    { return _serde :: export :: Err (__err) ; }
                }
            }
        }
        #[automatically_derived]
        impl <'de> _serde::Deserialize<'de> for GenesisConfig {
            fn deserialize<__D>(__deserializer: __D)
             -> _serde::export::Result<Self, __D::Error> where
             __D: _serde::Deserializer<'de> {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                }
                struct __FieldVisitor;
                impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type
                    Value
                    =
                    __Field;
                    fn expecting(&self,
                                 __formatter: &mut _serde::export::Formatter)
                     -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter,
                                                             "field identifier")
                    }
                    fn visit_u64<__E>(self, __value: u64)
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            12u64 => _serde::export::Ok(__Field::__field12),
                            13u64 => _serde::export::Ok(__Field::__field13),
                            14u64 => _serde::export::Ok(__Field::__field14),
                            15u64 => _serde::export::Ok(__Field::__field15),
                            _ =>
                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                 &"field index 0 <= i < 16")),
                        }
                    }
                    fn visit_str<__E>(self, __value: &str)
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            "system" => _serde::export::Ok(__Field::__field0),
                            "babe" => _serde::export::Ok(__Field::__field1),
                            "indices" =>
                            _serde::export::Ok(__Field::__field2),
                            "balances" =>
                            _serde::export::Ok(__Field::__field3),
                            "staking" =>
                            _serde::export::Ok(__Field::__field4),
                            "session" =>
                            _serde::export::Ok(__Field::__field5),
                            "democracy" =>
                            _serde::export::Ok(__Field::__field6),
                            "collectiveInstance1" =>
                            _serde::export::Ok(__Field::__field7),
                            "collectiveInstance2" =>
                            _serde::export::Ok(__Field::__field8),
                            "membershipInstance1" =>
                            _serde::export::Ok(__Field::__field9),
                            "grandpa" =>
                            _serde::export::Ok(__Field::__field10),
                            "treasury" =>
                            _serde::export::Ok(__Field::__field11),
                            "contracts" =>
                            _serde::export::Ok(__Field::__field12),
                            "sudo" => _serde::export::Ok(__Field::__field13),
                            "imOnline" =>
                            _serde::export::Ok(__Field::__field14),
                            "authorityDiscovery" =>
                            _serde::export::Ok(__Field::__field15),
                            _ => {
                                _serde::export::Err(_serde::de::Error::unknown_field(__value,
                                                                                     FIELDS))
                            }
                        }
                    }
                    fn visit_bytes<__E>(self, __value: &[u8])
                     -> _serde::export::Result<Self::Value, __E> where
                     __E: _serde::de::Error {
                        match __value {
                            b"system" =>
                            _serde::export::Ok(__Field::__field0),
                            b"babe" => _serde::export::Ok(__Field::__field1),
                            b"indices" =>
                            _serde::export::Ok(__Field::__field2),
                            b"balances" =>
                            _serde::export::Ok(__Field::__field3),
                            b"staking" =>
                            _serde::export::Ok(__Field::__field4),
                            b"session" =>
                            _serde::export::Ok(__Field::__field5),
                            b"democracy" =>
                            _serde::export::Ok(__Field::__field6),
                            b"collectiveInstance1" =>
                            _serde::export::Ok(__Field::__field7),
                            b"collectiveInstance2" =>
                            _serde::export::Ok(__Field::__field8),
                            b"membershipInstance1" =>
                            _serde::export::Ok(__Field::__field9),
                            b"grandpa" =>
                            _serde::export::Ok(__Field::__field10),
                            b"treasury" =>
                            _serde::export::Ok(__Field::__field11),
                            b"contracts" =>
                            _serde::export::Ok(__Field::__field12),
                            b"sudo" => _serde::export::Ok(__Field::__field13),
                            b"imOnline" =>
                            _serde::export::Ok(__Field::__field14),
                            b"authorityDiscovery" =>
                            _serde::export::Ok(__Field::__field15),
                            _ => {
                                let __value =
                                    &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_field(__value,
                                                                                     FIELDS))
                            }
                        }
                    }
                }
                impl <'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                     __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<GenesisConfig>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type
                    Value
                    =
                    GenesisConfig;
                    fn expecting(&self,
                                 __formatter: &mut _serde::export::Formatter)
                     -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter,
                                                             "struct GenesisConfig")
                    }
                    #[inline]
                    fn visit_seq<__A>(self, mut __seq: __A)
                     -> _serde::export::Result<Self::Value, __A::Error> where
                     __A: _serde::de::SeqAccess<'de> {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Option<SystemConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Option<BabeConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<Option<IndicesConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<Option<BalancesConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field4 =
                            match match _serde::de::SeqAccess::next_element::<Option<StakingConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<Option<SessionConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field6 =
                            match match _serde::de::SeqAccess::next_element::<Option<DemocracyConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field7 =
                            match match _serde::de::SeqAccess::next_element::<Option<CouncilConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field8 =
                            match match _serde::de::SeqAccess::next_element::<Option<TechnicalCommitteeConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field9 =
                            match match _serde::de::SeqAccess::next_element::<Option<TechnicalMembershipConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field10 =
                            match match _serde::de::SeqAccess::next_element::<Option<GrandpaConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(10usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field11 =
                            match match _serde::de::SeqAccess::next_element::<Option<TreasuryConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(11usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field12 =
                            match match _serde::de::SeqAccess::next_element::<Option<ContractsConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(12usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field13 =
                            match match _serde::de::SeqAccess::next_element::<Option<SudoConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(13usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field14 =
                            match match _serde::de::SeqAccess::next_element::<Option<ImOnlineConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(14usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        let __field15 =
                            match match _serde::de::SeqAccess::next_element::<Option<AuthorityDiscoveryConfig>>(&mut __seq)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(15usize,
                                                                                                 &"struct GenesisConfig with 16 elements"));
                                }
                            };
                        _serde::export::Ok(GenesisConfig{system: __field0,
                                                         babe: __field1,
                                                         indices: __field2,
                                                         balances: __field3,
                                                         staking: __field4,
                                                         session: __field5,
                                                         democracy: __field6,
                                                         collective_Instance1:
                                                             __field7,
                                                         collective_Instance2:
                                                             __field8,
                                                         membership_Instance1:
                                                             __field9,
                                                         grandpa: __field10,
                                                         treasury: __field11,
                                                         contracts: __field12,
                                                         sudo: __field13,
                                                         im_online: __field14,
                                                         authority_discovery:
                                                             __field15,})
                    }
                    #[inline]
                    fn visit_map<__A>(self, mut __map: __A)
                     -> _serde::export::Result<Self::Value, __A::Error> where
                     __A: _serde::de::MapAccess<'de> {
                        let mut __field0:
                                _serde::export::Option<Option<SystemConfig>> =
                            _serde::export::None;
                        let mut __field1:
                                _serde::export::Option<Option<BabeConfig>> =
                            _serde::export::None;
                        let mut __field2:
                                _serde::export::Option<Option<IndicesConfig>> =
                            _serde::export::None;
                        let mut __field3:
                                _serde::export::Option<Option<BalancesConfig>> =
                            _serde::export::None;
                        let mut __field4:
                                _serde::export::Option<Option<StakingConfig>> =
                            _serde::export::None;
                        let mut __field5:
                                _serde::export::Option<Option<SessionConfig>> =
                            _serde::export::None;
                        let mut __field6:
                                _serde::export::Option<Option<DemocracyConfig>> =
                            _serde::export::None;
                        let mut __field7:
                                _serde::export::Option<Option<CouncilConfig>> =
                            _serde::export::None;
                        let mut __field8:
                                _serde::export::Option<Option<TechnicalCommitteeConfig>> =
                            _serde::export::None;
                        let mut __field9:
                                _serde::export::Option<Option<TechnicalMembershipConfig>> =
                            _serde::export::None;
                        let mut __field10:
                                _serde::export::Option<Option<GrandpaConfig>> =
                            _serde::export::None;
                        let mut __field11:
                                _serde::export::Option<Option<TreasuryConfig>> =
                            _serde::export::None;
                        let mut __field12:
                                _serde::export::Option<Option<ContractsConfig>> =
                            _serde::export::None;
                        let mut __field13:
                                _serde::export::Option<Option<SudoConfig>> =
                            _serde::export::None;
                        let mut __field14:
                                _serde::export::Option<Option<ImOnlineConfig>> =
                            _serde::export::None;
                        let mut __field15:
                                _serde::export::Option<Option<AuthorityDiscoveryConfig>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("system"));
                                    }
                                    __field0 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<SystemConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("babe"));
                                    }
                                    __field1 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<BabeConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("indices"));
                                    }
                                    __field2 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<IndicesConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("balances"));
                                    }
                                    __field3 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<BalancesConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("staking"));
                                    }
                                    __field4 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StakingConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field5 => {
                                    if _serde::export::Option::is_some(&__field5)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("session"));
                                    }
                                    __field5 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<SessionConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field6 => {
                                    if _serde::export::Option::is_some(&__field6)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("democracy"));
                                    }
                                    __field6 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<DemocracyConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field7 => {
                                    if _serde::export::Option::is_some(&__field7)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("collectiveInstance1"));
                                    }
                                    __field7 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<CouncilConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field8 => {
                                    if _serde::export::Option::is_some(&__field8)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("collectiveInstance2"));
                                    }
                                    __field8 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<TechnicalCommitteeConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field9 => {
                                    if _serde::export::Option::is_some(&__field9)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("membershipInstance1"));
                                    }
                                    __field9 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<TechnicalMembershipConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field10 => {
                                    if _serde::export::Option::is_some(&__field10)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("grandpa"));
                                    }
                                    __field10 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<GrandpaConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field11 => {
                                    if _serde::export::Option::is_some(&__field11)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("treasury"));
                                    }
                                    __field11 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<TreasuryConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field12 => {
                                    if _serde::export::Option::is_some(&__field12)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("contracts"));
                                    }
                                    __field12 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<ContractsConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field13 => {
                                    if _serde::export::Option::is_some(&__field13)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("sudo"));
                                    }
                                    __field13 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<SudoConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field14 => {
                                    if _serde::export::Option::is_some(&__field14)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("imOnline"));
                                    }
                                    __field14 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<ImOnlineConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                                __Field::__field15 => {
                                    if _serde::export::Option::is_some(&__field15)
                                       {
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::duplicate_field("authorityDiscovery"));
                                    }
                                    __field15 =
                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<AuthorityDiscoveryConfig>>(&mut __map)
                                                                 {
                                                                 _serde::export::Ok(__val)
                                                                 => __val,
                                                                 _serde::export::Err(__err)
                                                                 => {
                                                                     return _serde::export::Err(__err);
                                                                 }
                                                             });
                                }
                            }
                        }
                        let __field0 =
                            match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("system")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field1 =
                            match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("babe")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field2 =
                            match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("indices")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field3 =
                            match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("balances")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field4 =
                            match __field4 {
                                _serde::export::Some(__field4) => __field4,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("staking")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field5 =
                            match __field5 {
                                _serde::export::Some(__field5) => __field5,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("session")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field6 =
                            match __field6 {
                                _serde::export::Some(__field6) => __field6,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("democracy")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field7 =
                            match __field7 {
                                _serde::export::Some(__field7) => __field7,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("collectiveInstance1")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field8 =
                            match __field8 {
                                _serde::export::Some(__field8) => __field8,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("collectiveInstance2")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field9 =
                            match __field9 {
                                _serde::export::Some(__field9) => __field9,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("membershipInstance1")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field10 =
                            match __field10 {
                                _serde::export::Some(__field10) => __field10,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("grandpa")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field11 =
                            match __field11 {
                                _serde::export::Some(__field11) => __field11,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("treasury")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field12 =
                            match __field12 {
                                _serde::export::Some(__field12) => __field12,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("contracts")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field13 =
                            match __field13 {
                                _serde::export::Some(__field13) => __field13,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("sudo")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field14 =
                            match __field14 {
                                _serde::export::Some(__field14) => __field14,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("imOnline")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        let __field15 =
                            match __field15 {
                                _serde::export::Some(__field15) => __field15,
                                _serde::export::None =>
                                match _serde::private::de::missing_field("authorityDiscovery")
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                            };
                        _serde::export::Ok(GenesisConfig{system: __field0,
                                                         babe: __field1,
                                                         indices: __field2,
                                                         balances: __field3,
                                                         staking: __field4,
                                                         session: __field5,
                                                         democracy: __field6,
                                                         collective_Instance1:
                                                             __field7,
                                                         collective_Instance2:
                                                             __field8,
                                                         membership_Instance1:
                                                             __field9,
                                                         grandpa: __field10,
                                                         treasury: __field11,
                                                         contracts: __field12,
                                                         sudo: __field13,
                                                         im_online: __field14,
                                                         authority_discovery:
                                                             __field15,})
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["system", "babe", "indices", "balances", "staking",
                      "session", "democracy", "collectiveInstance1",
                      "collectiveInstance2", "membershipInstance1", "grandpa",
                      "treasury", "contracts", "sudo", "imOnline",
                      "authorityDiscovery"];
                _serde::Deserializer::deserialize_struct(__deserializer,
                                                         "GenesisConfig",
                                                         FIELDS,
                                                         __Visitor{marker:
                                                                       _serde::export::PhantomData::<GenesisConfig>,
                                                                   lifetime:
                                                                       _serde::export::PhantomData,})
            }
        }
    };
#[cfg(any (feature = "std", test))]
impl ::sp_runtime::BuildStorage for GenesisConfig {
    fn assimilate_storage(&self,
                          storage:
                              &mut (::sp_runtime::StorageOverlay,
                                    ::sp_runtime::ChildrenStorageOverlay))
     -> std::result::Result<(), String> {
        if let Some(ref extra) = self.system {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      system::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                      storage)?;
        }
        if let Some(ref extra) = self.babe {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      babe::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                    storage)?;
        }
        if let Some(ref extra) = self.indices {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      indices::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                       storage)?;
        }
        if let Some(ref extra) = self.balances {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      balances::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                        storage)?;
        }
        if let Some(ref extra) = self.staking {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      staking::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                       storage)?;
        }
        if let Some(ref extra) = self.session {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      session::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                       storage)?;
        }
        if let Some(ref extra) = self.democracy {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      democracy::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                         storage)?;
        }
        if let Some(ref extra) = self.collective_Instance1 {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      collective::Instance1>::build_module_genesis_storage(extra,
                                                                                                           storage)?;
        }
        if let Some(ref extra) = self.collective_Instance2 {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      collective::Instance2>::build_module_genesis_storage(extra,
                                                                                                           storage)?;
        }
        if let Some(ref extra) = self.membership_Instance1 {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      membership::Instance1>::build_module_genesis_storage(extra,
                                                                                                           storage)?;
        }
        if let Some(ref extra) = self.grandpa {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      grandpa::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                       storage)?;
        }
        if let Some(ref extra) = self.treasury {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      treasury::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                        storage)?;
        }
        if let Some(ref extra) = self.contracts {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      contracts::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                         storage)?;
        }
        if let Some(ref extra) = self.sudo {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      sudo::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                    storage)?;
        }
        if let Some(ref extra) = self.im_online {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      im_online::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                         storage)?;
        }
        if let Some(ref extra) = self.authority_discovery {
            ::sp_runtime::BuildModuleGenesisStorage::<Runtime,
                                                      authority_discovery::__InherentHiddenInstance>::build_module_genesis_storage(extra,
                                                                                                                                   storage)?;
        }
        Ok(())
    }
}
trait InherentDataExt {
    fn create_extrinsics(&self)
    ->
        ::frame_support::inherent::Vec<<Block as
                                       ::frame_support::inherent::BlockT>::Extrinsic>;
    fn check_extrinsics(&self, block: &Block)
    -> ::frame_support::inherent::CheckInherentsResult;
}
impl InherentDataExt for ::frame_support::inherent::InherentData {
    fn create_extrinsics(&self)
     ->
         ::frame_support::inherent::Vec<<Block as
                                        ::frame_support::inherent::BlockT>::Extrinsic> {
        use ::frame_support::inherent::ProvideInherent;
        use ::frame_support::inherent::Extrinsic;
        let mut inherents = Vec::new();
        if let Some(inherent) = Babe::create_inherent(self) {
            inherents.push(UncheckedExtrinsic::new(Call::Timestamp(inherent),
                                                   None).expect("Runtime UncheckedExtrinsic is not Opaque, so it has to return `Some`; qed"));
        }
        if let Some(inherent) = Timestamp::create_inherent(self) {
            inherents.push(UncheckedExtrinsic::new(Call::Timestamp(inherent),
                                                   None).expect("Runtime UncheckedExtrinsic is not Opaque, so it has to return `Some`; qed"));
        }
        if let Some(inherent) = Authorship::create_inherent(self) {
            inherents.push(UncheckedExtrinsic::new(Call::Authorship(inherent),
                                                   None).expect("Runtime UncheckedExtrinsic is not Opaque, so it has to return `Some`; qed"));
        }
        if let Some(inherent) = FinalityTracker::create_inherent(self) {
            inherents.push(UncheckedExtrinsic::new(Call::FinalityTracker(inherent),
                                                   None).expect("Runtime UncheckedExtrinsic is not Opaque, so it has to return `Some`; qed"));
        }
        inherents
    }
    fn check_extrinsics(&self, block: &Block)
     -> ::frame_support::inherent::CheckInherentsResult {
        use ::frame_support::inherent::{ProvideInherent, IsFatalError};
        let mut result =
            ::frame_support::inherent::CheckInherentsResult::new();
        for xt in block.extrinsics() {
            if ::frame_support::inherent::Extrinsic::is_signed(xt).unwrap_or(false)
               {
                break ;
            }
            match xt.function {
                Call::Timestamp(ref call) => {
                    if let Err(e) = Babe::check_inherent(call, self) {
                        result.put_error(Babe::INHERENT_IDENTIFIER,
                                         &e).expect("There is only one fatal error; qed");
                        if e.is_fatal_error() { return result; }
                    }
                }
                _ => { }
            }
            match xt.function {
                Call::Timestamp(ref call) => {
                    if let Err(e) = Timestamp::check_inherent(call, self) {
                        result.put_error(Timestamp::INHERENT_IDENTIFIER,
                                         &e).expect("There is only one fatal error; qed");
                        if e.is_fatal_error() { return result; }
                    }
                }
                _ => { }
            }
            match xt.function {
                Call::Authorship(ref call) => {
                    if let Err(e) = Authorship::check_inherent(call, self) {
                        result.put_error(Authorship::INHERENT_IDENTIFIER,
                                         &e).expect("There is only one fatal error; qed");
                        if e.is_fatal_error() { return result; }
                    }
                }
                _ => { }
            }
            match xt.function {
                Call::FinalityTracker(ref call) => {
                    if let Err(e) =
                           FinalityTracker::check_inherent(call, self) {
                        result.put_error(FinalityTracker::INHERENT_IDENTIFIER,
                                         &e).expect("There is only one fatal error; qed");
                        if e.is_fatal_error() { return result; }
                    }
                }
                _ => { }
            }
        }
        result
    }
}
#[allow(deprecated)]
impl ::frame_support::unsigned::ValidateUnsigned for Runtime {
    type
    Call
    =
    Call;
    fn pre_dispatch(call: &Self::Call)
     -> Result<(), ::frame_support::unsigned::TransactionValidityError> {

        #[allow(unreachable_patterns)]
        match call {
            Call::ImOnline(inner_call) => ImOnline::pre_dispatch(inner_call),
            _ => Ok(()),
        }
    }
    fn validate_unsigned(call: &Self::Call)
     -> ::frame_support::unsigned::TransactionValidity {

        #[allow(unreachable_patterns)]
        match call {
            Call::ImOnline(inner_call) =>
            ImOnline::validate_unsigned(inner_call),
            _ =>
            ::frame_support::unsigned::UnknownTransaction::NoUnsignedValidator.into(),
        }
    }
}
/// The address format for describing accounts.
pub type Address = <Indices as StaticLookup>::Source;
/// Block header type as expected by this runtime.
pub type Header = generic::Header<BlockNumber, BlakeTwo256>;
/// Block type as expected by this runtime.
pub type Block = generic::Block<Header, UncheckedExtrinsic>;
/// A Block signed with a Justification
pub type SignedBlock = generic::SignedBlock<Block>;
/// BlockId type as expected by this runtime.
pub type BlockId = generic::BlockId<Block>;
/// The SignedExtension to the basic transaction logic.
pub type SignedExtra
    =
    (system::CheckVersion<Runtime>, system::CheckGenesis<Runtime>,
     system::CheckEra<Runtime>, system::CheckNonce<Runtime>,
     system::CheckWeight<Runtime>,
     transaction_payment::ChargeTransactionPayment<Runtime>,
     contracts::CheckBlockGasLimit<Runtime>);
/// Unchecked extrinsic type as expected by this runtime.
pub type UncheckedExtrinsic
    =
    generic::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;
/// The payload being signed in transactions.
pub type SignedPayload = generic::SignedPayload<Call, SignedExtra>;
/// Extrinsic type that has already been checked.
pub type CheckedExtrinsic
    =
    generic::CheckedExtrinsic<AccountId, Call, SignedExtra>;
/// Executive: handles dispatch to the various modules.
pub type Executive
    =
    executive::Executive<Runtime, Block, system::ChainContext<Runtime>,
                         Runtime, AllModules>;
#[doc(hidden)]
mod sp_api_hidden_includes_IMPL_RUNTIME_APIS {
    pub extern crate sp_api as sp_api;
}
pub struct RuntimeApi {
}
#[doc = r" Implements all runtime apis for the client side."]
#[cfg(any (feature = "std", test))]
pub struct RuntimeApiImpl<C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                   as
                                                                                                   self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
                          'static> {
    call: &'static C,
    commit_on_success: std::cell::RefCell<bool>,
    initialized_block: std::cell::RefCell<Option<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                 as
                                                                                                                 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>>,
    changes: std::cell::RefCell<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::OverlayedChanges>,
    recorder: Option<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ProofRecorder<<Runtime
                                                                                           as
                                                                                           self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>,
}
#[cfg(any (feature = "std", test))]
unsafe impl <C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                      as
                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>
 Send for RuntimeApiImpl<C> {
}
#[cfg(any (feature = "std", test))]
unsafe impl <C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                      as
                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>
 Sync for RuntimeApiImpl<C> {
}
#[cfg(any (feature = "std", test))]
impl <C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                               as
                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>
 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ApiExt<<Runtime as
                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<C> {
    type
    Error
    =
    C::Error;
    fn map_api_result<F: FnOnce(&Self) -> std::result::Result<R, E>, R,
                      E>(&self, map_call: F) -> std::result::Result<R, E>
     where Self: Sized {
        *self.commit_on_success.borrow_mut() = false;
        let res = map_call(self);
        *self.commit_on_success.borrow_mut() = true;
        self.commit_on_ok(&res);
        res
    }
    fn runtime_version_at(&self,
                          at:
                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                               as
                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::RuntimeVersion,
                             C::Error> {
        self.call.runtime_version_at(at)
    }
    fn record_proof(&mut self) { self.recorder = Some(Default::default()); }
    fn extract_proof(&mut self)
     ->
         Option<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::StorageProof> {
        self.recorder.take().map(|recorder|
                                     {
                                         let trie_nodes =
                                             recorder.read().iter().filter_map(|(_k,
                                                                                 v)|
                                                                                   v.as_ref().map(|v|
                                                                                                      v.to_vec())).collect();
                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::StorageProof::new(trie_nodes)
                                     })
    }
}
#[cfg(any (feature = "std", test))]
impl <C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                               as
                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ConstructRuntimeApi<<Runtime
                                                                             as
                                                                             self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                             C>
 for RuntimeApi {
    type
    RuntimeApi
    =
    RuntimeApiImpl<C>;
    fn construct_runtime_api<'a>(call: &'a C)
     ->
         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ApiRef<'a,
                                                                        Self::RuntimeApi> {
        RuntimeApiImpl{call: unsafe { std::mem::transmute(call) },
                       commit_on_success: true.into(),
                       initialized_block: None.into(),
                       changes: Default::default(),
                       recorder: Default::default(),}.into()
    }
}
#[cfg(any (feature = "std", test))]
impl <C: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                               as
                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>
 RuntimeApiImpl<C> {
    fn call_api_at<R: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode +
                   self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode +
                   PartialEq,
                   F: FnOnce(&C, &Self,
                             &std::cell::RefCell<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::OverlayedChanges>,
                             &std::cell::RefCell<Option<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                        as
                                                                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>>,
                             &Option<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ProofRecorder<<Runtime
                                                                                                           as
                                                                                                           self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>>)
                   ->
                   std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<R>,
                                       E>, E>(&self, call_api_at: F)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<R>,
                             E> {
        let res =
            call_api_at(&self.call, self, &self.changes,
                        &self.initialized_block, &self.recorder);
        self.commit_on_ok(&res);
        res
    }
    fn commit_on_ok<R, E>(&self, res: &std::result::Result<R, E>) {
        if *self.commit_on_success.borrow() {
            if res.is_err() {
                self.changes.borrow_mut().discard_prospective();
            } else { self.changes.borrow_mut().commit_prospective(); }
        }
    }
}
impl sp_api::runtime_decl_for_Core::Core<Block> for Runtime {
    fn version() -> RuntimeVersion { VERSION }
    fn execute_block(block: Block) { Executive::execute_block(block) }
    fn initialize_block(header: &<Block as BlockT>::Header) {
        Executive::initialize_block(header)
    }
}
impl sp_api::runtime_decl_for_Metadata::Metadata<Block> for Runtime {
    fn metadata() -> OpaqueMetadata { Runtime::metadata().into() }
}
impl block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block> for
 Runtime {
    fn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic)
     -> ApplyExtrinsicResult {
        Executive::apply_extrinsic(extrinsic)
    }
    fn finalize_block() -> <Block as BlockT>::Header {
        Executive::finalize_block()
    }
    fn inherent_extrinsics(data: InherentData)
     -> Vec<<Block as BlockT>::Extrinsic> {
        data.create_extrinsics()
    }
    fn check_inherents(block: Block, data: InherentData)
     -> CheckInherentsResult {
        data.check_extrinsics(&block)
    }
    fn random_seed() -> <Block as BlockT>::Hash {
        RandomnessCollectiveFlip::random_seed()
    }
}
impl txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::TaggedTransactionQueue<Block>
 for Runtime {
    fn validate_transaction(tx: <Block as BlockT>::Extrinsic)
     -> TransactionValidity {
        Executive::validate_transaction(tx)
    }
}
impl offchain_primitives::runtime_decl_for_OffchainWorkerApi::OffchainWorkerApi<Block>
 for Runtime {
    fn offchain_worker(number: NumberFor<Block>) {
        Executive::offchain_worker(number)
    }
}
impl fg_primitives::runtime_decl_for_GrandpaApi::GrandpaApi<Block> for Runtime
 {
    fn grandpa_authorities() -> GrandpaAuthorityList {
        Grandpa::grandpa_authorities()
    }
}
impl babe_primitives::runtime_decl_for_BabeApi::BabeApi<Block> for Runtime {
    fn configuration() -> babe_primitives::BabeConfiguration {
        babe_primitives::BabeConfiguration{slot_duration:
                                               Babe::slot_duration(),
                                           epoch_length: EpochDuration::get(),
                                           c: PRIMARY_PROBABILITY,
                                           genesis_authorities:
                                               Babe::authorities(),
                                           randomness: Babe::randomness(),
                                           secondary_slots: true,}
    }
}
impl authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::AuthorityDiscoveryApi<Block>
 for Runtime {
    fn authorities() -> Vec<AuthorityDiscoveryId> {
        AuthorityDiscovery::authorities()
    }
}
impl system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::AccountNonceApi<Block,
                                                                               AccountId,
                                                                               Index>
 for Runtime {
    fn account_nonce(account: AccountId) -> Index {
        System::account_nonce(account)
    }
}
impl contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::ContractsApi<Block,
                                                                            AccountId,
                                                                            Balance>
 for Runtime {
    fn call(origin: AccountId, dest: AccountId, value: Balance,
            gas_limit: u64, input_data: Vec<u8>) -> ContractExecResult {
        let exec_result =
            Contracts::bare_call(origin, dest.into(), value, gas_limit,
                                 input_data);
        match exec_result {
            Ok(v) =>
            ContractExecResult::Success{status: v.status, data: v.data,},
            Err(_) => ContractExecResult::Error,
        }
    }
    fn get_storage(address: AccountId, key: [u8; 32])
     -> contracts_rpc_runtime_api::GetStorageResult {
        Contracts::get_storage(address,
                               key).map_err(|rpc_err|
                                                {
                                                    use contracts::GetStorageError;
                                                    use contracts_rpc_runtime_api::{GetStorageError
                                                                                    as
                                                                                    RpcGetStorageError};

                                                    #[doc =
                                                      " Map the contract error into the RPC layer error."]
                                                    match rpc_err {
                                                        GetStorageError::ContractDoesntExist
                                                        =>
                                                        RpcGetStorageError::ContractDoesntExist,
                                                        GetStorageError::IsTombstone
                                                        =>
                                                        RpcGetStorageError::IsTombstone,
                                                    }
                                                })
    }
}
impl transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::TransactionPaymentApi<Block,
                                                                                                        Balance,
                                                                                                        UncheckedExtrinsic>
 for Runtime {
    fn query_info(uxt: UncheckedExtrinsic, len: u32)
     -> RuntimeDispatchInfo<Balance> {
        TransactionPayment::query_info(uxt, len)
    }
}
impl sp_sesssion::runtime_decl_for_SessionKeys::SessionKeys<Block> for Runtime
 {
    fn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {
        SessionKeys::generate(seed)
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 sp_api::Core<<Runtime as
              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn Core_version_runtime_api_impl(&self,
                                     at:
                                         &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                          as
                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                     context:
                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                     params: Option<()>,
                                     params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<RuntimeVersion>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 sp_api::runtime_decl_for_Core::version_call_api_at(call_runtime_at,
                                                                                    core_api,
                                                                                    at,
                                                                                    params_encoded,
                                                                                    changes,
                                                                                    initialized_block,
                                                                                    params.map(|p|
                                                                                                   {
                                                                                                       sp_api::runtime_decl_for_Core::version_native_call_generator::<Runtime,
                                                                                                                                                                      <Runtime
                                                                                                                                                                      as
                                                                                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                      Block>()
                                                                                                   }),
                                                                                    context,
                                                                                    recorder)
                             })
    }
    fn Core_execute_block_runtime_api_impl(&self,
                                           at:
                                               &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                as
                                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                           context:
                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                           params:
                                               Option<(<Runtime as
                                                       self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock)>,
                                           params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<()>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 sp_api::runtime_decl_for_Core::execute_block_call_api_at(call_runtime_at,
                                                                                          core_api,
                                                                                          at,
                                                                                          params_encoded,
                                                                                          changes,
                                                                                          initialized_block,
                                                                                          params.map(|p|
                                                                                                         {
                                                                                                             sp_api::runtime_decl_for_Core::execute_block_native_call_generator::<Runtime,
                                                                                                                                                                                  <Runtime
                                                                                                                                                                                  as
                                                                                                                                                                                  self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                  Block>(p)
                                                                                                         }),
                                                                                          context,
                                                                                          recorder)
                             })
    }
    fn Core_initialize_block_runtime_api_impl(&self,
                                              at:
                                                  &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                   as
                                                                                                                   self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                              context:
                                                  self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                              params:
                                                  Option<(&<<Runtime as
                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                           as
                                                           BlockT>::Header)>,
                                              params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<()>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 sp_api::runtime_decl_for_Core::initialize_block_call_api_at(call_runtime_at,
                                                                                             core_api,
                                                                                             at,
                                                                                             params_encoded,
                                                                                             changes,
                                                                                             initialized_block,
                                                                                             params.map(|p|
                                                                                                            {
                                                                                                                sp_api::runtime_decl_for_Core::initialize_block_native_call_generator::<Runtime,
                                                                                                                                                                                        <Runtime
                                                                                                                                                                                        as
                                                                                                                                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                        Block>(p)
                                                                                                            }),
                                                                                             context,
                                                                                             recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 sp_api::Metadata<<Runtime as
                  self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn Metadata_metadata_runtime_api_impl(&self,
                                          at:
                                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                               as
                                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                          context:
                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                          params: Option<()>,
                                          params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<OpaqueMetadata>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 sp_api::runtime_decl_for_Metadata::metadata_call_api_at(call_runtime_at,
                                                                                         core_api,
                                                                                         at,
                                                                                         params_encoded,
                                                                                         changes,
                                                                                         initialized_block,
                                                                                         params.map(|p|
                                                                                                        {
                                                                                                            sp_api::runtime_decl_for_Metadata::metadata_native_call_generator::<Runtime,
                                                                                                                                                                                <Runtime
                                                                                                                                                                                as
                                                                                                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                Block>()
                                                                                                        }),
                                                                                         context,
                                                                                         recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 block_builder_api::BlockBuilder<<Runtime as
                                 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn BlockBuilder_apply_extrinsic_runtime_api_impl(&self,
                                                     at:
                                                         &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                          as
                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                     context:
                                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                     params:
                                                         Option<(<<Runtime as
                                                                  self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                                 as
                                                                 BlockT>::Extrinsic)>,
                                                     params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<ApplyExtrinsicResult>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 block_builder_api::runtime_decl_for_BlockBuilder::apply_extrinsic_call_api_at(call_runtime_at,
                                                                                                               core_api,
                                                                                                               at,
                                                                                                               params_encoded,
                                                                                                               changes,
                                                                                                               initialized_block,
                                                                                                               params.map(|p|
                                                                                                                              {
                                                                                                                                  block_builder_api::runtime_decl_for_BlockBuilder::apply_extrinsic_native_call_generator::<Runtime,
                                                                                                                                                                                                                            <Runtime
                                                                                                                                                                                                                            as
                                                                                                                                                                                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                            Block>(p)
                                                                                                                              }),
                                                                                                               context,
                                                                                                               recorder)
                             })
    }
    fn BlockBuilder_finalize_block_runtime_api_impl(&self,
                                                    at:
                                                        &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                         as
                                                                                                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                    context:
                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                    params: Option<()>,
                                                    params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<<<Runtime
                                                                                                      as
                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                                                                     as
                                                                                                     BlockT>::Header>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 block_builder_api::runtime_decl_for_BlockBuilder::finalize_block_call_api_at(call_runtime_at,
                                                                                                              core_api,
                                                                                                              at,
                                                                                                              params_encoded,
                                                                                                              changes,
                                                                                                              initialized_block,
                                                                                                              params.map(|p|
                                                                                                                             {
                                                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::finalize_block_native_call_generator::<Runtime,
                                                                                                                                                                                                                          <Runtime
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                          Block>()
                                                                                                                             }),
                                                                                                              context,
                                                                                                              recorder)
                             })
    }
    fn BlockBuilder_inherent_extrinsics_runtime_api_impl(&self,
                                                         at:
                                                             &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                              as
                                                                                                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                         context:
                                                             self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                         params:
                                                             Option<(InherentData)>,
                                                         params_encoded:
                                                             Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<Vec<<<Runtime
                                                                                                          as
                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                                                                         as
                                                                                                         BlockT>::Extrinsic>>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 block_builder_api::runtime_decl_for_BlockBuilder::inherent_extrinsics_call_api_at(call_runtime_at,
                                                                                                                   core_api,
                                                                                                                   at,
                                                                                                                   params_encoded,
                                                                                                                   changes,
                                                                                                                   initialized_block,
                                                                                                                   params.map(|p|
                                                                                                                                  {
                                                                                                                                      block_builder_api::runtime_decl_for_BlockBuilder::inherent_extrinsics_native_call_generator::<Runtime,
                                                                                                                                                                                                                                    <Runtime
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                    Block>(p)
                                                                                                                                  }),
                                                                                                                   context,
                                                                                                                   recorder)
                             })
    }
    fn BlockBuilder_check_inherents_runtime_api_impl(&self,
                                                     at:
                                                         &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                          as
                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                     context:
                                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                     params:
                                                         Option<(<Runtime as
                                                                 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                 InherentData)>,
                                                     params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<CheckInherentsResult>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 block_builder_api::runtime_decl_for_BlockBuilder::check_inherents_call_api_at(call_runtime_at,
                                                                                                               core_api,
                                                                                                               at,
                                                                                                               params_encoded,
                                                                                                               changes,
                                                                                                               initialized_block,
                                                                                                               params.map(|p|
                                                                                                                              {
                                                                                                                                  block_builder_api::runtime_decl_for_BlockBuilder::check_inherents_native_call_generator::<Runtime,
                                                                                                                                                                                                                            <Runtime
                                                                                                                                                                                                                            as
                                                                                                                                                                                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                            Block>(p.0,
                                                                                                                                                                                                                                   p.1)
                                                                                                                              }),
                                                                                                               context,
                                                                                                               recorder)
                             })
    }
    fn BlockBuilder_random_seed_runtime_api_impl(&self,
                                                 at:
                                                     &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                      as
                                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                 context:
                                                     self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                 params: Option<()>,
                                                 params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<<<Runtime
                                                                                                      as
                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                                                                     as
                                                                                                     BlockT>::Hash>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 block_builder_api::runtime_decl_for_BlockBuilder::random_seed_call_api_at(call_runtime_at,
                                                                                                           core_api,
                                                                                                           at,
                                                                                                           params_encoded,
                                                                                                           changes,
                                                                                                           initialized_block,
                                                                                                           params.map(|p|
                                                                                                                          {
                                                                                                                              block_builder_api::runtime_decl_for_BlockBuilder::random_seed_native_call_generator::<Runtime,
                                                                                                                                                                                                                    <Runtime
                                                                                                                                                                                                                    as
                                                                                                                                                                                                                    self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                    Block>()
                                                                                                                          }),
                                                                                                           context,
                                                                                                           recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 txpool_runtime_api::TaggedTransactionQueue<<Runtime as
                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn TaggedTransactionQueue_validate_transaction_runtime_api_impl(&self,
                                                                    at:
                                                                        &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                                         as
                                                                                                                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                                    context:
                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                                    params:
                                                                        Option<(<<Runtime
                                                                                 as
                                                                                 self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock
                                                                                as
                                                                                BlockT>::Extrinsic)>,
                                                                    params_encoded:
                                                                        Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<TransactionValidity>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::validate_transaction_call_api_at(call_runtime_at,
                                                                                                                               core_api,
                                                                                                                               at,
                                                                                                                               params_encoded,
                                                                                                                               changes,
                                                                                                                               initialized_block,
                                                                                                                               params.map(|p|
                                                                                                                                              {
                                                                                                                                                  txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::validate_transaction_native_call_generator::<Runtime,
                                                                                                                                                                                                                                                            <Runtime
                                                                                                                                                                                                                                                            as
                                                                                                                                                                                                                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                                            Block>(p)
                                                                                                                                              }),
                                                                                                                               context,
                                                                                                                               recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 offchain_primitives::OffchainWorkerApi<<Runtime as
                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn OffchainWorkerApi_offchain_worker_runtime_api_impl(&self,
                                                          at:
                                                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                               as
                                                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                          context:
                                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                          params:
                                                              Option<(NumberFor<<Runtime
                                                                                as
                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>)>,
                                                          params_encoded:
                                                              Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<()>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 offchain_primitives::runtime_decl_for_OffchainWorkerApi::offchain_worker_call_api_at(call_runtime_at,
                                                                                                                      core_api,
                                                                                                                      at,
                                                                                                                      params_encoded,
                                                                                                                      changes,
                                                                                                                      initialized_block,
                                                                                                                      params.map(|p|
                                                                                                                                     {
                                                                                                                                         offchain_primitives::runtime_decl_for_OffchainWorkerApi::offchain_worker_native_call_generator::<Runtime,
                                                                                                                                                                                                                                          <Runtime
                                                                                                                                                                                                                                          as
                                                                                                                                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                          Block>(p)
                                                                                                                                     }),
                                                                                                                      context,
                                                                                                                      recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 fg_primitives::GrandpaApi<<Runtime as
                           self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn GrandpaApi_grandpa_authorities_runtime_api_impl(&self,
                                                       at:
                                                           &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                            as
                                                                                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                       context:
                                                           self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                       params: Option<()>,
                                                       params_encoded:
                                                           Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<GrandpaAuthorityList>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 fg_primitives::runtime_decl_for_GrandpaApi::grandpa_authorities_call_api_at(call_runtime_at,
                                                                                                             core_api,
                                                                                                             at,
                                                                                                             params_encoded,
                                                                                                             changes,
                                                                                                             initialized_block,
                                                                                                             params.map(|p|
                                                                                                                            {
                                                                                                                                fg_primitives::runtime_decl_for_GrandpaApi::grandpa_authorities_native_call_generator::<Runtime,
                                                                                                                                                                                                                        <Runtime
                                                                                                                                                                                                                        as
                                                                                                                                                                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                        Block>()
                                                                                                                            }),
                                                                                                             context,
                                                                                                             recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 babe_primitives::BabeApi<<Runtime as
                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn BabeApi_configuration_runtime_api_impl(&self,
                                              at:
                                                  &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                   as
                                                                                                                   self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                              context:
                                                  self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                              params: Option<()>,
                                              params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<babe_primitives::BabeConfiguration>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 babe_primitives::runtime_decl_for_BabeApi::configuration_call_api_at(call_runtime_at,
                                                                                                      core_api,
                                                                                                      at,
                                                                                                      params_encoded,
                                                                                                      changes,
                                                                                                      initialized_block,
                                                                                                      params.map(|p|
                                                                                                                     {
                                                                                                                         babe_primitives::runtime_decl_for_BabeApi::configuration_native_call_generator::<Runtime,
                                                                                                                                                                                                          <Runtime
                                                                                                                                                                                                          as
                                                                                                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                          Block>()
                                                                                                                     }),
                                                                                                      context,
                                                                                                      recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 authority_discovery_primitives::AuthorityDiscoveryApi<<Runtime as
                                                       self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn AuthorityDiscoveryApi_authorities_runtime_api_impl(&self,
                                                          at:
                                                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                               as
                                                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                          context:
                                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                          params: Option<()>,
                                                          params_encoded:
                                                              Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<Vec<AuthorityDiscoveryId>>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::authorities_call_api_at(call_runtime_at,
                                                                                                                                 core_api,
                                                                                                                                 at,
                                                                                                                                 params_encoded,
                                                                                                                                 changes,
                                                                                                                                 initialized_block,
                                                                                                                                 params.map(|p|
                                                                                                                                                {
                                                                                                                                                    authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::authorities_native_call_generator::<Runtime,
                                                                                                                                                                                                                                                                <Runtime
                                                                                                                                                                                                                                                                as
                                                                                                                                                                                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                                                Block>()
                                                                                                                                                }),
                                                                                                                                 context,
                                                                                                                                 recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 system_rpc_runtime_api::AccountNonceApi<<Runtime as
                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                         AccountId, Index> for
 RuntimeApiImpl<RuntimeApiImplCall> {
    fn AccountNonceApi_account_nonce_runtime_api_impl(&self,
                                                      at:
                                                          &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                           as
                                                                                                                           self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                      context:
                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                      params:
                                                          Option<(AccountId)>,
                                                      params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<Index>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::account_nonce_call_api_at(call_runtime_at,
                                                                                                                     core_api,
                                                                                                                     at,
                                                                                                                     params_encoded,
                                                                                                                     changes,
                                                                                                                     initialized_block,
                                                                                                                     params.map(|p|
                                                                                                                                    {
                                                                                                                                        system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::account_nonce_native_call_generator::<Runtime,
                                                                                                                                                                                                                                        <Runtime
                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                        Block,
                                                                                                                                                                                                                                        AccountId,
                                                                                                                                                                                                                                        Index>(p)
                                                                                                                                    }),
                                                                                                                     context,
                                                                                                                     recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 contracts_rpc_runtime_api::ContractsApi<<Runtime as
                                         self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                         AccountId, Balance> for
 RuntimeApiImpl<RuntimeApiImplCall> {
    fn ContractsApi_call_runtime_api_impl(&self,
                                          at:
                                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                               as
                                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                          context:
                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                          params:
                                              Option<(AccountId, AccountId,
                                                      Balance, u64, Vec<u8>)>,
                                          params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<ContractExecResult>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::call_call_api_at(call_runtime_at,
                                                                                                            core_api,
                                                                                                            at,
                                                                                                            params_encoded,
                                                                                                            changes,
                                                                                                            initialized_block,
                                                                                                            params.map(|p|
                                                                                                                           {
                                                                                                                               contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::call_native_call_generator::<Runtime,
                                                                                                                                                                                                                      <Runtime
                                                                                                                                                                                                                      as
                                                                                                                                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                      Block,
                                                                                                                                                                                                                      AccountId,
                                                                                                                                                                                                                      Balance>(p.0,
                                                                                                                                                                                                                               p.1,
                                                                                                                                                                                                                               p.2,
                                                                                                                                                                                                                               p.3,
                                                                                                                                                                                                                               p.4)
                                                                                                                           }),
                                                                                                            context,
                                                                                                            recorder)
                             })
    }
    fn ContractsApi_get_storage_runtime_api_impl(&self,
                                                 at:
                                                     &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                      as
                                                                                                                      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                 context:
                                                     self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                 params:
                                                     Option<(AccountId,
                                                             [u8; 32])>,
                                                 params_encoded: Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<contracts_rpc_runtime_api::GetStorageResult>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::get_storage_call_api_at(call_runtime_at,
                                                                                                                   core_api,
                                                                                                                   at,
                                                                                                                   params_encoded,
                                                                                                                   changes,
                                                                                                                   initialized_block,
                                                                                                                   params.map(|p|
                                                                                                                                  {
                                                                                                                                      contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::get_storage_native_call_generator::<Runtime,
                                                                                                                                                                                                                                    <Runtime
                                                                                                                                                                                                                                    as
                                                                                                                                                                                                                                    self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                    Block,
                                                                                                                                                                                                                                    AccountId,
                                                                                                                                                                                                                                    Balance>(p.0,
                                                                                                                                                                                                                                             p.1)
                                                                                                                                  }),
                                                                                                                   context,
                                                                                                                   recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 transaction_payment_rpc_runtime_api::TransactionPaymentApi<<Runtime as
                                                            self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                            Balance,
                                                            UncheckedExtrinsic>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn TransactionPaymentApi_query_info_runtime_api_impl(&self,
                                                         at:
                                                             &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                              as
                                                                                                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                         context:
                                                             self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                         params:
                                                             Option<(UncheckedExtrinsic,
                                                                     u32)>,
                                                         params_encoded:
                                                             Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<RuntimeDispatchInfo<Balance>>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::query_info_call_api_at(call_runtime_at,
                                                                                                                                     core_api,
                                                                                                                                     at,
                                                                                                                                     params_encoded,
                                                                                                                                     changes,
                                                                                                                                     initialized_block,
                                                                                                                                     params.map(|p|
                                                                                                                                                    {
                                                                                                                                                        transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::query_info_native_call_generator::<Runtime,
                                                                                                                                                                                                                                                                        <Runtime
                                                                                                                                                                                                                                                                        as
                                                                                                                                                                                                                                                                        self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                                                                        Block,
                                                                                                                                                                                                                                                                        Balance,
                                                                                                                                                                                                                                                                        UncheckedExtrinsic>(p.0,
                                                                                                                                                                                                                                                                                            p.1)
                                                                                                                                                    }),
                                                                                                                                     context,
                                                                                                                                     recorder)
                             })
    }
}
#[cfg(any (feature = "std", test))]
impl <RuntimeApiImplCall: self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::CallRuntimeAt<<Runtime
                                                                                                as
                                                                                                self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock> +
      'static>
 sp_sesssion::SessionKeys<<Runtime as
                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>
 for RuntimeApiImpl<RuntimeApiImplCall> {
    fn SessionKeys_generate_session_keys_runtime_api_impl(&self,
                                                          at:
                                                              &self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::BlockId<<Runtime
                                                                                                                               as
                                                                                                                               self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock>,
                                                          context:
                                                              self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ExecutionContext,
                                                          params:
                                                              Option<(Option<Vec<u8>>)>,
                                                          params_encoded:
                                                              Vec<u8>)
     ->
         std::result::Result<self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::NativeOrEncoded<Vec<u8>>,
                             RuntimeApiImplCall::Error> {
        self.call_api_at(|call_runtime_at, core_api, changes,
                          initialized_block, recorder|
                             {
                                 sp_sesssion::runtime_decl_for_SessionKeys::generate_session_keys_call_api_at(call_runtime_at,
                                                                                                              core_api,
                                                                                                              at,
                                                                                                              params_encoded,
                                                                                                              changes,
                                                                                                              initialized_block,
                                                                                                              params.map(|p|
                                                                                                                             {
                                                                                                                                 sp_sesssion::runtime_decl_for_SessionKeys::generate_session_keys_native_call_generator::<Runtime,
                                                                                                                                                                                                                          <Runtime
                                                                                                                                                                                                                          as
                                                                                                                                                                                                                          self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::GetNodeBlockType>::NodeBlock,
                                                                                                                                                                                                                          Block>(p)
                                                                                                                             }),
                                                                                                              context,
                                                                                                              recorder)
                             })
    }
}
const RUNTIME_API_VERSIONS:
      self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::ApisVec =
    std::borrow::Cow::Borrowed(&[(sp_api::runtime_decl_for_Core::ID,
                                  sp_api::runtime_decl_for_Core::VERSION),
                                 (sp_api::runtime_decl_for_Metadata::ID,
                                  sp_api::runtime_decl_for_Metadata::VERSION),
                                 (block_builder_api::runtime_decl_for_BlockBuilder::ID,
                                  block_builder_api::runtime_decl_for_BlockBuilder::VERSION),
                                 (txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::ID,
                                  txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::VERSION),
                                 (offchain_primitives::runtime_decl_for_OffchainWorkerApi::ID,
                                  offchain_primitives::runtime_decl_for_OffchainWorkerApi::VERSION),
                                 (fg_primitives::runtime_decl_for_GrandpaApi::ID,
                                  fg_primitives::runtime_decl_for_GrandpaApi::VERSION),
                                 (babe_primitives::runtime_decl_for_BabeApi::ID,
                                  babe_primitives::runtime_decl_for_BabeApi::VERSION),
                                 (authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::ID,
                                  authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::VERSION),
                                 (system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::ID,
                                  system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::VERSION),
                                 (contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::ID,
                                  contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::VERSION),
                                 (transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::ID,
                                  transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::VERSION),
                                 (sp_sesssion::runtime_decl_for_SessionKeys::ID,
                                  sp_sesssion::runtime_decl_for_SessionKeys::VERSION)]);
pub mod api {
    use super::*;
    #[cfg(feature = "std")]
    pub fn dispatch(method: &str, mut data: &[u8]) -> Option<Vec<u8>> {
        match method {
            "Core_version" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 sp_api::runtime_decl_for_Core::Core<Block>>::version()
                                                                                         })),
            "Core_execute_block" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let block:
                                                                                                     Block =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"execute_block",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 sp_api::runtime_decl_for_Core::Core<Block>>::execute_block(block)
                                                                                         })),
            "Core_initialize_block" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let header:
                                                                                                     <Block
                                                                                                     as
                                                                                                     BlockT>::Header =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"initialize_block",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 sp_api::runtime_decl_for_Core::Core<Block>>::initialize_block(&header)
                                                                                         })),
            "Metadata_metadata" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 sp_api::runtime_decl_for_Metadata::Metadata<Block>>::metadata()
                                                                                         })),
            "BlockBuilder_apply_extrinsic" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let extrinsic:
                                                                                                     <Block
                                                                                                     as
                                                                                                     BlockT>::Extrinsic =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"apply_extrinsic",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block>>::apply_extrinsic(extrinsic)
                                                                                         })),
            "BlockBuilder_finalize_block" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block>>::finalize_block()
                                                                                         })),
            "BlockBuilder_inherent_extrinsics" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let data:
                                                                                                     InherentData =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"inherent_extrinsics",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block>>::inherent_extrinsics(data)
                                                                                         })),
            "BlockBuilder_check_inherents" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let block:
                                                                                                     Block =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"check_inherents",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let data:
                                                                                                     InherentData =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"check_inherents",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block>>::check_inherents(block,
                                                                                                                                                                                         data)
                                                                                         })),
            "BlockBuilder_random_seed" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 block_builder_api::runtime_decl_for_BlockBuilder::BlockBuilder<Block>>::random_seed()
                                                                                         })),
            "TaggedTransactionQueue_validate_transaction" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let tx:
                                                                                                     <Block
                                                                                                     as
                                                                                                     BlockT>::Extrinsic =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"validate_transaction",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 txpool_runtime_api::runtime_decl_for_TaggedTransactionQueue::TaggedTransactionQueue<Block>>::validate_transaction(tx)
                                                                                         })),
            "OffchainWorkerApi_offchain_worker" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let number:
                                                                                                     NumberFor<Block> =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"offchain_worker",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 offchain_primitives::runtime_decl_for_OffchainWorkerApi::OffchainWorkerApi<Block>>::offchain_worker(number)
                                                                                         })),
            "GrandpaApi_grandpa_authorities" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 fg_primitives::runtime_decl_for_GrandpaApi::GrandpaApi<Block>>::grandpa_authorities()
                                                                                         })),
            "BabeApi_configuration" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 babe_primitives::runtime_decl_for_BabeApi::BabeApi<Block>>::configuration()
                                                                                         })),
            "AuthorityDiscoveryApi_authorities" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 authority_discovery_primitives::runtime_decl_for_AuthorityDiscoveryApi::AuthorityDiscoveryApi<Block>>::authorities()
                                                                                         })),
            "AccountNonceApi_account_nonce" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let account:
                                                                                                     AccountId =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"account_nonce",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 system_rpc_runtime_api::runtime_decl_for_AccountNonceApi::AccountNonceApi<Block,
                                                                                                                                                                           AccountId,
                                                                                                                                                                           Index>>::account_nonce(account)
                                                                                         })),
            "ContractsApi_call" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let origin:
                                                                                                     AccountId =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"call",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let dest:
                                                                                                     AccountId =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"call",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let value:
                                                                                                     Balance =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"call",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let gas_limit:
                                                                                                     u64 =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"call",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let input_data:
                                                                                                     Vec<u8> =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"call",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::ContractsApi<Block,
                                                                                                                                                                        AccountId,
                                                                                                                                                                        Balance>>::call(origin,
                                                                                                                                                                                        dest,
                                                                                                                                                                                        value,
                                                                                                                                                                                        gas_limit,
                                                                                                                                                                                        input_data)
                                                                                         })),
            "ContractsApi_get_storage" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let address:
                                                                                                     AccountId =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"get_storage",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let key:
                                                                                                     [u8; 32] =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"get_storage",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 contracts_rpc_runtime_api::runtime_decl_for_ContractsApi::ContractsApi<Block,
                                                                                                                                                                        AccountId,
                                                                                                                                                                        Balance>>::get_storage(address,
                                                                                                                                                                                               key)
                                                                                         })),
            "TransactionPaymentApi_query_info" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let uxt:
                                                                                                     UncheckedExtrinsic =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"query_info",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };
                                                                                             let len:
                                                                                                     u32 =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"query_info",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 transaction_payment_rpc_runtime_api::runtime_decl_for_TransactionPaymentApi::TransactionPaymentApi<Block,
                                                                                                                                                                                                    Balance,
                                                                                                                                                                                                    UncheckedExtrinsic>>::query_info(uxt,
                                                                                                                                                                                                                                     len)
                                                                                         })),
            "SessionKeys_generate_session_keys" =>
            Some(self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Encode::encode(&{
                                                                                             let seed:
                                                                                                     Option<Vec<u8>> =
                                                                                                 match self::sp_api_hidden_includes_IMPL_RUNTIME_APIS::sp_api::Decode::decode(&mut data)
                                                                                                     {
                                                                                                     Ok(input)
                                                                                                     =>
                                                                                                     input,
                                                                                                     Err(e)
                                                                                                     =>
                                                                                                     {
                                                                                                         ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["Bad input data provided to ",
                                                                                                                                                                      ": "],
                                                                                                                                                                    &match (&"generate_session_keys",
                                                                                                                                                                            &e.what())
                                                                                                                                                                         {
                                                                                                                                                                         (arg0,
                                                                                                                                                                          arg1)
                                                                                                                                                                         =>
                                                                                                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                       ::core::fmt::Display::fmt),
                                                                                                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                                                                                                     }),
                                                                                                                                    &("bin/node/runtime/src/lib.rs",
                                                                                                                                      758u32,
                                                                                                                                      1u32))
                                                                                                     }
                                                                                                 };

                                                                                             #[allow(deprecated)]
                                                                                             <Runtime
                                                                                                 as
                                                                                                 sp_sesssion::runtime_decl_for_SessionKeys::SessionKeys<Block>>::generate_session_keys(seed)
                                                                                         })),
            _ => None,
        }
    }
}
